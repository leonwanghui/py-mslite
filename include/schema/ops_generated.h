// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

namespace mindspore {
namespace schema {

struct Pad;

struct Maximum;

struct Minimum;

struct Flatten;

struct FlattenGrad;

struct Concat;

struct SoftMax;

struct Activation;

struct ActivationGrad;

struct Conv2D;

struct Adder;

struct Conv2DGradFilter;

struct Conv2DGradInput;

struct GroupConv2DGradInput;

struct FusedBatchNorm;

struct BatchNorm;

struct BiasGrad;

struct SoftmaxCrossEntropy;

struct SparseSoftmaxCrossEntropy;

struct make_tuple;

struct PoolingGrad;

struct Shape;

struct ConstantOfShape;

struct Nchw2Nhwc;

struct Nhwc2Nchw;

struct FakeQuantWithMinMaxVars;

struct BiasAdd;

struct ROIPooling;

struct Pooling;

struct DepthwiseConv2D;

struct DeDepthwiseConv2D;

struct Resize;

struct DetectionPostProcess;

struct FullConnection;

struct Mean;

struct DeConv2D;

struct DeConv2DGradFilter;

struct BNGrad;

struct Scale;

struct Eltwise;

struct Add;

struct Sub;

struct Mul;

struct Div;

struct AddGrad;

struct SubGrad;

struct MulGrad;

struct DivGrad;

struct RealDiv;

struct Rsqrt;

struct Equal;

struct Less;

struct Greater;

struct NotEqual;

struct LessEqual;

struct GreaterEqual;

struct Min;

struct Slice;

struct Floor;

struct Abs;

struct Neg;

struct NegGrad;

struct Exp;

struct Cos;

struct Sin;

struct Sqrt;

struct Square;

struct Ceil;

struct Log;

struct LogGrad;

struct Tan;

struct Atan;

struct Asin;

struct Reshape;

struct Power;

struct PowerGrad;

struct ArgMax;

struct ArgMin;

struct NetOutput;

struct MatMul;

struct PReLU;

struct LeakyReLU;

struct StridedSlice;

struct Stack;

struct Range;

struct ExpandDims;

struct Tile;

struct Cast;

struct QuantDTypeCast;

struct Split;

struct Crop;

struct Permute;

struct Clip;

struct Constant;

struct Elu;

struct Broadcast;

struct BroadcastTo;

struct Lrn;

struct Reduce;

struct Transpose;

struct Squeeze;

struct Unsqueeze;

struct Upsample;

struct Dropout;

struct LocalResponseNormalization;

struct ZerosLike;

struct TopK;

struct SpaceToDepth;

struct SpaceToBatch;

struct SparseToDense;

struct ReverseSequence;

struct Rank;

struct Gather;

struct GatherNd;

struct Fill;

struct DepthToSpace;

struct BatchToSpace;

struct BatchToSpaceND;

struct AddN;

struct EmbeddingLookup;

struct EmbeddingLookupSparse;

struct FloorDiv;

struct FloorMod;

struct Mod;

struct L2Norm;

struct LogicalAnd;

struct LogicalOr;

struct LogicalXor;

struct LogicalNot;

struct MatrixDiag;

struct Select;

struct TfReduce;

struct Reverse;

struct Round;

struct Scatter;

struct ScatterND;

struct Unique;

struct Unstack;

struct OnnxInt8Quantize;

struct OnnxInt8Dequantize;

struct FakeQuantWithMinMax;

struct FakeQuantWithMinMaxPerChannel;

struct BatchNormFold;

struct MulFold;

struct AddFold;

struct SquaredDifference;

struct TupleGetItem;

struct ApplyMomentum;

struct Sgd;

struct Adam;

struct Assign;

struct AssignAdd;

struct Where;

struct OneHot;

struct Lstm;

struct PriorBox;

struct SpaceToBatchND;

struct MakeTuple;

struct ToFormat;

struct Depend;

struct ControlDepend;

struct Return;

struct Proposal;

struct Custom;

struct BlackBox;

struct LshProjection;

struct HashtableLookup;

struct SkipGram;

struct CustomPredict;

struct CustomNormalize;

struct CustomExtractFeatures;

struct AudioSpectrogram;

struct Mfcc;

struct Rfft;

struct FftReal;

struct FftImag;

struct DropoutGrad;

struct MaximumGrad;

struct MinimumGrad;

struct NonMaxSuppression;

struct InstanceNorm;

struct Loop;

struct Identity;

struct LayerNorm;

struct While;

struct UnsortedSegmentSum;

struct OnesLike;

struct BinaryCrossEntropy;

struct BinaryCrossEntropyGrad;

struct LpNormalization;

struct Switch;

struct Partial;

struct TensorListFromTensor;

struct TensorListStack;

struct TensorListGetItem;

struct TensorListSetItem;

struct TensorListReserve;

struct All;

struct Assert;

struct SmoothL1Loss;

struct SmoothL1LossGrad;

struct SigmoidCrossEntropyWithLogits;

struct SigmoidCrossEntropyWithLogitsGrad;

struct Reciprocal;

struct Merge;

struct GeLU;

enum ResizeMethod {
  ResizeMethod_UNKNOW = -1,
  ResizeMethod_LINEAR = 0,
  ResizeMethod_NEAREST = 1,
  ResizeMethod_CUBIC = 2,
  ResizeMethod_MIN = ResizeMethod_UNKNOW,
  ResizeMethod_MAX = ResizeMethod_CUBIC
};

inline const ResizeMethod (&EnumValuesResizeMethod())[4] {
  static const ResizeMethod values[] = {
    ResizeMethod_UNKNOW,
    ResizeMethod_LINEAR,
    ResizeMethod_NEAREST,
    ResizeMethod_CUBIC
  };
  return values;
}

inline const char * const *EnumNamesResizeMethod() {
  static const char * const names[] = {
    "UNKNOW",
    "LINEAR",
    "NEAREST",
    "CUBIC",
    nullptr
  };
  return names;
}

inline const char *EnumNameResizeMethod(ResizeMethod e) {
  if (e < ResizeMethod_UNKNOW || e > ResizeMethod_CUBIC) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ResizeMethod_UNKNOW);
  return EnumNamesResizeMethod()[index];
}

enum CoordinateTransformMode {
  CoordinateTransformMode_COMMON = 0,
  CoordinateTransformMode_HALF_PIXEL = 1,
  CoordinateTransformMode_PYTORCH_HALF_PIXEL = 2,
  CoordinateTransformMode_TF_HALF_PIXEL = 3,
  CoordinateTransformMode_TF_CROP_AND_RESIZE = 4,
  CoordinateTransformMode_ALIGN_CORNERS = 5,
  CoordinateTransformMode_ASYMMETRIC = 6,
  CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL = 7,
  CoordinateTransformMode_MIN = CoordinateTransformMode_COMMON,
  CoordinateTransformMode_MAX = CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL
};

inline const CoordinateTransformMode (&EnumValuesCoordinateTransformMode())[8] {
  static const CoordinateTransformMode values[] = {
    CoordinateTransformMode_COMMON,
    CoordinateTransformMode_HALF_PIXEL,
    CoordinateTransformMode_PYTORCH_HALF_PIXEL,
    CoordinateTransformMode_TF_HALF_PIXEL,
    CoordinateTransformMode_TF_CROP_AND_RESIZE,
    CoordinateTransformMode_ALIGN_CORNERS,
    CoordinateTransformMode_ASYMMETRIC,
    CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL
  };
  return values;
}

inline const char * const *EnumNamesCoordinateTransformMode() {
  static const char * const names[] = {
    "COMMON",
    "HALF_PIXEL",
    "PYTORCH_HALF_PIXEL",
    "TF_HALF_PIXEL",
    "TF_CROP_AND_RESIZE",
    "ALIGN_CORNERS",
    "ASYMMETRIC",
    "ALIGN_CORNERS_WITH_HALF_PIEXL",
    nullptr
  };
  return names;
}

inline const char *EnumNameCoordinateTransformMode(CoordinateTransformMode e) {
  if (e < CoordinateTransformMode_COMMON || e > CoordinateTransformMode_ALIGN_CORNERS_WITH_HALF_PIEXL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCoordinateTransformMode()[index];
}

enum NearestMode {
  NearestMode_NORMAL = 0,
  NearestMode_ROUND_HALF_DOWN = 1,
  NearestMode_ROUND_HALF_UP = 2,
  NearestMode_FLOOR = 3,
  NearestMode_CEIL = 4,
  NearestMode_MIN = NearestMode_NORMAL,
  NearestMode_MAX = NearestMode_CEIL
};

inline const NearestMode (&EnumValuesNearestMode())[5] {
  static const NearestMode values[] = {
    NearestMode_NORMAL,
    NearestMode_ROUND_HALF_DOWN,
    NearestMode_ROUND_HALF_UP,
    NearestMode_FLOOR,
    NearestMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesNearestMode() {
  static const char * const names[] = {
    "NORMAL",
    "ROUND_HALF_DOWN",
    "ROUND_HALF_UP",
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameNearestMode(NearestMode e) {
  if (e < NearestMode_NORMAL || e > NearestMode_CEIL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNearestMode()[index];
}

enum Format {
  Format_NCHW = 0,
  Format_NHWC = 1,
  Format_NHWC4 = 2,
  Format_HWKC = 3,
  Format_HWCK = 4,
  Format_KCHW = 5,
  Format_CKHW = 6,
  Format_KHWC = 7,
  Format_CHWK = 8,
  Format_HW = 9,
  Format_HW4 = 10,
  Format_NC = 11,
  Format_NC4 = 12,
  Format_NC4HW4 = 100,
  Format_NUM_OF_FORMAT = 101,
  Format_MIN = Format_NCHW,
  Format_MAX = Format_NUM_OF_FORMAT
};

inline const Format (&EnumValuesFormat())[15] {
  static const Format values[] = {
    Format_NCHW,
    Format_NHWC,
    Format_NHWC4,
    Format_HWKC,
    Format_HWCK,
    Format_KCHW,
    Format_CKHW,
    Format_KHWC,
    Format_CHWK,
    Format_HW,
    Format_HW4,
    Format_NC,
    Format_NC4,
    Format_NC4HW4,
    Format_NUM_OF_FORMAT
  };
  return values;
}

inline const char *EnumNameFormat(Format e) {
  switch (e) {
    case Format_NCHW: return "NCHW";
    case Format_NHWC: return "NHWC";
    case Format_NHWC4: return "NHWC4";
    case Format_HWKC: return "HWKC";
    case Format_HWCK: return "HWCK";
    case Format_KCHW: return "KCHW";
    case Format_CKHW: return "CKHW";
    case Format_KHWC: return "KHWC";
    case Format_CHWK: return "CHWK";
    case Format_HW: return "HW";
    case Format_HW4: return "HW4";
    case Format_NC: return "NC";
    case Format_NC4: return "NC4";
    case Format_NC4HW4: return "NC4HW4";
    case Format_NUM_OF_FORMAT: return "NUM_OF_FORMAT";
    default: return "";
  }
}

enum ActivationType {
  ActivationType_NO_ACTIVATION = 0,
  ActivationType_RELU = 1,
  ActivationType_SIGMOID = 2,
  ActivationType_RELU6 = 3,
  ActivationType_ELU = 4,
  ActivationType_LEAKY_RELU = 5,
  ActivationType_ABS = 6,
  ActivationType_RELU1 = 7,
  ActivationType_SOFTSIGN = 8,
  ActivationType_SOFTPLUS = 9,
  ActivationType_TANH = 10,
  ActivationType_SELU = 11,
  ActivationType_HSWISH = 12,
  ActivationType_HSIGMOID = 13,
  ActivationType_THRESHOLDRELU = 14,
  ActivationType_LINEAR = 15,
  ActivationType_HARD_TANH = 16,
  ActivationType_SIGN = 17,
  ActivationType_SWISH = 18,
  ActivationType_UNKNOW = 19,
  ActivationType_MIN = ActivationType_NO_ACTIVATION,
  ActivationType_MAX = ActivationType_UNKNOW
};

inline const ActivationType (&EnumValuesActivationType())[20] {
  static const ActivationType values[] = {
    ActivationType_NO_ACTIVATION,
    ActivationType_RELU,
    ActivationType_SIGMOID,
    ActivationType_RELU6,
    ActivationType_ELU,
    ActivationType_LEAKY_RELU,
    ActivationType_ABS,
    ActivationType_RELU1,
    ActivationType_SOFTSIGN,
    ActivationType_SOFTPLUS,
    ActivationType_TANH,
    ActivationType_SELU,
    ActivationType_HSWISH,
    ActivationType_HSIGMOID,
    ActivationType_THRESHOLDRELU,
    ActivationType_LINEAR,
    ActivationType_HARD_TANH,
    ActivationType_SIGN,
    ActivationType_SWISH,
    ActivationType_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesActivationType() {
  static const char * const names[] = {
    "NO_ACTIVATION",
    "RELU",
    "SIGMOID",
    "RELU6",
    "ELU",
    "LEAKY_RELU",
    "ABS",
    "RELU1",
    "SOFTSIGN",
    "SOFTPLUS",
    "TANH",
    "SELU",
    "HSWISH",
    "HSIGMOID",
    "THRESHOLDRELU",
    "LINEAR",
    "HARD_TANH",
    "SIGN",
    "SWISH",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationType(ActivationType e) {
  if (e < ActivationType_NO_ACTIVATION || e > ActivationType_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationType()[index];
}

enum ActivationGradType {
  ActivationGradType_NO_ACTIVATION = 0,
  ActivationGradType_RELU = 1,
  ActivationGradType_SIGMOID = 2,
  ActivationGradType_RELU6 = 3,
  ActivationGradType_ELU = 4,
  ActivationGradType_LEAKY_RELU = 5,
  ActivationGradType_ABS = 6,
  ActivationGradType_RELU1 = 7,
  ActivationGradType_SOFTSIGN = 8,
  ActivationGradType_SOFTPLUS = 9,
  ActivationGradType_TANH = 10,
  ActivationGradType_SELU = 11,
  ActivationGradType_HSWISH = 12,
  ActivationGradType_HSIGMOID = 13,
  ActivationGradType_THRESHOLDRELU = 14,
  ActivationGradType_LINEAR = 15,
  ActivationGradType_UNKNOW = 16,
  ActivationGradType_MIN = ActivationGradType_NO_ACTIVATION,
  ActivationGradType_MAX = ActivationGradType_UNKNOW
};

inline const ActivationGradType (&EnumValuesActivationGradType())[17] {
  static const ActivationGradType values[] = {
    ActivationGradType_NO_ACTIVATION,
    ActivationGradType_RELU,
    ActivationGradType_SIGMOID,
    ActivationGradType_RELU6,
    ActivationGradType_ELU,
    ActivationGradType_LEAKY_RELU,
    ActivationGradType_ABS,
    ActivationGradType_RELU1,
    ActivationGradType_SOFTSIGN,
    ActivationGradType_SOFTPLUS,
    ActivationGradType_TANH,
    ActivationGradType_SELU,
    ActivationGradType_HSWISH,
    ActivationGradType_HSIGMOID,
    ActivationGradType_THRESHOLDRELU,
    ActivationGradType_LINEAR,
    ActivationGradType_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesActivationGradType() {
  static const char * const names[] = {
    "NO_ACTIVATION",
    "RELU",
    "SIGMOID",
    "RELU6",
    "ELU",
    "LEAKY_RELU",
    "ABS",
    "RELU1",
    "SOFTSIGN",
    "SOFTPLUS",
    "TANH",
    "SELU",
    "HSWISH",
    "HSIGMOID",
    "THRESHOLDRELU",
    "LINEAR",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameActivationGradType(ActivationGradType e) {
  if (e < ActivationGradType_NO_ACTIVATION || e > ActivationGradType_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesActivationGradType()[index];
}

enum ReduceType {
  ReduceType_REDUCE_MAX = 0,
  ReduceType_REDUCE_MEAN = 1,
  ReduceType_REDUCE_ALL = 2,
  ReduceType_REDUCE_ANY = 3,
  ReduceType_REDUCE_LOG_SUM_EXP = 4,
  ReduceType_REDUCE_PROD = 5,
  ReduceType_REDUCE_SUM = 6,
  ReduceType_UNKNOW = 7,
  ReduceType_MIN = ReduceType_REDUCE_MAX,
  ReduceType_MAX = ReduceType_UNKNOW
};

inline const ReduceType (&EnumValuesReduceType())[8] {
  static const ReduceType values[] = {
    ReduceType_REDUCE_MAX,
    ReduceType_REDUCE_MEAN,
    ReduceType_REDUCE_ALL,
    ReduceType_REDUCE_ANY,
    ReduceType_REDUCE_LOG_SUM_EXP,
    ReduceType_REDUCE_PROD,
    ReduceType_REDUCE_SUM,
    ReduceType_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesReduceType() {
  static const char * const names[] = {
    "REDUCE_MAX",
    "REDUCE_MEAN",
    "REDUCE_ALL",
    "REDUCE_ANY",
    "REDUCE_LOG_SUM_EXP",
    "REDUCE_PROD",
    "REDUCE_SUM",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceType(ReduceType e) {
  if (e < ReduceType_REDUCE_MAX || e > ReduceType_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceType()[index];
}

enum PoolMode {
  PoolMode_MAX_POOLING = 0,
  PoolMode_MEAN_POOLING = 1,
  PoolMode_MIN = PoolMode_MAX_POOLING,
  PoolMode_MAX = PoolMode_MEAN_POOLING
};

inline const PoolMode (&EnumValuesPoolMode())[2] {
  static const PoolMode values[] = {
    PoolMode_MAX_POOLING,
    PoolMode_MEAN_POOLING
  };
  return values;
}

inline const char * const *EnumNamesPoolMode() {
  static const char * const names[] = {
    "MAX_POOLING",
    "MEAN_POOLING",
    nullptr
  };
  return names;
}

inline const char *EnumNamePoolMode(PoolMode e) {
  if (e < PoolMode_MAX_POOLING || e > PoolMode_MEAN_POOLING) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPoolMode()[index];
}

enum EltwiseMode {
  EltwiseMode_PROD = 0,
  EltwiseMode_SUM = 1,
  EltwiseMode_MAXIMUM = 2,
  EltwiseMode_UNKNOW = 3,
  EltwiseMode_MIN = EltwiseMode_PROD,
  EltwiseMode_MAX = EltwiseMode_UNKNOW
};

inline const EltwiseMode (&EnumValuesEltwiseMode())[4] {
  static const EltwiseMode values[] = {
    EltwiseMode_PROD,
    EltwiseMode_SUM,
    EltwiseMode_MAXIMUM,
    EltwiseMode_UNKNOW
  };
  return values;
}

inline const char * const *EnumNamesEltwiseMode() {
  static const char * const names[] = {
    "PROD",
    "SUM",
    "MAXIMUM",
    "UNKNOW",
    nullptr
  };
  return names;
}

inline const char *EnumNameEltwiseMode(EltwiseMode e) {
  if (e < EltwiseMode_PROD || e > EltwiseMode_UNKNOW) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesEltwiseMode()[index];
}

enum PadMode {
  PadMode_NOTSET = 0,
  PadMode_SAME_UPPER = 1,
  PadMode_VALID = 2,
  PadMode_CAFFE = 4,
  PadMode_SAME_LOWER = 5,
  PadMode_MIN = PadMode_NOTSET,
  PadMode_MAX = PadMode_SAME_LOWER
};

inline const PadMode (&EnumValuesPadMode())[5] {
  static const PadMode values[] = {
    PadMode_NOTSET,
    PadMode_SAME_UPPER,
    PadMode_VALID,
    PadMode_CAFFE,
    PadMode_SAME_LOWER
  };
  return values;
}

inline const char * const *EnumNamesPadMode() {
  static const char * const names[] = {
    "NOTSET",
    "SAME_UPPER",
    "VALID",
    "",
    "CAFFE",
    "SAME_LOWER",
    nullptr
  };
  return names;
}

inline const char *EnumNamePadMode(PadMode e) {
  if (e < PadMode_NOTSET || e > PadMode_SAME_LOWER) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPadMode()[index];
}

enum RoundMode {
  RoundMode_FLOOR = 0,
  RoundMode_CEIL = 1,
  RoundMode_MIN = RoundMode_FLOOR,
  RoundMode_MAX = RoundMode_CEIL
};

inline const RoundMode (&EnumValuesRoundMode())[2] {
  static const RoundMode values[] = {
    RoundMode_FLOOR,
    RoundMode_CEIL
  };
  return values;
}

inline const char * const *EnumNamesRoundMode() {
  static const char * const names[] = {
    "FLOOR",
    "CEIL",
    nullptr
  };
  return names;
}

inline const char *EnumNameRoundMode(RoundMode e) {
  if (e < RoundMode_FLOOR || e > RoundMode_CEIL) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRoundMode()[index];
}

enum PaddingMode {
  PaddingMode_CONSTANT = 0,
  PaddingMode_REFLECT = 1,
  PaddingMode_SYMMETRIC = 2,
  PaddingMode_MODE_RESERVED = 3,
  PaddingMode_MIN = PaddingMode_CONSTANT,
  PaddingMode_MAX = PaddingMode_MODE_RESERVED
};

inline const PaddingMode (&EnumValuesPaddingMode())[4] {
  static const PaddingMode values[] = {
    PaddingMode_CONSTANT,
    PaddingMode_REFLECT,
    PaddingMode_SYMMETRIC,
    PaddingMode_MODE_RESERVED
  };
  return values;
}

inline const char * const *EnumNamesPaddingMode() {
  static const char * const names[] = {
    "CONSTANT",
    "REFLECT",
    "SYMMETRIC",
    "MODE_RESERVED",
    nullptr
  };
  return names;
}

inline const char *EnumNamePaddingMode(PaddingMode e) {
  if (e < PaddingMode_CONSTANT || e > PaddingMode_MODE_RESERVED) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPaddingMode()[index];
}

enum LshProjectionType {
  LshProjectionType_UNKNOWN = 0,
  LshProjectionType_SPARSE = 1,
  LshProjectionType_DENSE = 2,
  LshProjectionType_MIN = LshProjectionType_UNKNOWN,
  LshProjectionType_MAX = LshProjectionType_DENSE
};

inline const LshProjectionType (&EnumValuesLshProjectionType())[3] {
  static const LshProjectionType values[] = {
    LshProjectionType_UNKNOWN,
    LshProjectionType_SPARSE,
    LshProjectionType_DENSE
  };
  return values;
}

inline const char * const *EnumNamesLshProjectionType() {
  static const char * const names[] = {
    "UNKNOWN",
    "SPARSE",
    "DENSE",
    nullptr
  };
  return names;
}

inline const char *EnumNameLshProjectionType(LshProjectionType e) {
  if (e < LshProjectionType_UNKNOWN || e > LshProjectionType_DENSE) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesLshProjectionType()[index];
}

enum ReduceMode {
  ReduceMode_ReduceMean = 0,
  ReduceMode_ReduceMax = 1,
  ReduceMode_ReduceMin = 2,
  ReduceMode_ReduceProd = 3,
  ReduceMode_ReduceSum = 4,
  ReduceMode_ReduceSumSquare = 5,
  ReduceMode_ReduceASum = 6,
  ReduceMode_ReduceAll = 7,
  ReduceMode_MIN = ReduceMode_ReduceMean,
  ReduceMode_MAX = ReduceMode_ReduceAll
};

inline const ReduceMode (&EnumValuesReduceMode())[8] {
  static const ReduceMode values[] = {
    ReduceMode_ReduceMean,
    ReduceMode_ReduceMax,
    ReduceMode_ReduceMin,
    ReduceMode_ReduceProd,
    ReduceMode_ReduceSum,
    ReduceMode_ReduceSumSquare,
    ReduceMode_ReduceASum,
    ReduceMode_ReduceAll
  };
  return values;
}

inline const char * const *EnumNamesReduceMode() {
  static const char * const names[] = {
    "ReduceMean",
    "ReduceMax",
    "ReduceMin",
    "ReduceProd",
    "ReduceSum",
    "ReduceSumSquare",
    "ReduceASum",
    "ReduceAll",
    nullptr
  };
  return names;
}

inline const char *EnumNameReduceMode(ReduceMode e) {
  if (e < ReduceMode_ReduceMean || e > ReduceMode_ReduceAll) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesReduceMode()[index];
}

struct Pad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PADDINGS = 4,
    VT_PADDINGMODE = 6,
    VT_CONSTANTVALUE = 8
  };
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  PaddingMode paddingMode() const {
    return static_cast<PaddingMode>(GetField<int8_t>(VT_PADDINGMODE, 0));
  }
  float constantValue() const {
    return GetField<float>(VT_CONSTANTVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           VerifyField<int8_t>(verifier, VT_PADDINGMODE) &&
           VerifyField<float>(verifier, VT_CONSTANTVALUE) &&
           verifier.EndTable();
  }
};

struct PadBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(Pad::VT_PADDINGS, paddings);
  }
  void add_paddingMode(PaddingMode paddingMode) {
    fbb_.AddElement<int8_t>(Pad::VT_PADDINGMODE, static_cast<int8_t>(paddingMode), 0);
  }
  void add_constantValue(float constantValue) {
    fbb_.AddElement<float>(Pad::VT_CONSTANTVALUE, constantValue, 0.0f);
  }
  explicit PadBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PadBuilder &operator=(const PadBuilder &);
  flatbuffers::Offset<Pad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pad>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pad> CreatePad(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0,
    PaddingMode paddingMode = PaddingMode_CONSTANT,
    float constantValue = 0.0f) {
  PadBuilder builder_(_fbb);
  builder_.add_constantValue(constantValue);
  builder_.add_paddings(paddings);
  builder_.add_paddingMode(paddingMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Pad> CreatePadDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *paddings = nullptr,
    PaddingMode paddingMode = PaddingMode_CONSTANT,
    float constantValue = 0.0f) {
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::CreatePad(
      _fbb,
      paddings__,
      paddingMode,
      constantValue);
}

struct Maximum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MaximumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumBuilder &operator=(const MaximumBuilder &);
  flatbuffers::Offset<Maximum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Maximum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Maximum> CreateMaximum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Minimum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MinimumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinimumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MinimumBuilder &operator=(const MinimumBuilder &);
  flatbuffers::Offset<Minimum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Minimum>(end);
    return o;
  }
};

inline flatbuffers::Offset<Minimum> CreateMinimum(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinimumBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Flatten FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FlattenBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlattenBuilder &operator=(const FlattenBuilder &);
  flatbuffers::Offset<Flatten> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Flatten>(end);
    return o;
  }
};

inline flatbuffers::Offset<Flatten> CreateFlatten(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FlattenGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FlattenGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FlattenGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FlattenGradBuilder &operator=(const FlattenGradBuilder &);
  flatbuffers::Offset<FlattenGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FlattenGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<FlattenGrad> CreateFlattenGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FlattenGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Concat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_N = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           verifier.EndTable();
  }
};

struct ConcatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Concat::VT_AXIS, axis, 0);
  }
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Concat::VT_N, n, 0);
  }
  explicit ConcatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConcatBuilder &operator=(const ConcatBuilder &);
  flatbuffers::Offset<Concat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Concat>(end);
    return o;
  }
};

inline flatbuffers::Offset<Concat> CreateConcat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0) {
  ConcatBuilder builder_(_fbb);
  builder_.add_n(n);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct SoftMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, -1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct SoftMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(SoftMax::VT_AXIS, axis, -1);
  }
  explicit SoftMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftMaxBuilder &operator=(const SoftMaxBuilder &);
  flatbuffers::Offset<SoftMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftMax> CreateSoftMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = -1) {
  SoftMaxBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Activation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ALPHA = 6,
    VT_MIN_VAL = 8,
    VT_MAX_VAL = 10
  };
  ActivationType type() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_TYPE, 0));
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.2f);
  }
  float min_val() const {
    return GetField<float>(VT_MIN_VAL, -1.0f);
  }
  float max_val() const {
    return GetField<float>(VT_MAX_VAL, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_MIN_VAL) &&
           VerifyField<float>(verifier, VT_MAX_VAL) &&
           verifier.EndTable();
  }
};

struct ActivationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ActivationType type) {
    fbb_.AddElement<int8_t>(Activation::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Activation::VT_ALPHA, alpha, 0.2f);
  }
  void add_min_val(float min_val) {
    fbb_.AddElement<float>(Activation::VT_MIN_VAL, min_val, -1.0f);
  }
  void add_max_val(float max_val) {
    fbb_.AddElement<float>(Activation::VT_MAX_VAL, max_val, 1.0f);
  }
  explicit ActivationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActivationBuilder &operator=(const ActivationBuilder &);
  flatbuffers::Offset<Activation> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Activation>(end);
    return o;
  }
};

inline flatbuffers::Offset<Activation> CreateActivation(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationType type = ActivationType_NO_ACTIVATION,
    float alpha = 0.2f,
    float min_val = -1.0f,
    float max_val = 1.0f) {
  ActivationBuilder builder_(_fbb);
  builder_.add_max_val(max_val);
  builder_.add_min_val(min_val);
  builder_.add_alpha(alpha);
  builder_.add_type(type);
  return builder_.Finish();
}

struct ActivationGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4,
    VT_ALPHA = 6
  };
  ActivationType type() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_TYPE, 0));
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.2f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct ActivationGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ActivationType type) {
    fbb_.AddElement<int8_t>(ActivationGrad::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(ActivationGrad::VT_ALPHA, alpha, 0.2f);
  }
  explicit ActivationGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ActivationGradBuilder &operator=(const ActivationGradBuilder &);
  flatbuffers::Offset<ActivationGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ActivationGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<ActivationGrad> CreateActivationGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationType type = ActivationType_NO_ACTIVATION,
    float alpha = 0.2f) {
  ActivationGradBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Conv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Conv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2D::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2D::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DBuilder &operator=(const Conv2DBuilder &);
  flatbuffers::Offset<Conv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2D> CreateConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  Conv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct Adder FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct AdderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Adder::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Adder::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Adder::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Adder::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Adder::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Adder::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Adder::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Adder::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Adder::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Adder::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Adder::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Adder::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Adder::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Adder::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Adder::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Adder::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Adder::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit AdderBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AdderBuilder &operator=(const AdderBuilder &);
  flatbuffers::Offset<Adder> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Adder>(end);
    return o;
  }
};

inline flatbuffers::Offset<Adder> CreateAdder(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  AdderBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct Conv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_FILTER_SHAPE = 36,
    VT_ACTIVATIONTYPE = 38
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *filter_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_FILTER_SHAPE);
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyOffset(verifier, VT_FILTER_SHAPE) &&
           verifier.VerifyVector(filter_shape()) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DGradFilterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2DGradFilter::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2DGradFilter::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2DGradFilter::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_filter_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> filter_shape) {
    fbb_.AddOffset(Conv2DGradFilter::VT_FILTER_SHAPE, filter_shape);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2DGradFilter::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DGradFilterBuilder &operator=(const Conv2DGradFilterBuilder &);
  flatbuffers::Offset<Conv2DGradFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DGradFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DGradFilter> CreateConv2DGradFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> filter_shape = 0,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  Conv2DGradFilterBuilder builder_(_fbb);
  builder_.add_filter_shape(filter_shape);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DGradFilter> CreateConv2DGradFilterDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    const std::vector<int32_t> *filter_shape = nullptr,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  auto filter_shape__ = filter_shape ? _fbb.CreateVector<int32_t>(*filter_shape) : 0;
  return mindspore::schema::CreateConv2DGradFilter(
      _fbb,
      format,
      group,
      channelIn,
      channelOut,
      kernelW,
      kernelH,
      strideW,
      strideH,
      padMode,
      padUp,
      padDown,
      padLeft,
      padRight,
      dilateW,
      dilateH,
      hasBias,
      filter_shape__,
      activationType);
}

struct Conv2DGradInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_INPUT_SHAPE = 36,
    VT_ACTIVATIONTYPE = 38
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *input_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_SHAPE);
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyOffset(verifier, VT_INPUT_SHAPE) &&
           verifier.VerifyVector(input_shape()) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct Conv2DGradInputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Conv2DGradInput::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(Conv2DGradInput::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(Conv2DGradInput::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_input_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape) {
    fbb_.AddOffset(Conv2DGradInput::VT_INPUT_SHAPE, input_shape);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Conv2DGradInput::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit Conv2DGradInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Conv2DGradInputBuilder &operator=(const Conv2DGradInputBuilder &);
  flatbuffers::Offset<Conv2DGradInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Conv2DGradInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<Conv2DGradInput> CreateConv2DGradInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape = 0,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  Conv2DGradInputBuilder builder_(_fbb);
  builder_.add_input_shape(input_shape);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Conv2DGradInput> CreateConv2DGradInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    const std::vector<int32_t> *input_shape = nullptr,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  auto input_shape__ = input_shape ? _fbb.CreateVector<int32_t>(*input_shape) : 0;
  return mindspore::schema::CreateConv2DGradInput(
      _fbb,
      format,
      group,
      channelIn,
      channelOut,
      kernelW,
      kernelH,
      strideW,
      strideH,
      padMode,
      padUp,
      padDown,
      padLeft,
      padRight,
      dilateW,
      dilateH,
      hasBias,
      input_shape__,
      activationType);
}

struct GroupConv2DGradInput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_INPUT_SHAPE = 36,
    VT_ACTIVATIONTYPE = 38
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  const flatbuffers::Vector<int32_t> *input_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_INPUT_SHAPE);
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyOffset(verifier, VT_INPUT_SHAPE) &&
           verifier.VerifyVector(input_shape()) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct GroupConv2DGradInputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(GroupConv2DGradInput::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(GroupConv2DGradInput::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(GroupConv2DGradInput::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_input_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape) {
    fbb_.AddOffset(GroupConv2DGradInput::VT_INPUT_SHAPE, input_shape);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(GroupConv2DGradInput::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit GroupConv2DGradInputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GroupConv2DGradInputBuilder &operator=(const GroupConv2DGradInputBuilder &);
  flatbuffers::Offset<GroupConv2DGradInput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GroupConv2DGradInput>(end);
    return o;
  }
};

inline flatbuffers::Offset<GroupConv2DGradInput> CreateGroupConv2DGradInput(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> input_shape = 0,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  GroupConv2DGradInputBuilder builder_(_fbb);
  builder_.add_input_shape(input_shape);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<GroupConv2DGradInput> CreateGroupConv2DGradInputDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    const std::vector<int32_t> *input_shape = nullptr,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  auto input_shape__ = input_shape ? _fbb.CreateVector<int32_t>(*input_shape) : 0;
  return mindspore::schema::CreateGroupConv2DGradInput(
      _fbb,
      format,
      group,
      channelIn,
      channelOut,
      kernelW,
      kernelH,
      strideW,
      strideH,
      padMode,
      padUp,
      padDown,
      padLeft,
      padRight,
      dilateW,
      dilateH,
      hasBias,
      input_shape__,
      activationType);
}

struct FusedBatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4,
    VT_MOMENTUM = 6,
    VT_SPATIAL = 8
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.9f);
  }
  int32_t spatial() const {
    return GetField<int32_t>(VT_SPATIAL, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           VerifyField<int32_t>(verifier, VT_SPATIAL) &&
           verifier.EndTable();
  }
};

struct FusedBatchNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(FusedBatchNorm::VT_MOMENTUM, momentum, 0.9f);
  }
  void add_spatial(int32_t spatial) {
    fbb_.AddElement<int32_t>(FusedBatchNorm::VT_SPATIAL, spatial, 1);
  }
  explicit FusedBatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FusedBatchNormBuilder &operator=(const FusedBatchNormBuilder &);
  flatbuffers::Offset<FusedBatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FusedBatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<FusedBatchNorm> CreateFusedBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.00001f,
    float momentum = 0.9f,
    int32_t spatial = 1) {
  FusedBatchNormBuilder builder_(_fbb);
  builder_.add_spatial(spatial);
  builder_.add_momentum(momentum);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct BatchNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
};

struct BatchNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(BatchNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  explicit BatchNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchNormBuilder &operator=(const BatchNormBuilder &);
  flatbuffers::Offset<BatchNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNorm> CreateBatchNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.00001f) {
  BatchNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct BiasGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BiasGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BiasGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BiasGradBuilder &operator=(const BiasGradBuilder &);
  flatbuffers::Offset<BiasGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasGrad> CreateBiasGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BiasGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SoftmaxCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SoftmaxCrossEntropyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SoftmaxCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SoftmaxCrossEntropyBuilder &operator=(const SoftmaxCrossEntropyBuilder &);
  flatbuffers::Offset<SoftmaxCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SoftmaxCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<SoftmaxCrossEntropy> CreateSoftmaxCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SoftmaxCrossEntropyBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SparseSoftmaxCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ISGRAD = 4
  };
  int32_t isGrad() const {
    return GetField<int32_t>(VT_ISGRAD, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ISGRAD) &&
           verifier.EndTable();
  }
};

struct SparseSoftmaxCrossEntropyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_isGrad(int32_t isGrad) {
    fbb_.AddElement<int32_t>(SparseSoftmaxCrossEntropy::VT_ISGRAD, isGrad, 0);
  }
  explicit SparseSoftmaxCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseSoftmaxCrossEntropyBuilder &operator=(const SparseSoftmaxCrossEntropyBuilder &);
  flatbuffers::Offset<SparseSoftmaxCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseSoftmaxCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseSoftmaxCrossEntropy> CreateSparseSoftmaxCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t isGrad = 0) {
  SparseSoftmaxCrossEntropyBuilder builder_(_fbb);
  builder_.add_isGrad(isGrad);
  return builder_.Finish();
}

struct make_tuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct make_tupleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit make_tupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  make_tupleBuilder &operator=(const make_tupleBuilder &);
  flatbuffers::Offset<make_tuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<make_tuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<make_tuple> Createmake_tuple(
    flatbuffers::FlatBufferBuilder &_fbb) {
  make_tupleBuilder builder_(_fbb);
  return builder_.Finish();
}

struct PoolingGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_POOLINGMODE = 6,
    VT_GLOBAL = 8,
    VT_WINDOWW = 10,
    VT_WINDOWH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_ROUNDMODE = 28
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  PoolMode poolingMode() const {
    return static_cast<PoolMode>(GetField<int8_t>(VT_POOLINGMODE, 0));
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  int32_t windowW() const {
    return GetField<int32_t>(VT_WINDOWW, 0);
  }
  int32_t windowH() const {
    return GetField<int32_t>(VT_WINDOWH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  RoundMode roundMode() const {
    return static_cast<RoundMode>(GetField<int8_t>(VT_ROUNDMODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_POOLINGMODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int32_t>(verifier, VT_WINDOWW) &&
           VerifyField<int32_t>(verifier, VT_WINDOWH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int8_t>(verifier, VT_ROUNDMODE) &&
           verifier.EndTable();
  }
};

struct PoolingGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_poolingMode(PoolMode poolingMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_POOLINGMODE, static_cast<int8_t>(poolingMode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(PoolingGrad::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_windowW(int32_t windowW) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_WINDOWW, windowW, 0);
  }
  void add_windowH(int32_t windowH) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_WINDOWH, windowH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(PoolingGrad::VT_PADRIGHT, padRight, 0);
  }
  void add_roundMode(RoundMode roundMode) {
    fbb_.AddElement<int8_t>(PoolingGrad::VT_ROUNDMODE, static_cast<int8_t>(roundMode), 0);
  }
  explicit PoolingGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingGradBuilder &operator=(const PoolingGradBuilder &);
  flatbuffers::Offset<PoolingGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PoolingGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PoolingGrad> CreatePoolingGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    PoolMode poolingMode = PoolMode_MAX_POOLING,
    bool global = false,
    int32_t windowW = 0,
    int32_t windowH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    RoundMode roundMode = RoundMode_FLOOR) {
  PoolingGradBuilder builder_(_fbb);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_windowH(windowH);
  builder_.add_windowW(windowW);
  builder_.add_format(format);
  builder_.add_roundMode(roundMode);
  builder_.add_padMode(padMode);
  builder_.add_global(global);
  builder_.add_poolingMode(poolingMode);
  return builder_.Finish();
}

struct Shape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ShapeBuilder &operator=(const ShapeBuilder &);
  flatbuffers::Offset<Shape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Shape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Shape> CreateShape(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ShapeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ConstantOfShape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DATATYPE = 4,
    VT_VALUE = 6
  };
  int32_t dataType() const {
    return GetField<int32_t>(VT_DATATYPE, 0);
  }
  const flatbuffers::Vector<float> *value() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           verifier.VerifyVector(value()) &&
           verifier.EndTable();
  }
};

struct ConstantOfShapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dataType(int32_t dataType) {
    fbb_.AddElement<int32_t>(ConstantOfShape::VT_DATATYPE, dataType, 0);
  }
  void add_value(flatbuffers::Offset<flatbuffers::Vector<float>> value) {
    fbb_.AddOffset(ConstantOfShape::VT_VALUE, value);
  }
  explicit ConstantOfShapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstantOfShapeBuilder &operator=(const ConstantOfShapeBuilder &);
  flatbuffers::Offset<ConstantOfShape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ConstantOfShape>(end);
    return o;
  }
};

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShape(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dataType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> value = 0) {
  ConstantOfShapeBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_dataType(dataType);
  return builder_.Finish();
}

inline flatbuffers::Offset<ConstantOfShape> CreateConstantOfShapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dataType = 0,
    const std::vector<float> *value = nullptr) {
  auto value__ = value ? _fbb.CreateVector<float>(*value) : 0;
  return mindspore::schema::CreateConstantOfShape(
      _fbb,
      dataType,
      value__);
}

struct Nchw2Nhwc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Nchw2NhwcBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Nchw2NhwcBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Nchw2NhwcBuilder &operator=(const Nchw2NhwcBuilder &);
  flatbuffers::Offset<Nchw2Nhwc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nchw2Nhwc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nchw2Nhwc> CreateNchw2Nhwc(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Nchw2NhwcBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Nhwc2Nchw FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct Nhwc2NchwBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit Nhwc2NchwBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  Nhwc2NchwBuilder &operator=(const Nhwc2NchwBuilder &);
  flatbuffers::Offset<Nhwc2Nchw> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Nhwc2Nchw>(end);
    return o;
  }
};

inline flatbuffers::Offset<Nhwc2Nchw> CreateNhwc2Nchw(
    flatbuffers::FlatBufferBuilder &_fbb) {
  Nhwc2NchwBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantWithMinMaxVars FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NARROWRANGE = 4,
    VT_NUMBITS = 6
  };
  bool narrowRange() const {
    return GetField<uint8_t>(VT_NARROWRANGE, 0) != 0;
  }
  int32_t numBits() const {
    return GetField<int32_t>(VT_NUMBITS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxVarsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_narrowRange(bool narrowRange) {
    fbb_.AddElement<uint8_t>(FakeQuantWithMinMaxVars::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 0);
  }
  void add_numBits(int32_t numBits) {
    fbb_.AddElement<int32_t>(FakeQuantWithMinMaxVars::VT_NUMBITS, numBits, 0);
  }
  explicit FakeQuantWithMinMaxVarsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantWithMinMaxVarsBuilder &operator=(const FakeQuantWithMinMaxVarsBuilder &);
  flatbuffers::Offset<FakeQuantWithMinMaxVars> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxVars>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxVars> CreateFakeQuantWithMinMaxVars(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool narrowRange = false,
    int32_t numBits = 0) {
  FakeQuantWithMinMaxVarsBuilder builder_(_fbb);
  builder_.add_numBits(numBits);
  builder_.add_narrowRange(narrowRange);
  return builder_.Finish();
}

struct BiasAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct BiasAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(BiasAdd::VT_AXIS, axis);
  }
  explicit BiasAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BiasAddBuilder &operator=(const BiasAddBuilder &);
  flatbuffers::Offset<BiasAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BiasAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<BiasAdd> CreateBiasAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  BiasAddBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<BiasAdd> CreateBiasAddDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateBiasAdd(
      _fbb,
      axis__);
}

struct ROIPooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POOLEDH = 4,
    VT_POOLEDW = 6,
    VT_SCALE = 8
  };
  int32_t pooledH() const {
    return GetField<int32_t>(VT_POOLEDH, 0);
  }
  int32_t pooledW() const {
    return GetField<int32_t>(VT_POOLEDW, 0);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_POOLEDH) &&
           VerifyField<int32_t>(verifier, VT_POOLEDW) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           verifier.EndTable();
  }
};

struct ROIPoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_pooledH(int32_t pooledH) {
    fbb_.AddElement<int32_t>(ROIPooling::VT_POOLEDH, pooledH, 0);
  }
  void add_pooledW(int32_t pooledW) {
    fbb_.AddElement<int32_t>(ROIPooling::VT_POOLEDW, pooledW, 0);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(ROIPooling::VT_SCALE, scale, 0.0f);
  }
  explicit ROIPoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ROIPoolingBuilder &operator=(const ROIPoolingBuilder &);
  flatbuffers::Offset<ROIPooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ROIPooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<ROIPooling> CreateROIPooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t pooledH = 0,
    int32_t pooledW = 0,
    float scale = 0.0f) {
  ROIPoolingBuilder builder_(_fbb);
  builder_.add_scale(scale);
  builder_.add_pooledW(pooledW);
  builder_.add_pooledH(pooledH);
  return builder_.Finish();
}

struct Pooling FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_POOLINGMODE = 6,
    VT_GLOBAL = 8,
    VT_WINDOWW = 10,
    VT_WINDOWH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_ROUNDMODE = 28,
    VT_ACTIVATIONTYPE = 30,
    VT_AVGMODE = 32
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  PoolMode poolingMode() const {
    return static_cast<PoolMode>(GetField<int8_t>(VT_POOLINGMODE, 0));
  }
  bool global() const {
    return GetField<uint8_t>(VT_GLOBAL, 0) != 0;
  }
  int32_t windowW() const {
    return GetField<int32_t>(VT_WINDOWW, 0);
  }
  int32_t windowH() const {
    return GetField<int32_t>(VT_WINDOWH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  RoundMode roundMode() const {
    return static_cast<RoundMode>(GetField<int8_t>(VT_ROUNDMODE, 0));
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  int32_t avgMode() const {
    return GetField<int32_t>(VT_AVGMODE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_POOLINGMODE) &&
           VerifyField<uint8_t>(verifier, VT_GLOBAL) &&
           VerifyField<int32_t>(verifier, VT_WINDOWW) &&
           VerifyField<int32_t>(verifier, VT_WINDOWH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int8_t>(verifier, VT_ROUNDMODE) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           VerifyField<int32_t>(verifier, VT_AVGMODE) &&
           verifier.EndTable();
  }
};

struct PoolingBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Pooling::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_poolingMode(PoolMode poolingMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_POOLINGMODE, static_cast<int8_t>(poolingMode), 0);
  }
  void add_global(bool global) {
    fbb_.AddElement<uint8_t>(Pooling::VT_GLOBAL, static_cast<uint8_t>(global), 0);
  }
  void add_windowW(int32_t windowW) {
    fbb_.AddElement<int32_t>(Pooling::VT_WINDOWW, windowW, 0);
  }
  void add_windowH(int32_t windowH) {
    fbb_.AddElement<int32_t>(Pooling::VT_WINDOWH, windowH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(Pooling::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(Pooling::VT_PADRIGHT, padRight, 0);
  }
  void add_roundMode(RoundMode roundMode) {
    fbb_.AddElement<int8_t>(Pooling::VT_ROUNDMODE, static_cast<int8_t>(roundMode), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Pooling::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  void add_avgMode(int32_t avgMode) {
    fbb_.AddElement<int32_t>(Pooling::VT_AVGMODE, avgMode, 0);
  }
  explicit PoolingBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PoolingBuilder &operator=(const PoolingBuilder &);
  flatbuffers::Offset<Pooling> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Pooling>(end);
    return o;
  }
};

inline flatbuffers::Offset<Pooling> CreatePooling(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    PoolMode poolingMode = PoolMode_MAX_POOLING,
    bool global = false,
    int32_t windowW = 0,
    int32_t windowH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    RoundMode roundMode = RoundMode_FLOOR,
    ActivationType activationType = ActivationType_NO_ACTIVATION,
    int32_t avgMode = 0) {
  PoolingBuilder builder_(_fbb);
  builder_.add_avgMode(avgMode);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_windowH(windowH);
  builder_.add_windowW(windowW);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_roundMode(roundMode);
  builder_.add_padMode(padMode);
  builder_.add_global(global);
  builder_.add_poolingMode(poolingMode);
  return builder_.Finish();
}

struct DepthwiseConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_CHANNELIN = 6,
    VT_CHANNELMULTIPLIER = 8,
    VT_KERNELW = 10,
    VT_KERNELH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_DILATEW = 28,
    VT_DILATEH = 30,
    VT_HASBIAS = 32,
    VT_ACTIVATIONTYPE = 34
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelMultiplier() const {
    return GetField<int32_t>(VT_CHANNELMULTIPLIER, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELMULTIPLIER) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DepthwiseConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelMultiplier(int32_t channelMultiplier) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_CHANNELMULTIPLIER, channelMultiplier, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(DepthwiseConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DepthwiseConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DepthwiseConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(DepthwiseConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DepthwiseConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthwiseConv2DBuilder &operator=(const DepthwiseConv2DBuilder &);
  flatbuffers::Offset<DepthwiseConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthwiseConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthwiseConv2D> CreateDepthwiseConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t channelIn = 0,
    int32_t channelMultiplier = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DepthwiseConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelMultiplier(channelMultiplier);
  builder_.add_channelIn(channelIn);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct DeDepthwiseConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_CHANNELIN = 6,
    VT_CHANNELMULTIPLIER = 8,
    VT_KERNELW = 10,
    VT_KERNELH = 12,
    VT_STRIDEW = 14,
    VT_STRIDEH = 16,
    VT_PADMODE = 18,
    VT_PADUP = 20,
    VT_PADDOWN = 22,
    VT_PADLEFT = 24,
    VT_PADRIGHT = 26,
    VT_DILATEW = 28,
    VT_DILATEH = 30,
    VT_HASBIAS = 32,
    VT_ACTIVATIONTYPE = 34
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelMultiplier() const {
    return GetField<int32_t>(VT_CHANNELMULTIPLIER, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELMULTIPLIER) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DeDepthwiseConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelMultiplier(int32_t channelMultiplier) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_CHANNELMULTIPLIER, channelMultiplier, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(DeDepthwiseConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeDepthwiseConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeDepthwiseConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeDepthwiseConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeDepthwiseConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeDepthwiseConv2DBuilder &operator=(const DeDepthwiseConv2DBuilder &);
  flatbuffers::Offset<DeDepthwiseConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeDepthwiseConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeDepthwiseConv2D> CreateDeDepthwiseConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t channelIn = 0,
    int32_t channelMultiplier = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DeDepthwiseConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelMultiplier(channelMultiplier);
  builder_.add_channelIn(channelIn);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct Resize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_METHOD = 6,
    VT_NEWHEIGHT = 8,
    VT_NEWWIDTH = 10,
    VT_ALIGNCORNERS = 12,
    VT_PRESERVEASPECTRATIO = 14,
    VT_COORDINATETRANSFORMMODE = 16,
    VT_CUBICCOEFF = 18,
    VT_EXCLUDEOUTSIDE = 20,
    VT_EXTRAPOLATIONVALUE = 22,
    VT_NEARESTMODE = 24
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  ResizeMethod method() const {
    return static_cast<ResizeMethod>(GetField<int8_t>(VT_METHOD, 0));
  }
  int64_t newHeight() const {
    return GetField<int64_t>(VT_NEWHEIGHT, 0);
  }
  int64_t newWidth() const {
    return GetField<int64_t>(VT_NEWWIDTH, 0);
  }
  bool alignCorners() const {
    return GetField<uint8_t>(VT_ALIGNCORNERS, 0) != 0;
  }
  bool preserveAspectRatio() const {
    return GetField<uint8_t>(VT_PRESERVEASPECTRATIO, 0) != 0;
  }
  CoordinateTransformMode coordinateTransformMode() const {
    return static_cast<CoordinateTransformMode>(GetField<int8_t>(VT_COORDINATETRANSFORMMODE, 0));
  }
  float cubicCoeff() const {
    return GetField<float>(VT_CUBICCOEFF, 0.0f);
  }
  int32_t excludeOutside() const {
    return GetField<int32_t>(VT_EXCLUDEOUTSIDE, 0);
  }
  float extrapolationValue() const {
    return GetField<float>(VT_EXTRAPOLATIONVALUE, 0.0f);
  }
  NearestMode nearestMode() const {
    return static_cast<NearestMode>(GetField<int8_t>(VT_NEARESTMODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int8_t>(verifier, VT_METHOD) &&
           VerifyField<int64_t>(verifier, VT_NEWHEIGHT) &&
           VerifyField<int64_t>(verifier, VT_NEWWIDTH) &&
           VerifyField<uint8_t>(verifier, VT_ALIGNCORNERS) &&
           VerifyField<uint8_t>(verifier, VT_PRESERVEASPECTRATIO) &&
           VerifyField<int8_t>(verifier, VT_COORDINATETRANSFORMMODE) &&
           VerifyField<float>(verifier, VT_CUBICCOEFF) &&
           VerifyField<int32_t>(verifier, VT_EXCLUDEOUTSIDE) &&
           VerifyField<float>(verifier, VT_EXTRAPOLATIONVALUE) &&
           VerifyField<int8_t>(verifier, VT_NEARESTMODE) &&
           verifier.EndTable();
  }
};

struct ResizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Resize::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_method(ResizeMethod method) {
    fbb_.AddElement<int8_t>(Resize::VT_METHOD, static_cast<int8_t>(method), 0);
  }
  void add_newHeight(int64_t newHeight) {
    fbb_.AddElement<int64_t>(Resize::VT_NEWHEIGHT, newHeight, 0);
  }
  void add_newWidth(int64_t newWidth) {
    fbb_.AddElement<int64_t>(Resize::VT_NEWWIDTH, newWidth, 0);
  }
  void add_alignCorners(bool alignCorners) {
    fbb_.AddElement<uint8_t>(Resize::VT_ALIGNCORNERS, static_cast<uint8_t>(alignCorners), 0);
  }
  void add_preserveAspectRatio(bool preserveAspectRatio) {
    fbb_.AddElement<uint8_t>(Resize::VT_PRESERVEASPECTRATIO, static_cast<uint8_t>(preserveAspectRatio), 0);
  }
  void add_coordinateTransformMode(CoordinateTransformMode coordinateTransformMode) {
    fbb_.AddElement<int8_t>(Resize::VT_COORDINATETRANSFORMMODE, static_cast<int8_t>(coordinateTransformMode), 0);
  }
  void add_cubicCoeff(float cubicCoeff) {
    fbb_.AddElement<float>(Resize::VT_CUBICCOEFF, cubicCoeff, 0.0f);
  }
  void add_excludeOutside(int32_t excludeOutside) {
    fbb_.AddElement<int32_t>(Resize::VT_EXCLUDEOUTSIDE, excludeOutside, 0);
  }
  void add_extrapolationValue(float extrapolationValue) {
    fbb_.AddElement<float>(Resize::VT_EXTRAPOLATIONVALUE, extrapolationValue, 0.0f);
  }
  void add_nearestMode(NearestMode nearestMode) {
    fbb_.AddElement<int8_t>(Resize::VT_NEARESTMODE, static_cast<int8_t>(nearestMode), 0);
  }
  explicit ResizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ResizeBuilder &operator=(const ResizeBuilder &);
  flatbuffers::Offset<Resize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Resize>(end);
    return o;
  }
};

inline flatbuffers::Offset<Resize> CreateResize(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    ResizeMethod method = ResizeMethod_LINEAR,
    int64_t newHeight = 0,
    int64_t newWidth = 0,
    bool alignCorners = false,
    bool preserveAspectRatio = false,
    CoordinateTransformMode coordinateTransformMode = CoordinateTransformMode_COMMON,
    float cubicCoeff = 0.0f,
    int32_t excludeOutside = 0,
    float extrapolationValue = 0.0f,
    NearestMode nearestMode = NearestMode_NORMAL) {
  ResizeBuilder builder_(_fbb);
  builder_.add_newWidth(newWidth);
  builder_.add_newHeight(newHeight);
  builder_.add_extrapolationValue(extrapolationValue);
  builder_.add_excludeOutside(excludeOutside);
  builder_.add_cubicCoeff(cubicCoeff);
  builder_.add_format(format);
  builder_.add_nearestMode(nearestMode);
  builder_.add_coordinateTransformMode(coordinateTransformMode);
  builder_.add_preserveAspectRatio(preserveAspectRatio);
  builder_.add_alignCorners(alignCorners);
  builder_.add_method(method);
  return builder_.Finish();
}

struct DetectionPostProcess FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_INPUTSIZE = 6,
    VT_HSCALE = 8,
    VT_WSCALE = 10,
    VT_XSCALE = 12,
    VT_YSCALE = 14,
    VT_NMSIOUTHRESHOLD = 16,
    VT_NMSSCORETHRESHOLD = 18,
    VT_MAXDETECTIONS = 20,
    VT_DETECTIONSPERCLASS = 22,
    VT_MAXCLASSESPERDETECTION = 24,
    VT_NUMCLASSES = 26,
    VT_USEREGULARNMS = 28,
    VT_OUTQUANTIZED = 30
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t inputSize() const {
    return GetField<int32_t>(VT_INPUTSIZE, 0);
  }
  float hScale() const {
    return GetField<float>(VT_HSCALE, 0.0f);
  }
  float wScale() const {
    return GetField<float>(VT_WSCALE, 0.0f);
  }
  float xScale() const {
    return GetField<float>(VT_XSCALE, 0.0f);
  }
  float yScale() const {
    return GetField<float>(VT_YSCALE, 0.0f);
  }
  float NmsIouThreshold() const {
    return GetField<float>(VT_NMSIOUTHRESHOLD, 0.0f);
  }
  float NmsScoreThreshold() const {
    return GetField<float>(VT_NMSSCORETHRESHOLD, 0.0f);
  }
  int64_t MaxDetections() const {
    return GetField<int64_t>(VT_MAXDETECTIONS, 0);
  }
  int64_t DetectionsPerClass() const {
    return GetField<int64_t>(VT_DETECTIONSPERCLASS, 0);
  }
  int64_t MaxClassesPerDetection() const {
    return GetField<int64_t>(VT_MAXCLASSESPERDETECTION, 0);
  }
  int64_t NumClasses() const {
    return GetField<int64_t>(VT_NUMCLASSES, 0);
  }
  bool UseRegularNms() const {
    return GetField<uint8_t>(VT_USEREGULARNMS, 0) != 0;
  }
  bool OutQuantized() const {
    return GetField<uint8_t>(VT_OUTQUANTIZED, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_INPUTSIZE) &&
           VerifyField<float>(verifier, VT_HSCALE) &&
           VerifyField<float>(verifier, VT_WSCALE) &&
           VerifyField<float>(verifier, VT_XSCALE) &&
           VerifyField<float>(verifier, VT_YSCALE) &&
           VerifyField<float>(verifier, VT_NMSIOUTHRESHOLD) &&
           VerifyField<float>(verifier, VT_NMSSCORETHRESHOLD) &&
           VerifyField<int64_t>(verifier, VT_MAXDETECTIONS) &&
           VerifyField<int64_t>(verifier, VT_DETECTIONSPERCLASS) &&
           VerifyField<int64_t>(verifier, VT_MAXCLASSESPERDETECTION) &&
           VerifyField<int64_t>(verifier, VT_NUMCLASSES) &&
           VerifyField<uint8_t>(verifier, VT_USEREGULARNMS) &&
           VerifyField<uint8_t>(verifier, VT_OUTQUANTIZED) &&
           verifier.EndTable();
  }
};

struct DetectionPostProcessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_inputSize(int32_t inputSize) {
    fbb_.AddElement<int32_t>(DetectionPostProcess::VT_INPUTSIZE, inputSize, 0);
  }
  void add_hScale(float hScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_HSCALE, hScale, 0.0f);
  }
  void add_wScale(float wScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_WSCALE, wScale, 0.0f);
  }
  void add_xScale(float xScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_XSCALE, xScale, 0.0f);
  }
  void add_yScale(float yScale) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_YSCALE, yScale, 0.0f);
  }
  void add_NmsIouThreshold(float NmsIouThreshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMSIOUTHRESHOLD, NmsIouThreshold, 0.0f);
  }
  void add_NmsScoreThreshold(float NmsScoreThreshold) {
    fbb_.AddElement<float>(DetectionPostProcess::VT_NMSSCORETHRESHOLD, NmsScoreThreshold, 0.0f);
  }
  void add_MaxDetections(int64_t MaxDetections) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAXDETECTIONS, MaxDetections, 0);
  }
  void add_DetectionsPerClass(int64_t DetectionsPerClass) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_DETECTIONSPERCLASS, DetectionsPerClass, 0);
  }
  void add_MaxClassesPerDetection(int64_t MaxClassesPerDetection) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_MAXCLASSESPERDETECTION, MaxClassesPerDetection, 0);
  }
  void add_NumClasses(int64_t NumClasses) {
    fbb_.AddElement<int64_t>(DetectionPostProcess::VT_NUMCLASSES, NumClasses, 0);
  }
  void add_UseRegularNms(bool UseRegularNms) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_USEREGULARNMS, static_cast<uint8_t>(UseRegularNms), 0);
  }
  void add_OutQuantized(bool OutQuantized) {
    fbb_.AddElement<uint8_t>(DetectionPostProcess::VT_OUTQUANTIZED, static_cast<uint8_t>(OutQuantized), 0);
  }
  explicit DetectionPostProcessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DetectionPostProcessBuilder &operator=(const DetectionPostProcessBuilder &);
  flatbuffers::Offset<DetectionPostProcess> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DetectionPostProcess>(end);
    return o;
  }
};

inline flatbuffers::Offset<DetectionPostProcess> CreateDetectionPostProcess(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t inputSize = 0,
    float hScale = 0.0f,
    float wScale = 0.0f,
    float xScale = 0.0f,
    float yScale = 0.0f,
    float NmsIouThreshold = 0.0f,
    float NmsScoreThreshold = 0.0f,
    int64_t MaxDetections = 0,
    int64_t DetectionsPerClass = 0,
    int64_t MaxClassesPerDetection = 0,
    int64_t NumClasses = 0,
    bool UseRegularNms = false,
    bool OutQuantized = false) {
  DetectionPostProcessBuilder builder_(_fbb);
  builder_.add_NumClasses(NumClasses);
  builder_.add_MaxClassesPerDetection(MaxClassesPerDetection);
  builder_.add_DetectionsPerClass(DetectionsPerClass);
  builder_.add_MaxDetections(MaxDetections);
  builder_.add_NmsScoreThreshold(NmsScoreThreshold);
  builder_.add_NmsIouThreshold(NmsIouThreshold);
  builder_.add_yScale(yScale);
  builder_.add_xScale(xScale);
  builder_.add_wScale(wScale);
  builder_.add_hScale(hScale);
  builder_.add_inputSize(inputSize);
  builder_.add_format(format);
  builder_.add_OutQuantized(OutQuantized);
  builder_.add_UseRegularNms(UseRegularNms);
  return builder_.Finish();
}

struct FullConnection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_HASBIAS = 4,
    VT_AXIS = 6,
    VT_USEAXIS = 8,
    VT_ACTIVATIONTYPE = 10
  };
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool useAxis() const {
    return GetField<uint8_t>(VT_USEAXIS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_USEAXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct FullConnectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(FullConnection::VT_AXIS, axis, 0);
  }
  void add_useAxis(bool useAxis) {
    fbb_.AddElement<uint8_t>(FullConnection::VT_USEAXIS, static_cast<uint8_t>(useAxis), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(FullConnection::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit FullConnectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FullConnectionBuilder &operator=(const FullConnectionBuilder &);
  flatbuffers::Offset<FullConnection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FullConnection>(end);
    return o;
  }
};

inline flatbuffers::Offset<FullConnection> CreateFullConnection(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool hasBias = false,
    int32_t axis = 0,
    bool useAxis = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  FullConnectionBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activationType(activationType);
  builder_.add_useAxis(useAxis);
  builder_.add_hasBias(hasBias);
  return builder_.Finish();
}

struct Mean FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_KEEPDIMS = 6
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           verifier.EndTable();
  }
};

struct MeanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Mean::VT_AXIS, axis);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(Mean::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  explicit MeanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MeanBuilder &operator=(const MeanBuilder &);
  flatbuffers::Offset<Mean> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mean>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mean> CreateMean(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    bool keepDims = false) {
  MeanBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mean> CreateMeanDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    bool keepDims = false) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateMean(
      _fbb,
      axis__,
      keepDims);
}

struct DeConv2D FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DeConv2DBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(DeConv2D::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeConv2D::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeConv2D::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeConv2D::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeConv2DBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeConv2DBuilder &operator=(const DeConv2DBuilder &);
  flatbuffers::Offset<DeConv2D> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeConv2D>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeConv2D> CreateDeConv2D(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DeConv2DBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct DeConv2DGradFilter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_GROUP = 6,
    VT_CHANNELIN = 8,
    VT_CHANNELOUT = 10,
    VT_KERNELW = 12,
    VT_KERNELH = 14,
    VT_STRIDEW = 16,
    VT_STRIDEH = 18,
    VT_PADMODE = 20,
    VT_PADUP = 22,
    VT_PADDOWN = 24,
    VT_PADLEFT = 26,
    VT_PADRIGHT = 28,
    VT_DILATEW = 30,
    VT_DILATEH = 32,
    VT_HASBIAS = 34,
    VT_ACTIVATIONTYPE = 36
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t group() const {
    return GetField<int32_t>(VT_GROUP, 0);
  }
  int32_t channelIn() const {
    return GetField<int32_t>(VT_CHANNELIN, 0);
  }
  int32_t channelOut() const {
    return GetField<int32_t>(VT_CHANNELOUT, 0);
  }
  int32_t kernelW() const {
    return GetField<int32_t>(VT_KERNELW, 0);
  }
  int32_t kernelH() const {
    return GetField<int32_t>(VT_KERNELH, 0);
  }
  int32_t strideW() const {
    return GetField<int32_t>(VT_STRIDEW, 0);
  }
  int32_t strideH() const {
    return GetField<int32_t>(VT_STRIDEH, 0);
  }
  PadMode padMode() const {
    return static_cast<PadMode>(GetField<int8_t>(VT_PADMODE, 0));
  }
  int32_t padUp() const {
    return GetField<int32_t>(VT_PADUP, 0);
  }
  int32_t padDown() const {
    return GetField<int32_t>(VT_PADDOWN, 0);
  }
  int32_t padLeft() const {
    return GetField<int32_t>(VT_PADLEFT, 0);
  }
  int32_t padRight() const {
    return GetField<int32_t>(VT_PADRIGHT, 0);
  }
  int32_t dilateW() const {
    return GetField<int32_t>(VT_DILATEW, 0);
  }
  int32_t dilateH() const {
    return GetField<int32_t>(VT_DILATEH, 0);
  }
  bool hasBias() const {
    return GetField<uint8_t>(VT_HASBIAS, 0) != 0;
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_GROUP) &&
           VerifyField<int32_t>(verifier, VT_CHANNELIN) &&
           VerifyField<int32_t>(verifier, VT_CHANNELOUT) &&
           VerifyField<int32_t>(verifier, VT_KERNELW) &&
           VerifyField<int32_t>(verifier, VT_KERNELH) &&
           VerifyField<int32_t>(verifier, VT_STRIDEW) &&
           VerifyField<int32_t>(verifier, VT_STRIDEH) &&
           VerifyField<int8_t>(verifier, VT_PADMODE) &&
           VerifyField<int32_t>(verifier, VT_PADUP) &&
           VerifyField<int32_t>(verifier, VT_PADDOWN) &&
           VerifyField<int32_t>(verifier, VT_PADLEFT) &&
           VerifyField<int32_t>(verifier, VT_PADRIGHT) &&
           VerifyField<int32_t>(verifier, VT_DILATEW) &&
           VerifyField<int32_t>(verifier, VT_DILATEH) &&
           VerifyField<uint8_t>(verifier, VT_HASBIAS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DeConv2DGradFilterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_group(int32_t group) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_GROUP, group, 0);
  }
  void add_channelIn(int32_t channelIn) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_CHANNELIN, channelIn, 0);
  }
  void add_channelOut(int32_t channelOut) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_CHANNELOUT, channelOut, 0);
  }
  void add_kernelW(int32_t kernelW) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_KERNELW, kernelW, 0);
  }
  void add_kernelH(int32_t kernelH) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_KERNELH, kernelH, 0);
  }
  void add_strideW(int32_t strideW) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_STRIDEW, strideW, 0);
  }
  void add_strideH(int32_t strideH) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_STRIDEH, strideH, 0);
  }
  void add_padMode(PadMode padMode) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_PADMODE, static_cast<int8_t>(padMode), 0);
  }
  void add_padUp(int32_t padUp) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADUP, padUp, 0);
  }
  void add_padDown(int32_t padDown) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADDOWN, padDown, 0);
  }
  void add_padLeft(int32_t padLeft) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADLEFT, padLeft, 0);
  }
  void add_padRight(int32_t padRight) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_PADRIGHT, padRight, 0);
  }
  void add_dilateW(int32_t dilateW) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_DILATEW, dilateW, 0);
  }
  void add_dilateH(int32_t dilateH) {
    fbb_.AddElement<int32_t>(DeConv2DGradFilter::VT_DILATEH, dilateH, 0);
  }
  void add_hasBias(bool hasBias) {
    fbb_.AddElement<uint8_t>(DeConv2DGradFilter::VT_HASBIAS, static_cast<uint8_t>(hasBias), 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(DeConv2DGradFilter::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DeConv2DGradFilterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DeConv2DGradFilterBuilder &operator=(const DeConv2DGradFilterBuilder &);
  flatbuffers::Offset<DeConv2DGradFilter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DeConv2DGradFilter>(end);
    return o;
  }
};

inline flatbuffers::Offset<DeConv2DGradFilter> CreateDeConv2DGradFilter(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    int32_t group = 0,
    int32_t channelIn = 0,
    int32_t channelOut = 0,
    int32_t kernelW = 0,
    int32_t kernelH = 0,
    int32_t strideW = 0,
    int32_t strideH = 0,
    PadMode padMode = PadMode_NOTSET,
    int32_t padUp = 0,
    int32_t padDown = 0,
    int32_t padLeft = 0,
    int32_t padRight = 0,
    int32_t dilateW = 0,
    int32_t dilateH = 0,
    bool hasBias = false,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DeConv2DGradFilterBuilder builder_(_fbb);
  builder_.add_dilateH(dilateH);
  builder_.add_dilateW(dilateW);
  builder_.add_padRight(padRight);
  builder_.add_padLeft(padLeft);
  builder_.add_padDown(padDown);
  builder_.add_padUp(padUp);
  builder_.add_strideH(strideH);
  builder_.add_strideW(strideW);
  builder_.add_kernelH(kernelH);
  builder_.add_kernelW(kernelW);
  builder_.add_channelOut(channelOut);
  builder_.add_channelIn(channelIn);
  builder_.add_group(group);
  builder_.add_format(format);
  builder_.add_activationType(activationType);
  builder_.add_hasBias(hasBias);
  builder_.add_padMode(padMode);
  return builder_.Finish();
}

struct BNGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPS = 4,
    VT_MOMENTUM = 6
  };
  float eps() const {
    return GetField<float>(VT_EPS, 0.0f);
  }
  float momentum() const {
    return GetField<float>(VT_MOMENTUM, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPS) &&
           VerifyField<float>(verifier, VT_MOMENTUM) &&
           verifier.EndTable();
  }
};

struct BNGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_eps(float eps) {
    fbb_.AddElement<float>(BNGrad::VT_EPS, eps, 0.0f);
  }
  void add_momentum(float momentum) {
    fbb_.AddElement<float>(BNGrad::VT_MOMENTUM, momentum, 0.0f);
  }
  explicit BNGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BNGradBuilder &operator=(const BNGradBuilder &);
  flatbuffers::Offset<BNGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BNGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BNGrad> CreateBNGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float eps = 0.0f,
    float momentum = 0.0f) {
  BNGradBuilder builder_(_fbb);
  builder_.add_momentum(momentum);
  builder_.add_eps(eps);
  return builder_.Finish();
}

struct Scale FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_ACTIVATIONTYPE = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct ScaleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Scale::VT_AXIS, axis, 0);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Scale::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit ScaleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScaleBuilder &operator=(const ScaleBuilder &);
  flatbuffers::Offset<Scale> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scale>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scale> CreateScale(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  ScaleBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

struct Eltwise FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4
  };
  EltwiseMode mode() const {
    return static_cast<EltwiseMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           verifier.EndTable();
  }
};

struct EltwiseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(EltwiseMode mode) {
    fbb_.AddElement<int8_t>(Eltwise::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  explicit EltwiseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EltwiseBuilder &operator=(const EltwiseBuilder &);
  flatbuffers::Offset<Eltwise> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Eltwise>(end);
    return o;
  }
};

inline flatbuffers::Offset<Eltwise> CreateEltwise(
    flatbuffers::FlatBufferBuilder &_fbb,
    EltwiseMode mode = EltwiseMode_PROD) {
  EltwiseBuilder builder_(_fbb);
  builder_.add_mode(mode);
  return builder_.Finish();
}

struct Add FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct AddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Add::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit AddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddBuilder &operator=(const AddBuilder &);
  flatbuffers::Offset<Add> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Add>(end);
    return o;
  }
};

inline flatbuffers::Offset<Add> CreateAdd(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  AddBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

struct Sub FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct SubBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Sub::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit SubBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubBuilder &operator=(const SubBuilder &);
  flatbuffers::Offset<Sub> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sub>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sub> CreateSub(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  SubBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

struct Mul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct MulBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Mul::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit MulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulBuilder &operator=(const MulBuilder &);
  flatbuffers::Offset<Mul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mul>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mul> CreateMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  MulBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

struct Div FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ACTIVATIONTYPE = 4
  };
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct DivBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(Div::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit DivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivBuilder &operator=(const DivBuilder &);
  flatbuffers::Offset<Div> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Div>(end);
    return o;
  }
};

inline flatbuffers::Offset<Div> CreateDiv(
    flatbuffers::FlatBufferBuilder &_fbb,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  DivBuilder builder_(_fbb);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

struct AddGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddGradBuilder &operator=(const AddGradBuilder &);
  flatbuffers::Offset<AddGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddGrad> CreateAddGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SubGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SubGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SubGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGradBuilder &operator=(const SubGradBuilder &);
  flatbuffers::Offset<SubGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGrad> CreateSubGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SubGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MulGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MulGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulGradBuilder &operator=(const MulGradBuilder &);
  flatbuffers::Offset<MulGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulGrad> CreateMulGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DivGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DivGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DivGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DivGradBuilder &operator=(const DivGradBuilder &);
  flatbuffers::Offset<DivGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DivGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DivGrad> CreateDivGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DivGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct RealDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RealDivBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RealDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RealDivBuilder &operator=(const RealDivBuilder &);
  flatbuffers::Offset<RealDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<RealDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<RealDiv> CreateRealDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RealDivBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Rsqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RsqrtBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RsqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RsqrtBuilder &operator=(const RsqrtBuilder &);
  flatbuffers::Offset<Rsqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rsqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rsqrt> CreateRsqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RsqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Equal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct EqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit EqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EqualBuilder &operator=(const EqualBuilder &);
  flatbuffers::Offset<Equal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Equal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Equal> CreateEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  EqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Less FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessBuilder &operator=(const LessBuilder &);
  flatbuffers::Offset<Less> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Less>(end);
    return o;
  }
};

inline flatbuffers::Offset<Less> CreateLess(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Greater FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterBuilder &operator=(const GreaterBuilder &);
  flatbuffers::Offset<Greater> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Greater>(end);
    return o;
  }
};

inline flatbuffers::Offset<Greater> CreateGreater(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NotEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NotEqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NotEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NotEqualBuilder &operator=(const NotEqualBuilder &);
  flatbuffers::Offset<NotEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NotEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<NotEqual> CreateNotEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NotEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LessEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LessEqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LessEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LessEqualBuilder &operator=(const LessEqualBuilder &);
  flatbuffers::Offset<LessEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LessEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<LessEqual> CreateLessEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LessEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GreaterEqual FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct GreaterEqualBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit GreaterEqualBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GreaterEqualBuilder &operator=(const GreaterEqualBuilder &);
  flatbuffers::Offset<GreaterEqual> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GreaterEqual>(end);
    return o;
  }
};

inline flatbuffers::Offset<GreaterEqual> CreateGreaterEqual(
    flatbuffers::FlatBufferBuilder &_fbb) {
  GreaterEqualBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Min FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MinBuilder &operator=(const MinBuilder &);
  flatbuffers::Offset<Min> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Min>(end);
    return o;
  }
};

inline flatbuffers::Offset<Min> CreateMin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Slice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_AXES = 6,
    VT_BEGIN = 8,
    VT_SIZE = 10
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  const flatbuffers::Vector<int32_t> *begin() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  const flatbuffers::Vector<int32_t> *size() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyVector(begin()) &&
           VerifyOffset(verifier, VT_SIZE) &&
           verifier.VerifyVector(size()) &&
           verifier.EndTable();
  }
};

struct SliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Slice::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(Slice::VT_AXES, axes);
  }
  void add_begin(flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin) {
    fbb_.AddOffset(Slice::VT_BEGIN, begin);
  }
  void add_size(flatbuffers::Offset<flatbuffers::Vector<int32_t>> size) {
    fbb_.AddOffset(Slice::VT_SIZE, size);
  }
  explicit SliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SliceBuilder &operator=(const SliceBuilder &);
  flatbuffers::Offset<Slice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Slice>(end);
    return o;
  }
};

inline flatbuffers::Offset<Slice> CreateSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> size = 0) {
  SliceBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_begin(begin);
  builder_.add_axes(axes);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slice> CreateSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    const std::vector<int32_t> *axes = nullptr,
    const std::vector<int32_t> *begin = nullptr,
    const std::vector<int32_t> *size = nullptr) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  auto begin__ = begin ? _fbb.CreateVector<int32_t>(*begin) : 0;
  auto size__ = size ? _fbb.CreateVector<int32_t>(*size) : 0;
  return mindspore::schema::CreateSlice(
      _fbb,
      format,
      axes__,
      begin__,
      size__);
}

struct Floor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorBuilder &operator=(const FloorBuilder &);
  flatbuffers::Offset<Floor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Floor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Floor> CreateFloor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Abs FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AbsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AbsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AbsBuilder &operator=(const AbsBuilder &);
  flatbuffers::Offset<Abs> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Abs>(end);
    return o;
  }
};

inline flatbuffers::Offset<Abs> CreateAbs(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AbsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Neg FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NegBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegBuilder &operator=(const NegBuilder &);
  flatbuffers::Offset<Neg> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Neg>(end);
    return o;
  }
};

inline flatbuffers::Offset<Neg> CreateNeg(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NegGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NegGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NegGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NegGradBuilder &operator=(const NegGradBuilder &);
  flatbuffers::Offset<NegGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NegGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<NegGrad> CreateNegGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NegGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Exp FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BASE = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float base() const {
    return GetField<float>(VT_BASE, -1.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 1.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BASE) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct ExpBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_base(float base) {
    fbb_.AddElement<float>(Exp::VT_BASE, base, -1.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(Exp::VT_SCALE, scale, 1.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(Exp::VT_SHIFT, shift, 0.0f);
  }
  explicit ExpBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpBuilder &operator=(const ExpBuilder &);
  flatbuffers::Offset<Exp> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Exp>(end);
    return o;
  }
};

inline flatbuffers::Offset<Exp> CreateExp(
    flatbuffers::FlatBufferBuilder &_fbb,
    float base = -1.0f,
    float scale = 1.0f,
    float shift = 0.0f) {
  ExpBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_base(base);
  return builder_.Finish();
}

struct Cos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CosBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CosBuilder &operator=(const CosBuilder &);
  flatbuffers::Offset<Cos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cos>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cos> CreateCos(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CosBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Sin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SinBuilder &operator=(const SinBuilder &);
  flatbuffers::Offset<Sin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sin> CreateSin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SinBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Sqrt FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SqrtBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SqrtBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqrtBuilder &operator=(const SqrtBuilder &);
  flatbuffers::Offset<Sqrt> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sqrt>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sqrt> CreateSqrt(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SqrtBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Square FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquareBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquareBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquareBuilder &operator=(const SquareBuilder &);
  flatbuffers::Offset<Square> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Square>(end);
    return o;
  }
};

inline flatbuffers::Offset<Square> CreateSquare(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquareBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Ceil FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CeilBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CeilBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CeilBuilder &operator=(const CeilBuilder &);
  flatbuffers::Offset<Ceil> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Ceil>(end);
    return o;
  }
};

inline flatbuffers::Offset<Ceil> CreateCeil(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CeilBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Log FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogBuilder &operator=(const LogBuilder &);
  flatbuffers::Offset<Log> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Log>(end);
    return o;
  }
};

inline flatbuffers::Offset<Log> CreateLog(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogGradBuilder &operator=(const LogGradBuilder &);
  flatbuffers::Offset<LogGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogGrad> CreateLogGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Tan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TanBuilder &operator=(const TanBuilder &);
  flatbuffers::Offset<Tan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tan>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tan> CreateTan(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TanBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Atan FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AtanBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AtanBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AtanBuilder &operator=(const AtanBuilder &);
  flatbuffers::Offset<Atan> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Atan>(end);
    return o;
  }
};

inline flatbuffers::Offset<Atan> CreateAtan(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AtanBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Asin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AsinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AsinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AsinBuilder &operator=(const AsinBuilder &);
  flatbuffers::Offset<Asin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Asin>(end);
    return o;
  }
};

inline flatbuffers::Offset<Asin> CreateAsin(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AsinBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Reshape FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FORMAT = 4,
    VT_SHAPE = 6
  };
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  const flatbuffers::Vector<int64_t> *shape() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyOffset(verifier, VT_SHAPE) &&
           verifier.VerifyVector(shape()) &&
           verifier.EndTable();
  }
};

struct ReshapeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Reshape::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_shape(flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape) {
    fbb_.AddOffset(Reshape::VT_SHAPE, shape);
  }
  explicit ReshapeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReshapeBuilder &operator=(const ReshapeBuilder &);
  flatbuffers::Offset<Reshape> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reshape>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reshape> CreateReshape(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> shape = 0) {
  ReshapeBuilder builder_(_fbb);
  builder_.add_shape(shape);
  builder_.add_format(format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reshape> CreateReshapeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Format format = Format_NCHW,
    const std::vector<int64_t> *shape = nullptr) {
  auto shape__ = shape ? _fbb.CreateVector<int64_t>(*shape) : 0;
  return mindspore::schema::CreateReshape(
      _fbb,
      format,
      shape__);
}

struct Power FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct PowerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(Power::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(Power::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(Power::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowerBuilder &operator=(const PowerBuilder &);
  flatbuffers::Offset<Power> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Power>(end);
    return o;
  }
};

inline flatbuffers::Offset<Power> CreatePower(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

struct PowerGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_POWER = 4,
    VT_SCALE = 6,
    VT_SHIFT = 8
  };
  float power() const {
    return GetField<float>(VT_POWER, 0.0f);
  }
  float scale() const {
    return GetField<float>(VT_SCALE, 0.0f);
  }
  float shift() const {
    return GetField<float>(VT_SHIFT, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_POWER) &&
           VerifyField<float>(verifier, VT_SCALE) &&
           VerifyField<float>(verifier, VT_SHIFT) &&
           verifier.EndTable();
  }
};

struct PowerGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_power(float power) {
    fbb_.AddElement<float>(PowerGrad::VT_POWER, power, 0.0f);
  }
  void add_scale(float scale) {
    fbb_.AddElement<float>(PowerGrad::VT_SCALE, scale, 0.0f);
  }
  void add_shift(float shift) {
    fbb_.AddElement<float>(PowerGrad::VT_SHIFT, shift, 0.0f);
  }
  explicit PowerGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PowerGradBuilder &operator=(const PowerGradBuilder &);
  flatbuffers::Offset<PowerGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PowerGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<PowerGrad> CreatePowerGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float power = 0.0f,
    float scale = 0.0f,
    float shift = 0.0f) {
  PowerGradBuilder builder_(_fbb);
  builder_.add_shift(shift);
  builder_.add_scale(scale);
  builder_.add_power(power);
  return builder_.Finish();
}

struct ArgMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OUTMAXVALUE = 6,
    VT_TOPK = 8,
    VT_KEEPDIMS = 10,
    VT_AXISTYPE = 12
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool outMaxValue() const {
    return GetField<uint8_t>(VT_OUTMAXVALUE, 0) != 0;
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 1);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  int32_t axisType() const {
    return GetField<int32_t>(VT_AXISTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_OUTMAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_TOPK) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_AXISTYPE) &&
           verifier.EndTable();
  }
};

struct ArgMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXIS, axis, 0);
  }
  void add_outMaxValue(bool outMaxValue) {
    fbb_.AddElement<uint8_t>(ArgMax::VT_OUTMAXVALUE, static_cast<uint8_t>(outMaxValue), 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMax::VT_TOPK, topK, 1);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ArgMax::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_axisType(int32_t axisType) {
    fbb_.AddElement<int32_t>(ArgMax::VT_AXISTYPE, axisType, 0);
  }
  explicit ArgMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMaxBuilder &operator=(const ArgMaxBuilder &);
  flatbuffers::Offset<ArgMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMax> CreateArgMax(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    bool outMaxValue = false,
    int32_t topK = 1,
    bool keepDims = false,
    int32_t axisType = 0) {
  ArgMaxBuilder builder_(_fbb);
  builder_.add_axisType(axisType);
  builder_.add_topK(topK);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  builder_.add_outMaxValue(outMaxValue);
  return builder_.Finish();
}

struct ArgMin FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OUTMAXVALUE = 6,
    VT_TOPK = 8,
    VT_KEEPDIMS = 10,
    VT_AXISTYPE = 12
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool outMaxValue() const {
    return GetField<uint8_t>(VT_OUTMAXVALUE, 0) != 0;
  }
  int32_t topK() const {
    return GetField<int32_t>(VT_TOPK, 1);
  }
  bool keepDims() const {
    return GetField<uint8_t>(VT_KEEPDIMS, 0) != 0;
  }
  int32_t axisType() const {
    return GetField<int32_t>(VT_AXISTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<uint8_t>(verifier, VT_OUTMAXVALUE) &&
           VerifyField<int32_t>(verifier, VT_TOPK) &&
           VerifyField<uint8_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int32_t>(verifier, VT_AXISTYPE) &&
           verifier.EndTable();
  }
};

struct ArgMinBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(ArgMin::VT_AXIS, axis, 0);
  }
  void add_outMaxValue(bool outMaxValue) {
    fbb_.AddElement<uint8_t>(ArgMin::VT_OUTMAXVALUE, static_cast<uint8_t>(outMaxValue), 0);
  }
  void add_topK(int32_t topK) {
    fbb_.AddElement<int32_t>(ArgMin::VT_TOPK, topK, 1);
  }
  void add_keepDims(bool keepDims) {
    fbb_.AddElement<uint8_t>(ArgMin::VT_KEEPDIMS, static_cast<uint8_t>(keepDims), 0);
  }
  void add_axisType(int32_t axisType) {
    fbb_.AddElement<int32_t>(ArgMin::VT_AXISTYPE, axisType, 0);
  }
  explicit ArgMinBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ArgMinBuilder &operator=(const ArgMinBuilder &);
  flatbuffers::Offset<ArgMin> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ArgMin>(end);
    return o;
  }
};

inline flatbuffers::Offset<ArgMin> CreateArgMin(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    bool outMaxValue = false,
    int32_t topK = 1,
    bool keepDims = false,
    int32_t axisType = 0) {
  ArgMinBuilder builder_(_fbb);
  builder_.add_axisType(axisType);
  builder_.add_topK(topK);
  builder_.add_axis(axis);
  builder_.add_keepDims(keepDims);
  builder_.add_outMaxValue(outMaxValue);
  return builder_.Finish();
}

struct NetOutput FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct NetOutputBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit NetOutputBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NetOutputBuilder &operator=(const NetOutputBuilder &);
  flatbuffers::Offset<NetOutput> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NetOutput>(end);
    return o;
  }
};

inline flatbuffers::Offset<NetOutput> CreateNetOutput(
    flatbuffers::FlatBufferBuilder &_fbb) {
  NetOutputBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MatMul FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BROADCAST = 4,
    VT_TRANSPOSEA = 6,
    VT_TRANSPOSEB = 8
  };
  bool broadcast() const {
    return GetField<uint8_t>(VT_BROADCAST, 0) != 0;
  }
  bool transposeA() const {
    return GetField<uint8_t>(VT_TRANSPOSEA, 0) != 0;
  }
  bool transposeB() const {
    return GetField<uint8_t>(VT_TRANSPOSEB, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BROADCAST) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEA) &&
           VerifyField<uint8_t>(verifier, VT_TRANSPOSEB) &&
           verifier.EndTable();
  }
};

struct MatMulBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_broadcast(bool broadcast) {
    fbb_.AddElement<uint8_t>(MatMul::VT_BROADCAST, static_cast<uint8_t>(broadcast), 0);
  }
  void add_transposeA(bool transposeA) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEA, static_cast<uint8_t>(transposeA), 0);
  }
  void add_transposeB(bool transposeB) {
    fbb_.AddElement<uint8_t>(MatMul::VT_TRANSPOSEB, static_cast<uint8_t>(transposeB), 0);
  }
  explicit MatMulBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatMulBuilder &operator=(const MatMulBuilder &);
  flatbuffers::Offset<MatMul> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatMul>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatMul> CreateMatMul(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool broadcast = false,
    bool transposeA = false,
    bool transposeB = false) {
  MatMulBuilder builder_(_fbb);
  builder_.add_transposeB(transposeB);
  builder_.add_transposeA(transposeA);
  builder_.add_broadcast(broadcast);
  return builder_.Finish();
}

struct PReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CHANNELSHARED = 4,
    VT_SLOPE = 6
  };
  bool channelShared() const {
    return GetField<uint8_t>(VT_CHANNELSHARED, 0) != 0;
  }
  const flatbuffers::Vector<float> *slope() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SLOPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_CHANNELSHARED) &&
           VerifyOffset(verifier, VT_SLOPE) &&
           verifier.VerifyVector(slope()) &&
           verifier.EndTable();
  }
};

struct PReLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_channelShared(bool channelShared) {
    fbb_.AddElement<uint8_t>(PReLU::VT_CHANNELSHARED, static_cast<uint8_t>(channelShared), 0);
  }
  void add_slope(flatbuffers::Offset<flatbuffers::Vector<float>> slope) {
    fbb_.AddOffset(PReLU::VT_SLOPE, slope);
  }
  explicit PReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PReLUBuilder &operator=(const PReLUBuilder &);
  flatbuffers::Offset<PReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<PReLU> CreatePReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool channelShared = false,
    flatbuffers::Offset<flatbuffers::Vector<float>> slope = 0) {
  PReLUBuilder builder_(_fbb);
  builder_.add_slope(slope);
  builder_.add_channelShared(channelShared);
  return builder_.Finish();
}

inline flatbuffers::Offset<PReLU> CreatePReLUDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool channelShared = false,
    const std::vector<float> *slope = nullptr) {
  auto slope__ = slope ? _fbb.CreateVector<float>(*slope) : 0;
  return mindspore::schema::CreatePReLU(
      _fbb,
      channelShared,
      slope__);
}

struct LeakyReLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NEGATIVESLOPE = 4
  };
  float negativeSlope() const {
    return GetField<float>(VT_NEGATIVESLOPE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_NEGATIVESLOPE) &&
           verifier.EndTable();
  }
};

struct LeakyReLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_negativeSlope(float negativeSlope) {
    fbb_.AddElement<float>(LeakyReLU::VT_NEGATIVESLOPE, negativeSlope, 0.0f);
  }
  explicit LeakyReLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LeakyReLUBuilder &operator=(const LeakyReLUBuilder &);
  flatbuffers::Offset<LeakyReLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LeakyReLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<LeakyReLU> CreateLeakyReLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    float negativeSlope = 0.0f) {
  LeakyReLUBuilder builder_(_fbb);
  builder_.add_negativeSlope(negativeSlope);
  return builder_.Finish();
}

struct StridedSlice FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BEGINMASK = 4,
    VT_ENDMASK = 6,
    VT_ELLIPSISMASK = 8,
    VT_NEWAXISMASK = 10,
    VT_SHRINKAXISMASK = 12,
    VT_BEGIN = 14,
    VT_END = 16,
    VT_STRIDE = 18,
    VT_ISSCALE = 20
  };
  int32_t beginMask() const {
    return GetField<int32_t>(VT_BEGINMASK, 0);
  }
  int32_t endMask() const {
    return GetField<int32_t>(VT_ENDMASK, 0);
  }
  int32_t ellipsisMask() const {
    return GetField<int32_t>(VT_ELLIPSISMASK, 0);
  }
  int32_t newAxisMask() const {
    return GetField<int32_t>(VT_NEWAXISMASK, 0);
  }
  int32_t shrinkAxisMask() const {
    return GetField<int32_t>(VT_SHRINKAXISMASK, 0);
  }
  const flatbuffers::Vector<int32_t> *begin() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BEGIN);
  }
  const flatbuffers::Vector<int32_t> *end() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_END);
  }
  const flatbuffers::Vector<int32_t> *stride() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_STRIDE);
  }
  const flatbuffers::Vector<int32_t> *isScale() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BEGINMASK) &&
           VerifyField<int32_t>(verifier, VT_ENDMASK) &&
           VerifyField<int32_t>(verifier, VT_ELLIPSISMASK) &&
           VerifyField<int32_t>(verifier, VT_NEWAXISMASK) &&
           VerifyField<int32_t>(verifier, VT_SHRINKAXISMASK) &&
           VerifyOffset(verifier, VT_BEGIN) &&
           verifier.VerifyVector(begin()) &&
           VerifyOffset(verifier, VT_END) &&
           verifier.VerifyVector(end()) &&
           VerifyOffset(verifier, VT_STRIDE) &&
           verifier.VerifyVector(stride()) &&
           VerifyOffset(verifier, VT_ISSCALE) &&
           verifier.VerifyVector(isScale()) &&
           verifier.EndTable();
  }
};

struct StridedSliceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beginMask(int32_t beginMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_BEGINMASK, beginMask, 0);
  }
  void add_endMask(int32_t endMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_ENDMASK, endMask, 0);
  }
  void add_ellipsisMask(int32_t ellipsisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_ELLIPSISMASK, ellipsisMask, 0);
  }
  void add_newAxisMask(int32_t newAxisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_NEWAXISMASK, newAxisMask, 0);
  }
  void add_shrinkAxisMask(int32_t shrinkAxisMask) {
    fbb_.AddElement<int32_t>(StridedSlice::VT_SHRINKAXISMASK, shrinkAxisMask, 0);
  }
  void add_begin(flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin) {
    fbb_.AddOffset(StridedSlice::VT_BEGIN, begin);
  }
  void add_end(flatbuffers::Offset<flatbuffers::Vector<int32_t>> end) {
    fbb_.AddOffset(StridedSlice::VT_END, end);
  }
  void add_stride(flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride) {
    fbb_.AddOffset(StridedSlice::VT_STRIDE, stride);
  }
  void add_isScale(flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale) {
    fbb_.AddOffset(StridedSlice::VT_ISSCALE, isScale);
  }
  explicit StridedSliceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StridedSliceBuilder &operator=(const StridedSliceBuilder &);
  flatbuffers::Offset<StridedSlice> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StridedSlice>(end);
    return o;
  }
};

inline flatbuffers::Offset<StridedSlice> CreateStridedSlice(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> begin = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> end = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> stride = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale = 0) {
  StridedSliceBuilder builder_(_fbb);
  builder_.add_isScale(isScale);
  builder_.add_stride(stride);
  builder_.add_end(end);
  builder_.add_begin(begin);
  builder_.add_shrinkAxisMask(shrinkAxisMask);
  builder_.add_newAxisMask(newAxisMask);
  builder_.add_ellipsisMask(ellipsisMask);
  builder_.add_endMask(endMask);
  builder_.add_beginMask(beginMask);
  return builder_.Finish();
}

inline flatbuffers::Offset<StridedSlice> CreateStridedSliceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t beginMask = 0,
    int32_t endMask = 0,
    int32_t ellipsisMask = 0,
    int32_t newAxisMask = 0,
    int32_t shrinkAxisMask = 0,
    const std::vector<int32_t> *begin = nullptr,
    const std::vector<int32_t> *end = nullptr,
    const std::vector<int32_t> *stride = nullptr,
    const std::vector<int32_t> *isScale = nullptr) {
  auto begin__ = begin ? _fbb.CreateVector<int32_t>(*begin) : 0;
  auto end__ = end ? _fbb.CreateVector<int32_t>(*end) : 0;
  auto stride__ = stride ? _fbb.CreateVector<int32_t>(*stride) : 0;
  auto isScale__ = isScale ? _fbb.CreateVector<int32_t>(*isScale) : 0;
  return mindspore::schema::CreateStridedSlice(
      _fbb,
      beginMask,
      endMask,
      ellipsisMask,
      newAxisMask,
      shrinkAxisMask,
      begin__,
      end__,
      stride__,
      isScale__);
}

struct Stack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_N = 6,
    VT_ISSCALE = 8
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t n() const {
    return GetField<int32_t>(VT_N, 0);
  }
  const flatbuffers::Vector<int32_t> *isScale() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_ISSCALE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           VerifyOffset(verifier, VT_ISSCALE) &&
           verifier.VerifyVector(isScale()) &&
           verifier.EndTable();
  }
};

struct StackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Stack::VT_AXIS, axis, 0);
  }
  void add_n(int32_t n) {
    fbb_.AddElement<int32_t>(Stack::VT_N, n, 0);
  }
  void add_isScale(flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale) {
    fbb_.AddOffset(Stack::VT_ISSCALE, isScale);
  }
  explicit StackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  StackBuilder &operator=(const StackBuilder &);
  flatbuffers::Offset<Stack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Stack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Stack> CreateStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> isScale = 0) {
  StackBuilder builder_(_fbb);
  builder_.add_isScale(isScale);
  builder_.add_n(n);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Stack> CreateStackDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t n = 0,
    const std::vector<int32_t> *isScale = nullptr) {
  auto isScale__ = isScale ? _fbb.CreateVector<int32_t>(*isScale) : 0;
  return mindspore::schema::CreateStack(
      _fbb,
      axis,
      n,
      isScale__);
}

struct Range FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DTYPE = 4,
    VT_START = 6,
    VT_LIMIT = 8,
    VT_DELTA = 10
  };
  int32_t dType() const {
    return GetField<int32_t>(VT_DTYPE, 0);
  }
  int32_t start() const {
    return GetField<int32_t>(VT_START, 0);
  }
  int32_t limit() const {
    return GetField<int32_t>(VT_LIMIT, 0);
  }
  int32_t delta() const {
    return GetField<int32_t>(VT_DELTA, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DTYPE) &&
           VerifyField<int32_t>(verifier, VT_START) &&
           VerifyField<int32_t>(verifier, VT_LIMIT) &&
           VerifyField<int32_t>(verifier, VT_DELTA) &&
           verifier.EndTable();
  }
};

struct RangeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dType(int32_t dType) {
    fbb_.AddElement<int32_t>(Range::VT_DTYPE, dType, 0);
  }
  void add_start(int32_t start) {
    fbb_.AddElement<int32_t>(Range::VT_START, start, 0);
  }
  void add_limit(int32_t limit) {
    fbb_.AddElement<int32_t>(Range::VT_LIMIT, limit, 0);
  }
  void add_delta(int32_t delta) {
    fbb_.AddElement<int32_t>(Range::VT_DELTA, delta, 1);
  }
  explicit RangeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RangeBuilder &operator=(const RangeBuilder &);
  flatbuffers::Offset<Range> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Range>(end);
    return o;
  }
};

inline flatbuffers::Offset<Range> CreateRange(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dType = 0,
    int32_t start = 0,
    int32_t limit = 0,
    int32_t delta = 1) {
  RangeBuilder builder_(_fbb);
  builder_.add_delta(delta);
  builder_.add_limit(limit);
  builder_.add_start(start);
  builder_.add_dType(dType);
  return builder_.Finish();
}

struct ExpandDims FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIM = 4
  };
  int32_t dim() const {
    return GetField<int32_t>(VT_DIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DIM) &&
           verifier.EndTable();
  }
};

struct ExpandDimsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dim(int32_t dim) {
    fbb_.AddElement<int32_t>(ExpandDims::VT_DIM, dim, 0);
  }
  explicit ExpandDimsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ExpandDimsBuilder &operator=(const ExpandDimsBuilder &);
  flatbuffers::Offset<ExpandDims> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ExpandDims>(end);
    return o;
  }
};

inline flatbuffers::Offset<ExpandDims> CreateExpandDims(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t dim = 0) {
  ExpandDimsBuilder builder_(_fbb);
  builder_.add_dim(dim);
  return builder_.Finish();
}

struct Tile FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MULTIPLES = 4,
    VT_DIMS = 6
  };
  const flatbuffers::Vector<int32_t> *multiples() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MULTIPLES);
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MULTIPLES) &&
           verifier.VerifyVector(multiples()) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct TileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_multiples(flatbuffers::Offset<flatbuffers::Vector<int32_t>> multiples) {
    fbb_.AddOffset(Tile::VT_MULTIPLES, multiples);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Tile::VT_DIMS, dims);
  }
  explicit TileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TileBuilder &operator=(const TileBuilder &);
  flatbuffers::Offset<Tile> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tile>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tile> CreateTile(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> multiples = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  TileBuilder builder_(_fbb);
  builder_.add_dims(dims);
  builder_.add_multiples(multiples);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tile> CreateTileDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *multiples = nullptr,
    const std::vector<int32_t> *dims = nullptr) {
  auto multiples__ = multiples ? _fbb.CreateVector<int32_t>(*multiples) : 0;
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return mindspore::schema::CreateTile(
      _fbb,
      multiples__,
      dims__);
}

struct Cast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
};

struct CastBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(Cast::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(Cast::VT_DSTT, dstT, 0);
  }
  explicit CastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CastBuilder &operator=(const CastBuilder &);
  flatbuffers::Offset<Cast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Cast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Cast> CreateCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  CastBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

struct QuantDTypeCast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
};

struct QuantDTypeCastBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(QuantDTypeCast::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(QuantDTypeCast::VT_DSTT, dstT, 0);
  }
  explicit QuantDTypeCastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantDTypeCastBuilder &operator=(const QuantDTypeCastBuilder &);
  flatbuffers::Offset<QuantDTypeCast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantDTypeCast>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantDTypeCast> CreateQuantDTypeCast(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  QuantDTypeCastBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

struct Split FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMBERSPLIT = 4,
    VT_SIZESPLITS = 6,
    VT_SPLITDIM = 8
  };
  int32_t numberSplit() const {
    return GetField<int32_t>(VT_NUMBERSPLIT, 0);
  }
  const flatbuffers::Vector<int32_t> *sizeSplits() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SIZESPLITS);
  }
  int32_t splitDim() const {
    return GetField<int32_t>(VT_SPLITDIM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMBERSPLIT) &&
           VerifyOffset(verifier, VT_SIZESPLITS) &&
           verifier.VerifyVector(sizeSplits()) &&
           VerifyField<int32_t>(verifier, VT_SPLITDIM) &&
           verifier.EndTable();
  }
};

struct SplitBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numberSplit(int32_t numberSplit) {
    fbb_.AddElement<int32_t>(Split::VT_NUMBERSPLIT, numberSplit, 0);
  }
  void add_sizeSplits(flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizeSplits) {
    fbb_.AddOffset(Split::VT_SIZESPLITS, sizeSplits);
  }
  void add_splitDim(int32_t splitDim) {
    fbb_.AddElement<int32_t>(Split::VT_SPLITDIM, splitDim, 0);
  }
  explicit SplitBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SplitBuilder &operator=(const SplitBuilder &);
  flatbuffers::Offset<Split> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Split>(end);
    return o;
  }
};

inline flatbuffers::Offset<Split> CreateSplit(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberSplit = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> sizeSplits = 0,
    int32_t splitDim = 0) {
  SplitBuilder builder_(_fbb);
  builder_.add_splitDim(splitDim);
  builder_.add_sizeSplits(sizeSplits);
  builder_.add_numberSplit(numberSplit);
  return builder_.Finish();
}

inline flatbuffers::Offset<Split> CreateSplitDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numberSplit = 0,
    const std::vector<int32_t> *sizeSplits = nullptr,
    int32_t splitDim = 0) {
  auto sizeSplits__ = sizeSplits ? _fbb.CreateVector<int32_t>(*sizeSplits) : 0;
  return mindspore::schema::CreateSplit(
      _fbb,
      numberSplit,
      sizeSplits__,
      splitDim);
}

struct Crop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_OFFSETS = 6
  };
  int64_t axis() const {
    return GetField<int64_t>(VT_AXIS, 0);
  }
  const flatbuffers::Vector<int64_t> *offsets() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_OFFSETS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_AXIS) &&
           VerifyOffset(verifier, VT_OFFSETS) &&
           verifier.VerifyVector(offsets()) &&
           verifier.EndTable();
  }
};

struct CropBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int64_t axis) {
    fbb_.AddElement<int64_t>(Crop::VT_AXIS, axis, 0);
  }
  void add_offsets(flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets) {
    fbb_.AddOffset(Crop::VT_OFFSETS, offsets);
  }
  explicit CropBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CropBuilder &operator=(const CropBuilder &);
  flatbuffers::Offset<Crop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Crop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Crop> CreateCrop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> offsets = 0) {
  CropBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_offsets(offsets);
  return builder_.Finish();
}

inline flatbuffers::Offset<Crop> CreateCropDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t axis = 0,
    const std::vector<int64_t> *offsets = nullptr) {
  auto offsets__ = offsets ? _fbb.CreateVector<int64_t>(*offsets) : 0;
  return mindspore::schema::CreateCrop(
      _fbb,
      axis,
      offsets__);
}

struct Permute FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ORDER = 4
  };
  const flatbuffers::Vector<int64_t> *order() const {
    return GetPointer<const flatbuffers::Vector<int64_t> *>(VT_ORDER);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ORDER) &&
           verifier.VerifyVector(order()) &&
           verifier.EndTable();
  }
};

struct PermuteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_order(flatbuffers::Offset<flatbuffers::Vector<int64_t>> order) {
    fbb_.AddOffset(Permute::VT_ORDER, order);
  }
  explicit PermuteBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PermuteBuilder &operator=(const PermuteBuilder &);
  flatbuffers::Offset<Permute> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Permute>(end);
    return o;
  }
};

inline flatbuffers::Offset<Permute> CreatePermute(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int64_t>> order = 0) {
  PermuteBuilder builder_(_fbb);
  builder_.add_order(order);
  return builder_.Finish();
}

inline flatbuffers::Offset<Permute> CreatePermuteDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int64_t> *order = nullptr) {
  auto order__ = order ? _fbb.CreateVector<int64_t>(*order) : 0;
  return mindspore::schema::CreatePermute(
      _fbb,
      order__);
}

struct Clip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAX = 4,
    VT_MIN = 6
  };
  float max() const {
    return GetField<float>(VT_MAX, 0.0f);
  }
  float min() const {
    return GetField<float>(VT_MIN, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAX) &&
           VerifyField<float>(verifier, VT_MIN) &&
           verifier.EndTable();
  }
};

struct ClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_max(float max) {
    fbb_.AddElement<float>(Clip::VT_MAX, max, 0.0f);
  }
  void add_min(float min) {
    fbb_.AddElement<float>(Clip::VT_MIN, min, 0.0f);
  }
  explicit ClipBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ClipBuilder &operator=(const ClipBuilder &);
  flatbuffers::Offset<Clip> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Clip>(end);
    return o;
  }
};

inline flatbuffers::Offset<Clip> CreateClip(
    flatbuffers::FlatBufferBuilder &_fbb,
    float max = 0.0f,
    float min = 0.0f) {
  ClipBuilder builder_(_fbb);
  builder_.add_min(min);
  builder_.add_max(max);
  return builder_.Finish();
}

struct Constant FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ConstantBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ConstantBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ConstantBuilder &operator=(const ConstantBuilder &);
  flatbuffers::Offset<Constant> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Constant>(end);
    return o;
  }
};

inline flatbuffers::Offset<Constant> CreateConstant(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ConstantBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Elu FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           verifier.EndTable();
  }
};

struct EluBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Elu::VT_ALPHA, alpha, 1.0f);
  }
  explicit EluBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EluBuilder &operator=(const EluBuilder &);
  flatbuffers::Offset<Elu> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Elu>(end);
    return o;
  }
};

inline flatbuffers::Offset<Elu> CreateElu(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 1.0f) {
  EluBuilder builder_(_fbb);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct Broadcast FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BroadcastBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BroadcastBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastBuilder &operator=(const BroadcastBuilder &);
  flatbuffers::Offset<Broadcast> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Broadcast>(end);
    return o;
  }
};

inline flatbuffers::Offset<Broadcast> CreateBroadcast(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BroadcastBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BroadcastTo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DST_SHAPE = 4
  };
  const flatbuffers::Vector<int32_t> *dst_shape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DST_SHAPE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DST_SHAPE) &&
           verifier.VerifyVector(dst_shape()) &&
           verifier.EndTable();
  }
};

struct BroadcastToBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dst_shape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dst_shape) {
    fbb_.AddOffset(BroadcastTo::VT_DST_SHAPE, dst_shape);
  }
  explicit BroadcastToBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BroadcastToBuilder &operator=(const BroadcastToBuilder &);
  flatbuffers::Offset<BroadcastTo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BroadcastTo>(end);
    return o;
  }
};

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastTo(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dst_shape = 0) {
  BroadcastToBuilder builder_(_fbb);
  builder_.add_dst_shape(dst_shape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BroadcastTo> CreateBroadcastToDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dst_shape = nullptr) {
  auto dst_shape__ = dst_shape ? _fbb.CreateVector<int32_t>(*dst_shape) : 0;
  return mindspore::schema::CreateBroadcastTo(
      _fbb,
      dst_shape__);
}

struct Lrn FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ALPHA = 4,
    VT_BETA = 6,
    VT_BIAS = 8,
    VT_SIZE = 10
  };
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0001f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.75f);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 1.0f);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           verifier.EndTable();
  }
};

struct LrnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(Lrn::VT_ALPHA, alpha, 0.0001f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(Lrn::VT_BETA, beta, 0.75f);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(Lrn::VT_BIAS, bias, 1.0f);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(Lrn::VT_SIZE, size, 0);
  }
  explicit LrnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LrnBuilder &operator=(const LrnBuilder &);
  flatbuffers::Offset<Lrn> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lrn>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lrn> CreateLrn(
    flatbuffers::FlatBufferBuilder &_fbb,
    float alpha = 0.0001f,
    float beta = 0.75f,
    float bias = 1.0f,
    int32_t size = 0) {
  LrnBuilder builder_(_fbb);
  builder_.add_size(size);
  builder_.add_bias(bias);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  return builder_.Finish();
}

struct Reduce FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXES = 4,
    VT_KEEPDIMS = 6,
    VT_MODE = 8,
    VT_REDUCETOEND = 10,
    VT_COEFF = 12
  };
  const flatbuffers::Vector<int32_t> *axes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXES);
  }
  int32_t keepDims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 0);
  }
  ReduceMode mode() const {
    return static_cast<ReduceMode>(GetField<int8_t>(VT_MODE, 0));
  }
  bool reduceToEnd() const {
    return GetField<uint8_t>(VT_REDUCETOEND, 0) != 0;
  }
  float coeff() const {
    return GetField<float>(VT_COEFF, 1.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXES) &&
           verifier.VerifyVector(axes()) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           VerifyField<int8_t>(verifier, VT_MODE) &&
           VerifyField<uint8_t>(verifier, VT_REDUCETOEND) &&
           VerifyField<float>(verifier, VT_COEFF) &&
           verifier.EndTable();
  }
};

struct ReduceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes) {
    fbb_.AddOffset(Reduce::VT_AXES, axes);
  }
  void add_keepDims(int32_t keepDims) {
    fbb_.AddElement<int32_t>(Reduce::VT_KEEPDIMS, keepDims, 0);
  }
  void add_mode(ReduceMode mode) {
    fbb_.AddElement<int8_t>(Reduce::VT_MODE, static_cast<int8_t>(mode), 0);
  }
  void add_reduceToEnd(bool reduceToEnd) {
    fbb_.AddElement<uint8_t>(Reduce::VT_REDUCETOEND, static_cast<uint8_t>(reduceToEnd), 0);
  }
  void add_coeff(float coeff) {
    fbb_.AddElement<float>(Reduce::VT_COEFF, coeff, 1.0f);
  }
  explicit ReduceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReduceBuilder &operator=(const ReduceBuilder &);
  flatbuffers::Offset<Reduce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reduce>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reduce> CreateReduce(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axes = 0,
    int32_t keepDims = 0,
    ReduceMode mode = ReduceMode_ReduceMean,
    bool reduceToEnd = false,
    float coeff = 1.0f) {
  ReduceBuilder builder_(_fbb);
  builder_.add_coeff(coeff);
  builder_.add_keepDims(keepDims);
  builder_.add_axes(axes);
  builder_.add_reduceToEnd(reduceToEnd);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reduce> CreateReduceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axes = nullptr,
    int32_t keepDims = 0,
    ReduceMode mode = ReduceMode_ReduceMean,
    bool reduceToEnd = false,
    float coeff = 1.0f) {
  auto axes__ = axes ? _fbb.CreateVector<int32_t>(*axes) : 0;
  return mindspore::schema::CreateReduce(
      _fbb,
      axes__,
      keepDims,
      mode,
      reduceToEnd,
      coeff);
}

struct Transpose FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PERM = 4,
    VT_CONJUGATE = 6
  };
  const flatbuffers::Vector<int32_t> *perm() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PERM);
  }
  bool conjugate() const {
    return GetField<uint8_t>(VT_CONJUGATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PERM) &&
           verifier.VerifyVector(perm()) &&
           VerifyField<uint8_t>(verifier, VT_CONJUGATE) &&
           verifier.EndTable();
  }
};

struct TransposeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_perm(flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm) {
    fbb_.AddOffset(Transpose::VT_PERM, perm);
  }
  void add_conjugate(bool conjugate) {
    fbb_.AddElement<uint8_t>(Transpose::VT_CONJUGATE, static_cast<uint8_t>(conjugate), 0);
  }
  explicit TransposeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TransposeBuilder &operator=(const TransposeBuilder &);
  flatbuffers::Offset<Transpose> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Transpose>(end);
    return o;
  }
};

inline flatbuffers::Offset<Transpose> CreateTranspose(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> perm = 0,
    bool conjugate = false) {
  TransposeBuilder builder_(_fbb);
  builder_.add_perm(perm);
  builder_.add_conjugate(conjugate);
  return builder_.Finish();
}

inline flatbuffers::Offset<Transpose> CreateTransposeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *perm = nullptr,
    bool conjugate = false) {
  auto perm__ = perm ? _fbb.CreateVector<int32_t>(*perm) : 0;
  return mindspore::schema::CreateTranspose(
      _fbb,
      perm__,
      conjugate);
}

struct Squeeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct SqueezeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Squeeze::VT_AXIS, axis);
  }
  explicit SqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SqueezeBuilder &operator=(const SqueezeBuilder &);
  flatbuffers::Offset<Squeeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Squeeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Squeeze> CreateSqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  SqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Squeeze> CreateSqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateSqueeze(
      _fbb,
      axis__);
}

struct Unsqueeze FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct UnsqueezeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Unsqueeze::VT_AXIS, axis);
  }
  explicit UnsqueezeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsqueezeBuilder &operator=(const UnsqueezeBuilder &);
  flatbuffers::Offset<Unsqueeze> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unsqueeze>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueeze(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  UnsqueezeBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Unsqueeze> CreateUnsqueezeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateUnsqueeze(
      _fbb,
      axis__);
}

struct Upsample FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MODE = 4,
    VT_SCALES = 6
  };
  const flatbuffers::String *mode() const {
    return GetPointer<const flatbuffers::String *>(VT_MODE);
  }
  const flatbuffers::Vector<float> *scales() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MODE) &&
           verifier.VerifyString(mode()) &&
           VerifyOffset(verifier, VT_SCALES) &&
           verifier.VerifyVector(scales()) &&
           verifier.EndTable();
  }
};

struct UpsampleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_mode(flatbuffers::Offset<flatbuffers::String> mode) {
    fbb_.AddOffset(Upsample::VT_MODE, mode);
  }
  void add_scales(flatbuffers::Offset<flatbuffers::Vector<float>> scales) {
    fbb_.AddOffset(Upsample::VT_SCALES, scales);
  }
  explicit UpsampleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UpsampleBuilder &operator=(const UpsampleBuilder &);
  flatbuffers::Offset<Upsample> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Upsample>(end);
    return o;
  }
};

inline flatbuffers::Offset<Upsample> CreateUpsample(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> mode = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scales = 0) {
  UpsampleBuilder builder_(_fbb);
  builder_.add_scales(scales);
  builder_.add_mode(mode);
  return builder_.Finish();
}

inline flatbuffers::Offset<Upsample> CreateUpsampleDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *mode = nullptr,
    const std::vector<float> *scales = nullptr) {
  auto mode__ = mode ? _fbb.CreateString(mode) : 0;
  auto scales__ = scales ? _fbb.CreateVector<float>(*scales) : 0;
  return mindspore::schema::CreateUpsample(
      _fbb,
      mode__,
      scales__);
}

struct Dropout FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATIO = 4
  };
  float ratio() const {
    return GetField<float>(VT_RATIO, 0.5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATIO) &&
           verifier.EndTable();
  }
};

struct DropoutBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ratio(float ratio) {
    fbb_.AddElement<float>(Dropout::VT_RATIO, ratio, 0.5f);
  }
  explicit DropoutBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DropoutBuilder &operator=(const DropoutBuilder &);
  flatbuffers::Offset<Dropout> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Dropout>(end);
    return o;
  }
};

inline flatbuffers::Offset<Dropout> CreateDropout(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ratio = 0.5f) {
  DropoutBuilder builder_(_fbb);
  builder_.add_ratio(ratio);
  return builder_.Finish();
}

struct LocalResponseNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DEPTH_RADIUS = 4,
    VT_BIAS = 6,
    VT_ALPHA = 8,
    VT_BETA = 10
  };
  int32_t depth_radius() const {
    return GetField<int32_t>(VT_DEPTH_RADIUS, 0);
  }
  float bias() const {
    return GetField<float>(VT_BIAS, 0.0f);
  }
  float alpha() const {
    return GetField<float>(VT_ALPHA, 0.0f);
  }
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_DEPTH_RADIUS) &&
           VerifyField<float>(verifier, VT_BIAS) &&
           VerifyField<float>(verifier, VT_ALPHA) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct LocalResponseNormalizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_depth_radius(int32_t depth_radius) {
    fbb_.AddElement<int32_t>(LocalResponseNormalization::VT_DEPTH_RADIUS, depth_radius, 0);
  }
  void add_bias(float bias) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_BIAS, bias, 0.0f);
  }
  void add_alpha(float alpha) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_ALPHA, alpha, 0.0f);
  }
  void add_beta(float beta) {
    fbb_.AddElement<float>(LocalResponseNormalization::VT_BETA, beta, 0.0f);
  }
  explicit LocalResponseNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LocalResponseNormalizationBuilder &operator=(const LocalResponseNormalizationBuilder &);
  flatbuffers::Offset<LocalResponseNormalization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LocalResponseNormalization>(end);
    return o;
  }
};

inline flatbuffers::Offset<LocalResponseNormalization> CreateLocalResponseNormalization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t depth_radius = 0,
    float bias = 0.0f,
    float alpha = 0.0f,
    float beta = 0.0f) {
  LocalResponseNormalizationBuilder builder_(_fbb);
  builder_.add_beta(beta);
  builder_.add_alpha(alpha);
  builder_.add_bias(bias);
  builder_.add_depth_radius(depth_radius);
  return builder_.Finish();
}

struct ZerosLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ZerosLikeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ZerosLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ZerosLikeBuilder &operator=(const ZerosLikeBuilder &);
  flatbuffers::Offset<ZerosLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ZerosLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<ZerosLike> CreateZerosLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ZerosLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TopK FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_SORTED = 6
  };
  int32_t k() const {
    return GetField<int32_t>(VT_K, 0);
  }
  bool sorted() const {
    return GetField<uint8_t>(VT_SORTED, 1) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_K) &&
           VerifyField<uint8_t>(verifier, VT_SORTED) &&
           verifier.EndTable();
  }
};

struct TopKBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(int32_t k) {
    fbb_.AddElement<int32_t>(TopK::VT_K, k, 0);
  }
  void add_sorted(bool sorted) {
    fbb_.AddElement<uint8_t>(TopK::VT_SORTED, static_cast<uint8_t>(sorted), 1);
  }
  explicit TopKBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TopKBuilder &operator=(const TopKBuilder &);
  flatbuffers::Offset<TopK> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TopK>(end);
    return o;
  }
};

inline flatbuffers::Offset<TopK> CreateTopK(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t k = 0,
    bool sorted = true) {
  TopKBuilder builder_(_fbb);
  builder_.add_k(k);
  builder_.add_sorted(sorted);
  return builder_.Finish();
}

struct SpaceToDepth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_FORMAT = 6
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct SpaceToDepthBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_BLOCKSIZE, blockSize, 0);
  }
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(SpaceToDepth::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit SpaceToDepthBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToDepthBuilder &operator=(const SpaceToDepthBuilder &);
  flatbuffers::Offset<SpaceToDepth> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToDepth>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToDepth> CreateSpaceToDepth(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    Format format = Format_NCHW) {
  SpaceToDepthBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_blockSize(blockSize);
  return builder_.Finish();
}

struct SpaceToBatch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(SpaceToBatch::VT_BLOCKSHAPE, blockShape);
  }
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(SpaceToBatch::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchBuilder &operator=(const SpaceToBatchBuilder &);
  flatbuffers::Offset<SpaceToBatch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatch>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatch(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0) {
  SpaceToBatchBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatch> CreateSpaceToBatchDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *paddings = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::CreateSpaceToBatch(
      _fbb,
      blockShape__,
      paddings__);
}

struct SparseToDense FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALIDATEINDICES = 4
  };
  bool validateIndices() const {
    return GetField<uint8_t>(VT_VALIDATEINDICES, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALIDATEINDICES) &&
           verifier.EndTable();
  }
};

struct SparseToDenseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_validateIndices(bool validateIndices) {
    fbb_.AddElement<uint8_t>(SparseToDense::VT_VALIDATEINDICES, static_cast<uint8_t>(validateIndices), 0);
  }
  explicit SparseToDenseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SparseToDenseBuilder &operator=(const SparseToDenseBuilder &);
  flatbuffers::Offset<SparseToDense> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SparseToDense>(end);
    return o;
  }
};

inline flatbuffers::Offset<SparseToDense> CreateSparseToDense(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool validateIndices = false) {
  SparseToDenseBuilder builder_(_fbb);
  builder_.add_validateIndices(validateIndices);
  return builder_.Finish();
}

struct ReverseSequence FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SEQAXIS = 4,
    VT_BATCHAXIS = 6
  };
  int32_t seqAxis() const {
    return GetField<int32_t>(VT_SEQAXIS, 0);
  }
  int32_t batchAxis() const {
    return GetField<int32_t>(VT_BATCHAXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SEQAXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCHAXIS) &&
           verifier.EndTable();
  }
};

struct ReverseSequenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_seqAxis(int32_t seqAxis) {
    fbb_.AddElement<int32_t>(ReverseSequence::VT_SEQAXIS, seqAxis, 0);
  }
  void add_batchAxis(int32_t batchAxis) {
    fbb_.AddElement<int32_t>(ReverseSequence::VT_BATCHAXIS, batchAxis, 0);
  }
  explicit ReverseSequenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseSequenceBuilder &operator=(const ReverseSequenceBuilder &);
  flatbuffers::Offset<ReverseSequence> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ReverseSequence>(end);
    return o;
  }
};

inline flatbuffers::Offset<ReverseSequence> CreateReverseSequence(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t seqAxis = 0,
    int32_t batchAxis = 0) {
  ReverseSequenceBuilder builder_(_fbb);
  builder_.add_batchAxis(batchAxis);
  builder_.add_seqAxis(seqAxis);
  return builder_.Finish();
}

struct Rank FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RankBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RankBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RankBuilder &operator=(const RankBuilder &);
  flatbuffers::Offset<Rank> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rank>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rank> CreateRank(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RankBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Gather FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_BATCHDIMS = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t batchDims() const {
    return GetField<int32_t>(VT_BATCHDIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_BATCHDIMS) &&
           verifier.EndTable();
  }
};

struct GatherBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Gather::VT_AXIS, axis, 0);
  }
  void add_batchDims(int32_t batchDims) {
    fbb_.AddElement<int32_t>(Gather::VT_BATCHDIMS, batchDims, 0);
  }
  explicit GatherBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherBuilder &operator=(const GatherBuilder &);
  flatbuffers::Offset<Gather> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Gather>(end);
    return o;
  }
};

inline flatbuffers::Offset<Gather> CreateGather(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t batchDims = 0) {
  GatherBuilder builder_(_fbb);
  builder_.add_batchDims(batchDims);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct GatherNd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BATCHDIMS = 4
  };
  int32_t batchDims() const {
    return GetField<int32_t>(VT_BATCHDIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BATCHDIMS) &&
           verifier.EndTable();
  }
};

struct GatherNdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_batchDims(int32_t batchDims) {
    fbb_.AddElement<int32_t>(GatherNd::VT_BATCHDIMS, batchDims, 0);
  }
  explicit GatherNdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GatherNdBuilder &operator=(const GatherNdBuilder &);
  flatbuffers::Offset<GatherNd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GatherNd>(end);
    return o;
  }
};

inline flatbuffers::Offset<GatherNd> CreateGatherNd(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t batchDims = 0) {
  GatherNdBuilder builder_(_fbb);
  builder_.add_batchDims(batchDims);
  return builder_.Finish();
}

struct Fill FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_DIMS = 4
  };
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           verifier.EndTable();
  }
};

struct FillBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Fill::VT_DIMS, dims);
  }
  explicit FillBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FillBuilder &operator=(const FillBuilder &);
  flatbuffers::Offset<Fill> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Fill>(end);
    return o;
  }
};

inline flatbuffers::Offset<Fill> CreateFill(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0) {
  FillBuilder builder_(_fbb);
  builder_.add_dims(dims);
  return builder_.Finish();
}

inline flatbuffers::Offset<Fill> CreateFillDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *dims = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  return mindspore::schema::CreateFill(
      _fbb,
      dims__);
}

struct DepthToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSIZE = 4,
    VT_FORMAT = 6
  };
  int32_t blockSize() const {
    return GetField<int32_t>(VT_BLOCKSIZE, 0);
  }
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_BLOCKSIZE) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           verifier.EndTable();
  }
};

struct DepthToSpaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockSize(int32_t blockSize) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_BLOCKSIZE, blockSize, 0);
  }
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(DepthToSpace::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  explicit DepthToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DepthToSpaceBuilder &operator=(const DepthToSpaceBuilder &);
  flatbuffers::Offset<DepthToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DepthToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<DepthToSpace> CreateDepthToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t blockSize = 0,
    Format format = Format_NCHW) {
  DepthToSpaceBuilder builder_(_fbb);
  builder_.add_format(format);
  builder_.add_blockSize(blockSize);
  return builder_.Finish();
}

struct BatchToSpace FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *crops() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyVector(crops()) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(BatchToSpace::VT_BLOCKSHAPE, blockShape);
  }
  void add_crops(flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops) {
    fbb_.AddOffset(BatchToSpace::VT_CROPS, crops);
  }
  explicit BatchToSpaceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceBuilder &operator=(const BatchToSpaceBuilder &);
  flatbuffers::Offset<BatchToSpace> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpace>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpace(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops = 0) {
  BatchToSpaceBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpace> CreateBatchToSpaceDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *crops = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto crops__ = crops ? _fbb.CreateVector<int32_t>(*crops) : 0;
  return mindspore::schema::CreateBatchToSpace(
      _fbb,
      blockShape__,
      crops__);
}

struct BatchToSpaceND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_CROPS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *crops() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_CROPS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_CROPS) &&
           verifier.VerifyVector(crops()) &&
           verifier.EndTable();
  }
};

struct BatchToSpaceNDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(BatchToSpaceND::VT_BLOCKSHAPE, blockShape);
  }
  void add_crops(flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops) {
    fbb_.AddOffset(BatchToSpaceND::VT_CROPS, crops);
  }
  explicit BatchToSpaceNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchToSpaceNDBuilder &operator=(const BatchToSpaceNDBuilder &);
  flatbuffers::Offset<BatchToSpaceND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchToSpaceND>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> crops = 0) {
  BatchToSpaceNDBuilder builder_(_fbb);
  builder_.add_crops(crops);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<BatchToSpaceND> CreateBatchToSpaceNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *crops = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto crops__ = crops ? _fbb.CreateVector<int32_t>(*crops) : 0;
  return mindspore::schema::CreateBatchToSpaceND(
      _fbb,
      blockShape__,
      crops__);
}

struct AddN FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_N = 4
  };
  int32_t N() const {
    return GetField<int32_t>(VT_N, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_N) &&
           verifier.EndTable();
  }
};

struct AddNBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_N(int32_t N) {
    fbb_.AddElement<int32_t>(AddN::VT_N, N, 0);
  }
  explicit AddNBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddNBuilder &operator=(const AddNBuilder &);
  flatbuffers::Offset<AddN> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddN>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddN> CreateAddN(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t N = 0) {
  AddNBuilder builder_(_fbb);
  builder_.add_N(N);
  return builder_.Finish();
}

struct EmbeddingLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MAXNORM = 4
  };
  float maxNorm() const {
    return GetField<float>(VT_MAXNORM, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_MAXNORM) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_maxNorm(float maxNorm) {
    fbb_.AddElement<float>(EmbeddingLookup::VT_MAXNORM, maxNorm, 0.0f);
  }
  explicit EmbeddingLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupBuilder &operator=(const EmbeddingLookupBuilder &);
  flatbuffers::Offset<EmbeddingLookup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookup>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookup> CreateEmbeddingLookup(
    flatbuffers::FlatBufferBuilder &_fbb,
    float maxNorm = 0.0f) {
  EmbeddingLookupBuilder builder_(_fbb);
  builder_.add_maxNorm(maxNorm);
  return builder_.Finish();
}

struct EmbeddingLookupSparse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SPIDS = 4,
    VT_SPWEIGHTS = 6,
    VT_MAXNORTM = 8
  };
  const flatbuffers::Vector<int32_t> *spIds() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_SPIDS);
  }
  const flatbuffers::Vector<float> *spWeights() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SPWEIGHTS);
  }
  float maxNortm() const {
    return GetField<float>(VT_MAXNORTM, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SPIDS) &&
           verifier.VerifyVector(spIds()) &&
           VerifyOffset(verifier, VT_SPWEIGHTS) &&
           verifier.VerifyVector(spWeights()) &&
           VerifyField<float>(verifier, VT_MAXNORTM) &&
           verifier.EndTable();
  }
};

struct EmbeddingLookupSparseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_spIds(flatbuffers::Offset<flatbuffers::Vector<int32_t>> spIds) {
    fbb_.AddOffset(EmbeddingLookupSparse::VT_SPIDS, spIds);
  }
  void add_spWeights(flatbuffers::Offset<flatbuffers::Vector<float>> spWeights) {
    fbb_.AddOffset(EmbeddingLookupSparse::VT_SPWEIGHTS, spWeights);
  }
  void add_maxNortm(float maxNortm) {
    fbb_.AddElement<float>(EmbeddingLookupSparse::VT_MAXNORTM, maxNortm, 0.0f);
  }
  explicit EmbeddingLookupSparseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  EmbeddingLookupSparseBuilder &operator=(const EmbeddingLookupSparseBuilder &);
  flatbuffers::Offset<EmbeddingLookupSparse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<EmbeddingLookupSparse>(end);
    return o;
  }
};

inline flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> spIds = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> spWeights = 0,
    float maxNortm = 0.0f) {
  EmbeddingLookupSparseBuilder builder_(_fbb);
  builder_.add_maxNortm(maxNortm);
  builder_.add_spWeights(spWeights);
  builder_.add_spIds(spIds);
  return builder_.Finish();
}

inline flatbuffers::Offset<EmbeddingLookupSparse> CreateEmbeddingLookupSparseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *spIds = nullptr,
    const std::vector<float> *spWeights = nullptr,
    float maxNortm = 0.0f) {
  auto spIds__ = spIds ? _fbb.CreateVector<int32_t>(*spIds) : 0;
  auto spWeights__ = spWeights ? _fbb.CreateVector<float>(*spWeights) : 0;
  return mindspore::schema::CreateEmbeddingLookupSparse(
      _fbb,
      spIds__,
      spWeights__,
      maxNortm);
}

struct FloorDiv FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorDivBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorDivBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorDivBuilder &operator=(const FloorDivBuilder &);
  flatbuffers::Offset<FloorDiv> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorDiv>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorDiv> CreateFloorDiv(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorDivBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FloorMod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FloorModBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FloorModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FloorModBuilder &operator=(const FloorModBuilder &);
  flatbuffers::Offset<FloorMod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FloorMod>(end);
    return o;
  }
};

inline flatbuffers::Offset<FloorMod> CreateFloorMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FloorModBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Mod FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ModBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ModBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ModBuilder &operator=(const ModBuilder &);
  flatbuffers::Offset<Mod> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mod>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mod> CreateMod(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ModBuilder builder_(_fbb);
  return builder_.Finish();
}

struct L2Norm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_EPSILON = 6,
    VT_ACTIVATIONTYPE = 8
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.0f);
  }
  ActivationType activationType() const {
    return static_cast<ActivationType>(GetField<int8_t>(VT_ACTIVATIONTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<int8_t>(verifier, VT_ACTIVATIONTYPE) &&
           verifier.EndTable();
  }
};

struct L2NormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(L2Norm::VT_AXIS, axis);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(L2Norm::VT_EPSILON, epsilon, 0.0f);
  }
  void add_activationType(ActivationType activationType) {
    fbb_.AddElement<int8_t>(L2Norm::VT_ACTIVATIONTYPE, static_cast<int8_t>(activationType), 0);
  }
  explicit L2NormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  L2NormBuilder &operator=(const L2NormBuilder &);
  flatbuffers::Offset<L2Norm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<L2Norm>(end);
    return o;
  }
};

inline flatbuffers::Offset<L2Norm> CreateL2Norm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0,
    float epsilon = 0.0f,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  L2NormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_axis(axis);
  builder_.add_activationType(activationType);
  return builder_.Finish();
}

inline flatbuffers::Offset<L2Norm> CreateL2NormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr,
    float epsilon = 0.0f,
    ActivationType activationType = ActivationType_NO_ACTIVATION) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateL2Norm(
      _fbb,
      axis__,
      epsilon,
      activationType);
}

struct LogicalAnd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalAndBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalAndBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalAndBuilder &operator=(const LogicalAndBuilder &);
  flatbuffers::Offset<LogicalAnd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalAnd>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalAnd> CreateLogicalAnd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalAndBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalOr FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalOrBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalOrBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalOrBuilder &operator=(const LogicalOrBuilder &);
  flatbuffers::Offset<LogicalOr> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalOr>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalOr> CreateLogicalOr(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalOrBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalXor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalXorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalXorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalXorBuilder &operator=(const LogicalXorBuilder &);
  flatbuffers::Offset<LogicalXor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalXor>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalXor> CreateLogicalXor(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalXorBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LogicalNot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct LogicalNotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit LogicalNotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LogicalNotBuilder &operator=(const LogicalNotBuilder &);
  flatbuffers::Offset<LogicalNot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LogicalNot>(end);
    return o;
  }
};

inline flatbuffers::Offset<LogicalNot> CreateLogicalNot(
    flatbuffers::FlatBufferBuilder &_fbb) {
  LogicalNotBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MatrixDiag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_K = 4,
    VT_NUMROWS = 6,
    VT_NUMCOLS = 8,
    VT_PADDINGVALUE = 10
  };
  int32_t k() const {
    return GetField<int32_t>(VT_K, 0);
  }
  int32_t numRows() const {
    return GetField<int32_t>(VT_NUMROWS, 0);
  }
  int32_t numCols() const {
    return GetField<int32_t>(VT_NUMCOLS, 0);
  }
  float paddingValue() const {
    return GetField<float>(VT_PADDINGVALUE, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_K) &&
           VerifyField<int32_t>(verifier, VT_NUMROWS) &&
           VerifyField<int32_t>(verifier, VT_NUMCOLS) &&
           VerifyField<float>(verifier, VT_PADDINGVALUE) &&
           verifier.EndTable();
  }
};

struct MatrixDiagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_k(int32_t k) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_K, k, 0);
  }
  void add_numRows(int32_t numRows) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_NUMROWS, numRows, 0);
  }
  void add_numCols(int32_t numCols) {
    fbb_.AddElement<int32_t>(MatrixDiag::VT_NUMCOLS, numCols, 0);
  }
  void add_paddingValue(float paddingValue) {
    fbb_.AddElement<float>(MatrixDiag::VT_PADDINGVALUE, paddingValue, 0.0f);
  }
  explicit MatrixDiagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MatrixDiagBuilder &operator=(const MatrixDiagBuilder &);
  flatbuffers::Offset<MatrixDiag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MatrixDiag>(end);
    return o;
  }
};

inline flatbuffers::Offset<MatrixDiag> CreateMatrixDiag(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t k = 0,
    int32_t numRows = 0,
    int32_t numCols = 0,
    float paddingValue = 0.0f) {
  MatrixDiagBuilder builder_(_fbb);
  builder_.add_paddingValue(paddingValue);
  builder_.add_numCols(numCols);
  builder_.add_numRows(numRows);
  builder_.add_k(k);
  return builder_.Finish();
}

struct Select FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SelectBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SelectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SelectBuilder &operator=(const SelectBuilder &);
  flatbuffers::Offset<Select> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Select>(end);
    return o;
  }
};

inline flatbuffers::Offset<Select> CreateSelect(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SelectBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TfReduce FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  ReduceType type() const {
    return static_cast<ReduceType>(GetField<int8_t>(VT_TYPE, 7));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct TfReduceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ReduceType type) {
    fbb_.AddElement<int8_t>(TfReduce::VT_TYPE, static_cast<int8_t>(type), 7);
  }
  explicit TfReduceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TfReduceBuilder &operator=(const TfReduceBuilder &);
  flatbuffers::Offset<TfReduce> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TfReduce>(end);
    return o;
  }
};

inline flatbuffers::Offset<TfReduce> CreateTfReduce(
    flatbuffers::FlatBufferBuilder &_fbb,
    ReduceType type = ReduceType_UNKNOW) {
  TfReduceBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct Reverse FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  const flatbuffers::Vector<int32_t> *axis() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_AXIS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_AXIS) &&
           verifier.VerifyVector(axis()) &&
           verifier.EndTable();
  }
};

struct ReverseBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis) {
    fbb_.AddOffset(Reverse::VT_AXIS, axis);
  }
  explicit ReverseBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReverseBuilder &operator=(const ReverseBuilder &);
  flatbuffers::Offset<Reverse> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reverse>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reverse> CreateReverse(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> axis = 0) {
  ReverseBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

inline flatbuffers::Offset<Reverse> CreateReverseDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *axis = nullptr) {
  auto axis__ = axis ? _fbb.CreateVector<int32_t>(*axis) : 0;
  return mindspore::schema::CreateReverse(
      _fbb,
      axis__);
}

struct Round FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct RoundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit RoundBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RoundBuilder &operator=(const RoundBuilder &);
  flatbuffers::Offset<Round> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Round>(end);
    return o;
  }
};

inline flatbuffers::Offset<Round> CreateRound(
    flatbuffers::FlatBufferBuilder &_fbb) {
  RoundBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Scatter FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScatterBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterBuilder &operator=(const ScatterBuilder &);
  flatbuffers::Offset<Scatter> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Scatter>(end);
    return o;
  }
};

inline flatbuffers::Offset<Scatter> CreateScatter(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ScatterND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ScatterNDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ScatterNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ScatterNDBuilder &operator=(const ScatterNDBuilder &);
  flatbuffers::Offset<ScatterND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ScatterND>(end);
    return o;
  }
};

inline flatbuffers::Offset<ScatterND> CreateScatterND(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ScatterNDBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Unique FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTTYPE = 4
  };
  int32_t outType() const {
    return GetField<int32_t>(VT_OUTTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTTYPE) &&
           verifier.EndTable();
  }
};

struct UniqueBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outType(int32_t outType) {
    fbb_.AddElement<int32_t>(Unique::VT_OUTTYPE, outType, 0);
  }
  explicit UniqueBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UniqueBuilder &operator=(const UniqueBuilder &);
  flatbuffers::Offset<Unique> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unique>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unique> CreateUnique(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outType = 0) {
  UniqueBuilder builder_(_fbb);
  builder_.add_outType(outType);
  return builder_.Finish();
}

struct Unstack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUM = 4,
    VT_AXIS = 6
  };
  int32_t num() const {
    return GetField<int32_t>(VT_NUM, 0);
  }
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUM) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct UnstackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_num(int32_t num) {
    fbb_.AddElement<int32_t>(Unstack::VT_NUM, num, 0);
  }
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(Unstack::VT_AXIS, axis, 0);
  }
  explicit UnstackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnstackBuilder &operator=(const UnstackBuilder &);
  flatbuffers::Offset<Unstack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Unstack>(end);
    return o;
  }
};

inline flatbuffers::Offset<Unstack> CreateUnstack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t num = 0,
    int32_t axis = 0) {
  UnstackBuilder builder_(_fbb);
  builder_.add_axis(axis);
  builder_.add_num(num);
  return builder_.Finish();
}

struct OnnxInt8Quantize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OnnxInt8QuantizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnnxInt8QuantizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OnnxInt8QuantizeBuilder &operator=(const OnnxInt8QuantizeBuilder &);
  flatbuffers::Offset<OnnxInt8Quantize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnnxInt8Quantize>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnnxInt8Quantize> CreateOnnxInt8Quantize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnnxInt8QuantizeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct OnnxInt8Dequantize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OnnxInt8DequantizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnnxInt8DequantizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OnnxInt8DequantizeBuilder &operator=(const OnnxInt8DequantizeBuilder &);
  flatbuffers::Offset<OnnxInt8Dequantize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnnxInt8Dequantize>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnnxInt8Dequantize> CreateOnnxInt8Dequantize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnnxInt8DequantizeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantWithMinMax FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FakeQuantWithMinMaxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantWithMinMaxBuilder &operator=(const FakeQuantWithMinMaxBuilder &);
  flatbuffers::Offset<FakeQuantWithMinMax> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMax>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMax> CreateFakeQuantWithMinMax(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FakeQuantWithMinMaxBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FakeQuantWithMinMaxPerChannel FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FakeQuantWithMinMaxPerChannelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FakeQuantWithMinMaxPerChannelBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FakeQuantWithMinMaxPerChannelBuilder &operator=(const FakeQuantWithMinMaxPerChannelBuilder &);
  flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FakeQuantWithMinMaxPerChannel>(end);
    return o;
  }
};

inline flatbuffers::Offset<FakeQuantWithMinMaxPerChannel> CreateFakeQuantWithMinMaxPerChannel(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FakeQuantWithMinMaxPerChannelBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BatchNormFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct BatchNormFoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit BatchNormFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BatchNormFoldBuilder &operator=(const BatchNormFoldBuilder &);
  flatbuffers::Offset<BatchNormFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BatchNormFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<BatchNormFold> CreateBatchNormFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  BatchNormFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MulFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MulFoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MulFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MulFoldBuilder &operator=(const MulFoldBuilder &);
  flatbuffers::Offset<MulFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MulFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<MulFold> CreateMulFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MulFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AddFold FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AddFoldBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AddFoldBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AddFoldBuilder &operator=(const AddFoldBuilder &);
  flatbuffers::Offset<AddFold> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AddFold>(end);
    return o;
  }
};

inline flatbuffers::Offset<AddFold> CreateAddFold(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AddFoldBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SquaredDifference FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SquaredDifferenceBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SquaredDifferenceBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SquaredDifferenceBuilder &operator=(const SquaredDifferenceBuilder &);
  flatbuffers::Offset<SquaredDifference> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SquaredDifference>(end);
    return o;
  }
};

inline flatbuffers::Offset<SquaredDifference> CreateSquaredDifference(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SquaredDifferenceBuilder builder_(_fbb);
  return builder_.Finish();
}

struct TupleGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct TupleGetItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit TupleGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TupleGetItemBuilder &operator=(const TupleGetItemBuilder &);
  flatbuffers::Offset<TupleGetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TupleGetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TupleGetItem> CreateTupleGetItem(
    flatbuffers::FlatBufferBuilder &_fbb) {
  TupleGetItemBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ApplyMomentum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_GRADIENTSCALE = 4,
    VT_USENESTEROV = 6
  };
  float gradientScale() const {
    return GetField<float>(VT_GRADIENTSCALE, 0.0f);
  }
  bool useNesterov() const {
    return GetField<uint8_t>(VT_USENESTEROV, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_GRADIENTSCALE) &&
           VerifyField<uint8_t>(verifier, VT_USENESTEROV) &&
           verifier.EndTable();
  }
};

struct ApplyMomentumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_gradientScale(float gradientScale) {
    fbb_.AddElement<float>(ApplyMomentum::VT_GRADIENTSCALE, gradientScale, 0.0f);
  }
  void add_useNesterov(bool useNesterov) {
    fbb_.AddElement<uint8_t>(ApplyMomentum::VT_USENESTEROV, static_cast<uint8_t>(useNesterov), 0);
  }
  explicit ApplyMomentumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ApplyMomentumBuilder &operator=(const ApplyMomentumBuilder &);
  flatbuffers::Offset<ApplyMomentum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ApplyMomentum>(end);
    return o;
  }
};

inline flatbuffers::Offset<ApplyMomentum> CreateApplyMomentum(
    flatbuffers::FlatBufferBuilder &_fbb,
    float gradientScale = 0.0f,
    bool useNesterov = false) {
  ApplyMomentumBuilder builder_(_fbb);
  builder_.add_gradientScale(gradientScale);
  builder_.add_useNesterov(useNesterov);
  return builder_.Finish();
}

struct Sgd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WEIGHTDECAY = 4,
    VT_DAMPENING = 6,
    VT_USENESTEROV = 8
  };
  float weightDecay() const {
    return GetField<float>(VT_WEIGHTDECAY, 0.0f);
  }
  float dampening() const {
    return GetField<float>(VT_DAMPENING, 0.0f);
  }
  bool useNesterov() const {
    return GetField<uint8_t>(VT_USENESTEROV, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_WEIGHTDECAY) &&
           VerifyField<float>(verifier, VT_DAMPENING) &&
           VerifyField<uint8_t>(verifier, VT_USENESTEROV) &&
           verifier.EndTable();
  }
};

struct SgdBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_weightDecay(float weightDecay) {
    fbb_.AddElement<float>(Sgd::VT_WEIGHTDECAY, weightDecay, 0.0f);
  }
  void add_dampening(float dampening) {
    fbb_.AddElement<float>(Sgd::VT_DAMPENING, dampening, 0.0f);
  }
  void add_useNesterov(bool useNesterov) {
    fbb_.AddElement<uint8_t>(Sgd::VT_USENESTEROV, static_cast<uint8_t>(useNesterov), 0);
  }
  explicit SgdBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SgdBuilder &operator=(const SgdBuilder &);
  flatbuffers::Offset<Sgd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Sgd>(end);
    return o;
  }
};

inline flatbuffers::Offset<Sgd> CreateSgd(
    flatbuffers::FlatBufferBuilder &_fbb,
    float weightDecay = 0.0f,
    float dampening = 0.0f,
    bool useNesterov = false) {
  SgdBuilder builder_(_fbb);
  builder_.add_dampening(dampening);
  builder_.add_weightDecay(weightDecay);
  builder_.add_useNesterov(useNesterov);
  return builder_.Finish();
}

struct Adam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_USENESTEROV = 4
  };
  bool useNesterov() const {
    return GetField<uint8_t>(VT_USENESTEROV, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_USENESTEROV) &&
           verifier.EndTable();
  }
};

struct AdamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_useNesterov(bool useNesterov) {
    fbb_.AddElement<uint8_t>(Adam::VT_USENESTEROV, static_cast<uint8_t>(useNesterov), 0);
  }
  explicit AdamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AdamBuilder &operator=(const AdamBuilder &);
  flatbuffers::Offset<Adam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Adam>(end);
    return o;
  }
};

inline flatbuffers::Offset<Adam> CreateAdam(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool useNesterov = false) {
  AdamBuilder builder_(_fbb);
  builder_.add_useNesterov(useNesterov);
  return builder_.Finish();
}

struct Assign FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AssignBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignBuilder &operator=(const AssignBuilder &);
  flatbuffers::Offset<Assign> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assign>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assign> CreateAssign(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AssignAdd FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AssignAddBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit AssignAddBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssignAddBuilder &operator=(const AssignAddBuilder &);
  flatbuffers::Offset<AssignAdd> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AssignAdd>(end);
    return o;
  }
};

inline flatbuffers::Offset<AssignAdd> CreateAssignAdd(
    flatbuffers::FlatBufferBuilder &_fbb) {
  AssignAddBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Where FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONDITION = 4
  };
  const flatbuffers::Vector<uint8_t> *condition() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CONDITION);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CONDITION) &&
           verifier.VerifyVector(condition()) &&
           verifier.EndTable();
  }
};

struct WhereBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_condition(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> condition) {
    fbb_.AddOffset(Where::VT_CONDITION, condition);
  }
  explicit WhereBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhereBuilder &operator=(const WhereBuilder &);
  flatbuffers::Offset<Where> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Where>(end);
    return o;
  }
};

inline flatbuffers::Offset<Where> CreateWhere(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> condition = 0) {
  WhereBuilder builder_(_fbb);
  builder_.add_condition(condition);
  return builder_.Finish();
}

inline flatbuffers::Offset<Where> CreateWhereDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *condition = nullptr) {
  auto condition__ = condition ? _fbb.CreateVector<uint8_t>(*condition) : 0;
  return mindspore::schema::CreateWhere(
      _fbb,
      condition__);
}

struct OneHot FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           verifier.EndTable();
  }
};

struct OneHotBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(OneHot::VT_AXIS, axis, 0);
  }
  explicit OneHotBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OneHotBuilder &operator=(const OneHotBuilder &);
  flatbuffers::Offset<OneHot> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OneHot>(end);
    return o;
  }
};

inline flatbuffers::Offset<OneHot> CreateOneHot(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0) {
  OneHotBuilder builder_(_fbb);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Lstm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BIDIRECTION = 4
  };
  bool bidirection() const {
    return GetField<uint8_t>(VT_BIDIRECTION, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_BIDIRECTION) &&
           verifier.EndTable();
  }
};

struct LstmBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_bidirection(bool bidirection) {
    fbb_.AddElement<uint8_t>(Lstm::VT_BIDIRECTION, static_cast<uint8_t>(bidirection), 0);
  }
  explicit LstmBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LstmBuilder &operator=(const LstmBuilder &);
  flatbuffers::Offset<Lstm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Lstm>(end);
    return o;
  }
};

inline flatbuffers::Offset<Lstm> CreateLstm(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool bidirection = false) {
  LstmBuilder builder_(_fbb);
  builder_.add_bidirection(bidirection);
  return builder_.Finish();
}

struct PriorBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_MIN_SIZES = 4,
    VT_MAX_SIZES = 6,
    VT_ASPECT_RATIOS = 8,
    VT_VARIANCES = 10,
    VT_IMAGE_SIZE_W = 12,
    VT_IMAGE_SIZE_H = 14,
    VT_STEP_W = 16,
    VT_STEP_H = 18,
    VT_CLIP = 20,
    VT_FLIP = 22,
    VT_OFFSET = 24
  };
  const flatbuffers::Vector<int32_t> *min_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MIN_SIZES);
  }
  const flatbuffers::Vector<int32_t> *max_sizes() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_MAX_SIZES);
  }
  const flatbuffers::Vector<float> *aspect_ratios() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_ASPECT_RATIOS);
  }
  const flatbuffers::Vector<float> *variances() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_VARIANCES);
  }
  int32_t image_size_w() const {
    return GetField<int32_t>(VT_IMAGE_SIZE_W, 0);
  }
  int32_t image_size_h() const {
    return GetField<int32_t>(VT_IMAGE_SIZE_H, 0);
  }
  float step_w() const {
    return GetField<float>(VT_STEP_W, 0.0f);
  }
  float step_h() const {
    return GetField<float>(VT_STEP_H, 0.0f);
  }
  bool clip() const {
    return GetField<uint8_t>(VT_CLIP, 1) != 0;
  }
  bool flip() const {
    return GetField<uint8_t>(VT_FLIP, 1) != 0;
  }
  float offset() const {
    return GetField<float>(VT_OFFSET, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_MIN_SIZES) &&
           verifier.VerifyVector(min_sizes()) &&
           VerifyOffset(verifier, VT_MAX_SIZES) &&
           verifier.VerifyVector(max_sizes()) &&
           VerifyOffset(verifier, VT_ASPECT_RATIOS) &&
           verifier.VerifyVector(aspect_ratios()) &&
           VerifyOffset(verifier, VT_VARIANCES) &&
           verifier.VerifyVector(variances()) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_SIZE_W) &&
           VerifyField<int32_t>(verifier, VT_IMAGE_SIZE_H) &&
           VerifyField<float>(verifier, VT_STEP_W) &&
           VerifyField<float>(verifier, VT_STEP_H) &&
           VerifyField<uint8_t>(verifier, VT_CLIP) &&
           VerifyField<uint8_t>(verifier, VT_FLIP) &&
           VerifyField<float>(verifier, VT_OFFSET) &&
           verifier.EndTable();
  }
};

struct PriorBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_min_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> min_sizes) {
    fbb_.AddOffset(PriorBox::VT_MIN_SIZES, min_sizes);
  }
  void add_max_sizes(flatbuffers::Offset<flatbuffers::Vector<int32_t>> max_sizes) {
    fbb_.AddOffset(PriorBox::VT_MAX_SIZES, max_sizes);
  }
  void add_aspect_ratios(flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios) {
    fbb_.AddOffset(PriorBox::VT_ASPECT_RATIOS, aspect_ratios);
  }
  void add_variances(flatbuffers::Offset<flatbuffers::Vector<float>> variances) {
    fbb_.AddOffset(PriorBox::VT_VARIANCES, variances);
  }
  void add_image_size_w(int32_t image_size_w) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGE_SIZE_W, image_size_w, 0);
  }
  void add_image_size_h(int32_t image_size_h) {
    fbb_.AddElement<int32_t>(PriorBox::VT_IMAGE_SIZE_H, image_size_h, 0);
  }
  void add_step_w(float step_w) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_W, step_w, 0.0f);
  }
  void add_step_h(float step_h) {
    fbb_.AddElement<float>(PriorBox::VT_STEP_H, step_h, 0.0f);
  }
  void add_clip(bool clip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_CLIP, static_cast<uint8_t>(clip), 1);
  }
  void add_flip(bool flip) {
    fbb_.AddElement<uint8_t>(PriorBox::VT_FLIP, static_cast<uint8_t>(flip), 1);
  }
  void add_offset(float offset) {
    fbb_.AddElement<float>(PriorBox::VT_OFFSET, offset, 0.0f);
  }
  explicit PriorBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PriorBoxBuilder &operator=(const PriorBoxBuilder &);
  flatbuffers::Offset<PriorBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<PriorBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<PriorBox> CreatePriorBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> min_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> max_sizes = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> aspect_ratios = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> variances = 0,
    int32_t image_size_w = 0,
    int32_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = true,
    bool flip = true,
    float offset = 0.0f) {
  PriorBoxBuilder builder_(_fbb);
  builder_.add_offset(offset);
  builder_.add_step_h(step_h);
  builder_.add_step_w(step_w);
  builder_.add_image_size_h(image_size_h);
  builder_.add_image_size_w(image_size_w);
  builder_.add_variances(variances);
  builder_.add_aspect_ratios(aspect_ratios);
  builder_.add_max_sizes(max_sizes);
  builder_.add_min_sizes(min_sizes);
  builder_.add_flip(flip);
  builder_.add_clip(clip);
  return builder_.Finish();
}

inline flatbuffers::Offset<PriorBox> CreatePriorBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *min_sizes = nullptr,
    const std::vector<int32_t> *max_sizes = nullptr,
    const std::vector<float> *aspect_ratios = nullptr,
    const std::vector<float> *variances = nullptr,
    int32_t image_size_w = 0,
    int32_t image_size_h = 0,
    float step_w = 0.0f,
    float step_h = 0.0f,
    bool clip = true,
    bool flip = true,
    float offset = 0.0f) {
  auto min_sizes__ = min_sizes ? _fbb.CreateVector<int32_t>(*min_sizes) : 0;
  auto max_sizes__ = max_sizes ? _fbb.CreateVector<int32_t>(*max_sizes) : 0;
  auto aspect_ratios__ = aspect_ratios ? _fbb.CreateVector<float>(*aspect_ratios) : 0;
  auto variances__ = variances ? _fbb.CreateVector<float>(*variances) : 0;
  return mindspore::schema::CreatePriorBox(
      _fbb,
      min_sizes__,
      max_sizes__,
      aspect_ratios__,
      variances__,
      image_size_w,
      image_size_h,
      step_w,
      step_h,
      clip,
      flip,
      offset);
}

struct SpaceToBatchND FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKSHAPE = 4,
    VT_PADDINGS = 6
  };
  const flatbuffers::Vector<int32_t> *blockShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_BLOCKSHAPE);
  }
  const flatbuffers::Vector<int32_t> *paddings() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_PADDINGS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKSHAPE) &&
           verifier.VerifyVector(blockShape()) &&
           VerifyOffset(verifier, VT_PADDINGS) &&
           verifier.VerifyVector(paddings()) &&
           verifier.EndTable();
  }
};

struct SpaceToBatchNDBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape) {
    fbb_.AddOffset(SpaceToBatchND::VT_BLOCKSHAPE, blockShape);
  }
  void add_paddings(flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings) {
    fbb_.AddOffset(SpaceToBatchND::VT_PADDINGS, paddings);
  }
  explicit SpaceToBatchNDBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SpaceToBatchNDBuilder &operator=(const SpaceToBatchNDBuilder &);
  flatbuffers::Offset<SpaceToBatchND> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SpaceToBatchND>(end);
    return o;
  }
};

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchND(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> blockShape = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> paddings = 0) {
  SpaceToBatchNDBuilder builder_(_fbb);
  builder_.add_paddings(paddings);
  builder_.add_blockShape(blockShape);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpaceToBatchND> CreateSpaceToBatchNDDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *blockShape = nullptr,
    const std::vector<int32_t> *paddings = nullptr) {
  auto blockShape__ = blockShape ? _fbb.CreateVector<int32_t>(*blockShape) : 0;
  auto paddings__ = paddings ? _fbb.CreateVector<int32_t>(*paddings) : 0;
  return mindspore::schema::CreateSpaceToBatchND(
      _fbb,
      blockShape__,
      paddings__);
}

struct MakeTuple FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MakeTupleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MakeTupleBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MakeTupleBuilder &operator=(const MakeTupleBuilder &);
  flatbuffers::Offset<MakeTuple> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MakeTuple>(end);
    return o;
  }
};

inline flatbuffers::Offset<MakeTuple> CreateMakeTuple(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MakeTupleBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ToFormat FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SRCT = 4,
    VT_DSTT = 6
  };
  int32_t srcT() const {
    return GetField<int32_t>(VT_SRCT, 0);
  }
  int32_t dstT() const {
    return GetField<int32_t>(VT_DSTT, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SRCT) &&
           VerifyField<int32_t>(verifier, VT_DSTT) &&
           verifier.EndTable();
  }
};

struct ToFormatBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_srcT(int32_t srcT) {
    fbb_.AddElement<int32_t>(ToFormat::VT_SRCT, srcT, 0);
  }
  void add_dstT(int32_t dstT) {
    fbb_.AddElement<int32_t>(ToFormat::VT_DSTT, dstT, 0);
  }
  explicit ToFormatBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ToFormatBuilder &operator=(const ToFormatBuilder &);
  flatbuffers::Offset<ToFormat> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ToFormat>(end);
    return o;
  }
};

inline flatbuffers::Offset<ToFormat> CreateToFormat(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t srcT = 0,
    int32_t dstT = 0) {
  ToFormatBuilder builder_(_fbb);
  builder_.add_dstT(dstT);
  builder_.add_srcT(srcT);
  return builder_.Finish();
}

struct Depend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct DependBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit DependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DependBuilder &operator=(const DependBuilder &);
  flatbuffers::Offset<Depend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Depend>(end);
    return o;
  }
};

inline flatbuffers::Offset<Depend> CreateDepend(
    flatbuffers::FlatBufferBuilder &_fbb) {
  DependBuilder builder_(_fbb);
  return builder_.Finish();
}

struct ControlDepend FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ControlDependBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ControlDependBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ControlDependBuilder &operator=(const ControlDependBuilder &);
  flatbuffers::Offset<ControlDepend> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ControlDepend>(end);
    return o;
  }
};

inline flatbuffers::Offset<ControlDepend> CreateControlDepend(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ControlDependBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Return FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReturnBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReturnBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReturnBuilder &operator=(const ReturnBuilder &);
  flatbuffers::Offset<Return> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Return>(end);
    return o;
  }
};

inline flatbuffers::Offset<Return> CreateReturn(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReturnBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Proposal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FEAT_STRIDE = 4,
    VT_BASE_SIZE = 6,
    VT_MIN_SIZE = 8,
    VT_RATIO = 10,
    VT_SCALE = 12,
    VT_PRE_NMS_TOPN = 14,
    VT_POST_NMS_TOPN = 16,
    VT_NMS_THRESH = 18
  };
  float feat_stride() const {
    return GetField<float>(VT_FEAT_STRIDE, 0.0f);
  }
  float base_size() const {
    return GetField<float>(VT_BASE_SIZE, 0.0f);
  }
  float min_size() const {
    return GetField<float>(VT_MIN_SIZE, 0.0f);
  }
  const flatbuffers::Vector<float> *ratio() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_RATIO);
  }
  const flatbuffers::Vector<float> *scale() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_SCALE);
  }
  int32_t pre_nms_topn() const {
    return GetField<int32_t>(VT_PRE_NMS_TOPN, 0);
  }
  int32_t post_nms_topn() const {
    return GetField<int32_t>(VT_POST_NMS_TOPN, 0);
  }
  float nms_thresh() const {
    return GetField<float>(VT_NMS_THRESH, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FEAT_STRIDE) &&
           VerifyField<float>(verifier, VT_BASE_SIZE) &&
           VerifyField<float>(verifier, VT_MIN_SIZE) &&
           VerifyOffset(verifier, VT_RATIO) &&
           verifier.VerifyVector(ratio()) &&
           VerifyOffset(verifier, VT_SCALE) &&
           verifier.VerifyVector(scale()) &&
           VerifyField<int32_t>(verifier, VT_PRE_NMS_TOPN) &&
           VerifyField<int32_t>(verifier, VT_POST_NMS_TOPN) &&
           VerifyField<float>(verifier, VT_NMS_THRESH) &&
           verifier.EndTable();
  }
};

struct ProposalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_feat_stride(float feat_stride) {
    fbb_.AddElement<float>(Proposal::VT_FEAT_STRIDE, feat_stride, 0.0f);
  }
  void add_base_size(float base_size) {
    fbb_.AddElement<float>(Proposal::VT_BASE_SIZE, base_size, 0.0f);
  }
  void add_min_size(float min_size) {
    fbb_.AddElement<float>(Proposal::VT_MIN_SIZE, min_size, 0.0f);
  }
  void add_ratio(flatbuffers::Offset<flatbuffers::Vector<float>> ratio) {
    fbb_.AddOffset(Proposal::VT_RATIO, ratio);
  }
  void add_scale(flatbuffers::Offset<flatbuffers::Vector<float>> scale) {
    fbb_.AddOffset(Proposal::VT_SCALE, scale);
  }
  void add_pre_nms_topn(int32_t pre_nms_topn) {
    fbb_.AddElement<int32_t>(Proposal::VT_PRE_NMS_TOPN, pre_nms_topn, 0);
  }
  void add_post_nms_topn(int32_t post_nms_topn) {
    fbb_.AddElement<int32_t>(Proposal::VT_POST_NMS_TOPN, post_nms_topn, 0);
  }
  void add_nms_thresh(float nms_thresh) {
    fbb_.AddElement<float>(Proposal::VT_NMS_THRESH, nms_thresh, 0.0f);
  }
  explicit ProposalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ProposalBuilder &operator=(const ProposalBuilder &);
  flatbuffers::Offset<Proposal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Proposal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Proposal> CreateProposal(
    flatbuffers::FlatBufferBuilder &_fbb,
    float feat_stride = 0.0f,
    float base_size = 0.0f,
    float min_size = 0.0f,
    flatbuffers::Offset<flatbuffers::Vector<float>> ratio = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> scale = 0,
    int32_t pre_nms_topn = 0,
    int32_t post_nms_topn = 0,
    float nms_thresh = 0.0f) {
  ProposalBuilder builder_(_fbb);
  builder_.add_nms_thresh(nms_thresh);
  builder_.add_post_nms_topn(post_nms_topn);
  builder_.add_pre_nms_topn(pre_nms_topn);
  builder_.add_scale(scale);
  builder_.add_ratio(ratio);
  builder_.add_min_size(min_size);
  builder_.add_base_size(base_size);
  builder_.add_feat_stride(feat_stride);
  return builder_.Finish();
}

inline flatbuffers::Offset<Proposal> CreateProposalDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    float feat_stride = 0.0f,
    float base_size = 0.0f,
    float min_size = 0.0f,
    const std::vector<float> *ratio = nullptr,
    const std::vector<float> *scale = nullptr,
    int32_t pre_nms_topn = 0,
    int32_t post_nms_topn = 0,
    float nms_thresh = 0.0f) {
  auto ratio__ = ratio ? _fbb.CreateVector<float>(*ratio) : 0;
  auto scale__ = scale ? _fbb.CreateVector<float>(*scale) : 0;
  return mindspore::schema::CreateProposal(
      _fbb,
      feat_stride,
      base_size,
      min_size,
      ratio__,
      scale__,
      pre_nms_topn,
      post_nms_topn,
      nms_thresh);
}

struct Custom FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CUSTOM = 4
  };
  const flatbuffers::Vector<uint8_t> *custom() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_CUSTOM);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_CUSTOM) &&
           verifier.VerifyVector(custom()) &&
           verifier.EndTable();
  }
};

struct CustomBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_custom(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom) {
    fbb_.AddOffset(Custom::VT_CUSTOM, custom);
  }
  explicit CustomBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomBuilder &operator=(const CustomBuilder &);
  flatbuffers::Offset<Custom> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Custom>(end);
    return o;
  }
};

inline flatbuffers::Offset<Custom> CreateCustom(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> custom = 0) {
  CustomBuilder builder_(_fbb);
  builder_.add_custom(custom);
  return builder_.Finish();
}

inline flatbuffers::Offset<Custom> CreateCustomDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *custom = nullptr) {
  auto custom__ = custom ? _fbb.CreateVector<uint8_t>(*custom) : 0;
  return mindspore::schema::CreateCustom(
      _fbb,
      custom__);
}

struct BlackBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ID = 4,
    VT_SIZE = 6,
    VT_ADDRESS = 8
  };
  const flatbuffers::String *id() const {
    return GetPointer<const flatbuffers::String *>(VT_ID);
  }
  int32_t size() const {
    return GetField<int32_t>(VT_SIZE, 0);
  }
  const flatbuffers::Vector<uint8_t> *address() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_ADDRESS);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ID) &&
           verifier.VerifyString(id()) &&
           VerifyField<int32_t>(verifier, VT_SIZE) &&
           VerifyOffset(verifier, VT_ADDRESS) &&
           verifier.VerifyVector(address()) &&
           verifier.EndTable();
  }
};

struct BlackBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_id(flatbuffers::Offset<flatbuffers::String> id) {
    fbb_.AddOffset(BlackBox::VT_ID, id);
  }
  void add_size(int32_t size) {
    fbb_.AddElement<int32_t>(BlackBox::VT_SIZE, size, 0);
  }
  void add_address(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address) {
    fbb_.AddOffset(BlackBox::VT_ADDRESS, address);
  }
  explicit BlackBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlackBoxBuilder &operator=(const BlackBoxBuilder &);
  flatbuffers::Offset<BlackBox> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlackBox>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlackBox> CreateBlackBox(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> id = 0,
    int32_t size = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> address = 0) {
  BlackBoxBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_size(size);
  builder_.add_id(id);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlackBox> CreateBlackBoxDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *id = nullptr,
    int32_t size = 0,
    const std::vector<uint8_t> *address = nullptr) {
  auto id__ = id ? _fbb.CreateString(id) : 0;
  auto address__ = address ? _fbb.CreateVector<uint8_t>(*address) : 0;
  return mindspore::schema::CreateBlackBox(
      _fbb,
      id__,
      size,
      address__);
}

struct LshProjection FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_TYPE = 4
  };
  LshProjectionType type() const {
    return static_cast<LshProjectionType>(GetField<int8_t>(VT_TYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           verifier.EndTable();
  }
};

struct LshProjectionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(LshProjectionType type) {
    fbb_.AddElement<int8_t>(LshProjection::VT_TYPE, static_cast<int8_t>(type), 0);
  }
  explicit LshProjectionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LshProjectionBuilder &operator=(const LshProjectionBuilder &);
  flatbuffers::Offset<LshProjection> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LshProjection>(end);
    return o;
  }
};

inline flatbuffers::Offset<LshProjection> CreateLshProjection(
    flatbuffers::FlatBufferBuilder &_fbb,
    LshProjectionType type = LshProjectionType_UNKNOWN) {
  LshProjectionBuilder builder_(_fbb);
  builder_.add_type(type);
  return builder_.Finish();
}

struct HashtableLookup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct HashtableLookupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit HashtableLookupBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  HashtableLookupBuilder &operator=(const HashtableLookupBuilder &);
  flatbuffers::Offset<HashtableLookup> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<HashtableLookup>(end);
    return o;
  }
};

inline flatbuffers::Offset<HashtableLookup> CreateHashtableLookup(
    flatbuffers::FlatBufferBuilder &_fbb) {
  HashtableLookupBuilder builder_(_fbb);
  return builder_.Finish();
}

struct SkipGram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INCLUDEALLGRAMS = 4,
    VT_MAXSKIPSIZE = 6,
    VT_NGRAMSIZE = 8
  };
  bool includeAllGrams() const {
    return GetField<uint8_t>(VT_INCLUDEALLGRAMS, 0) != 0;
  }
  int32_t maxSkipSize() const {
    return GetField<int32_t>(VT_MAXSKIPSIZE, 0);
  }
  int32_t ngramSize() const {
    return GetField<int32_t>(VT_NGRAMSIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_INCLUDEALLGRAMS) &&
           VerifyField<int32_t>(verifier, VT_MAXSKIPSIZE) &&
           VerifyField<int32_t>(verifier, VT_NGRAMSIZE) &&
           verifier.EndTable();
  }
};

struct SkipGramBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_includeAllGrams(bool includeAllGrams) {
    fbb_.AddElement<uint8_t>(SkipGram::VT_INCLUDEALLGRAMS, static_cast<uint8_t>(includeAllGrams), 0);
  }
  void add_maxSkipSize(int32_t maxSkipSize) {
    fbb_.AddElement<int32_t>(SkipGram::VT_MAXSKIPSIZE, maxSkipSize, 0);
  }
  void add_ngramSize(int32_t ngramSize) {
    fbb_.AddElement<int32_t>(SkipGram::VT_NGRAMSIZE, ngramSize, 0);
  }
  explicit SkipGramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SkipGramBuilder &operator=(const SkipGramBuilder &);
  flatbuffers::Offset<SkipGram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SkipGram>(end);
    return o;
  }
};

inline flatbuffers::Offset<SkipGram> CreateSkipGram(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool includeAllGrams = false,
    int32_t maxSkipSize = 0,
    int32_t ngramSize = 0) {
  SkipGramBuilder builder_(_fbb);
  builder_.add_ngramSize(ngramSize);
  builder_.add_maxSkipSize(maxSkipSize);
  builder_.add_includeAllGrams(includeAllGrams);
  return builder_.Finish();
}

struct CustomPredict FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OUTPUTNUM = 4,
    VT_WEIGHTTHRESHOLD = 6
  };
  int32_t outputNum() const {
    return GetField<int32_t>(VT_OUTPUTNUM, 0);
  }
  float weightThreshold() const {
    return GetField<float>(VT_WEIGHTTHRESHOLD, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_OUTPUTNUM) &&
           VerifyField<float>(verifier, VT_WEIGHTTHRESHOLD) &&
           verifier.EndTable();
  }
};

struct CustomPredictBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_outputNum(int32_t outputNum) {
    fbb_.AddElement<int32_t>(CustomPredict::VT_OUTPUTNUM, outputNum, 0);
  }
  void add_weightThreshold(float weightThreshold) {
    fbb_.AddElement<float>(CustomPredict::VT_WEIGHTTHRESHOLD, weightThreshold, 0.0f);
  }
  explicit CustomPredictBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomPredictBuilder &operator=(const CustomPredictBuilder &);
  flatbuffers::Offset<CustomPredict> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomPredict>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomPredict> CreateCustomPredict(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t outputNum = 0,
    float weightThreshold = 0.0f) {
  CustomPredictBuilder builder_(_fbb);
  builder_.add_weightThreshold(weightThreshold);
  builder_.add_outputNum(outputNum);
  return builder_.Finish();
}

struct CustomNormalize FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CustomNormalizeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomNormalizeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomNormalizeBuilder &operator=(const CustomNormalizeBuilder &);
  flatbuffers::Offset<CustomNormalize> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomNormalize>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomNormalize> CreateCustomNormalize(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomNormalizeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CustomExtractFeatures FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CustomExtractFeaturesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CustomExtractFeaturesBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CustomExtractFeaturesBuilder &operator=(const CustomExtractFeaturesBuilder &);
  flatbuffers::Offset<CustomExtractFeatures> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CustomExtractFeatures>(end);
    return o;
  }
};

inline flatbuffers::Offset<CustomExtractFeatures> CreateCustomExtractFeatures(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CustomExtractFeaturesBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AudioSpectrogram FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_WINDOWSIZE = 4,
    VT_STRIDE = 6,
    VT_MAGSQUARE = 8
  };
  int32_t windowSize() const {
    return GetField<int32_t>(VT_WINDOWSIZE, 0);
  }
  int32_t stride() const {
    return GetField<int32_t>(VT_STRIDE, 0);
  }
  bool magSquare() const {
    return GetField<uint8_t>(VT_MAGSQUARE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_WINDOWSIZE) &&
           VerifyField<int32_t>(verifier, VT_STRIDE) &&
           VerifyField<uint8_t>(verifier, VT_MAGSQUARE) &&
           verifier.EndTable();
  }
};

struct AudioSpectrogramBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_windowSize(int32_t windowSize) {
    fbb_.AddElement<int32_t>(AudioSpectrogram::VT_WINDOWSIZE, windowSize, 0);
  }
  void add_stride(int32_t stride) {
    fbb_.AddElement<int32_t>(AudioSpectrogram::VT_STRIDE, stride, 0);
  }
  void add_magSquare(bool magSquare) {
    fbb_.AddElement<uint8_t>(AudioSpectrogram::VT_MAGSQUARE, static_cast<uint8_t>(magSquare), 0);
  }
  explicit AudioSpectrogramBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AudioSpectrogramBuilder &operator=(const AudioSpectrogramBuilder &);
  flatbuffers::Offset<AudioSpectrogram> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<AudioSpectrogram>(end);
    return o;
  }
};

inline flatbuffers::Offset<AudioSpectrogram> CreateAudioSpectrogram(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t windowSize = 0,
    int32_t stride = 0,
    bool magSquare = false) {
  AudioSpectrogramBuilder builder_(_fbb);
  builder_.add_stride(stride);
  builder_.add_windowSize(windowSize);
  builder_.add_magSquare(magSquare);
  return builder_.Finish();
}

struct Mfcc FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FREQUPPERLIMIT = 4,
    VT_FREQLOWERLIMIT = 6,
    VT_FILTERBANKCHANNELNUM = 8,
    VT_DCTCOEFFNUM = 10
  };
  float freqUpperLimit() const {
    return GetField<float>(VT_FREQUPPERLIMIT, 0.0f);
  }
  float freqLowerLimit() const {
    return GetField<float>(VT_FREQLOWERLIMIT, 0.0f);
  }
  int32_t filterBankChannelNum() const {
    return GetField<int32_t>(VT_FILTERBANKCHANNELNUM, 0);
  }
  int32_t dctCoeffNum() const {
    return GetField<int32_t>(VT_DCTCOEFFNUM, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FREQUPPERLIMIT) &&
           VerifyField<float>(verifier, VT_FREQLOWERLIMIT) &&
           VerifyField<int32_t>(verifier, VT_FILTERBANKCHANNELNUM) &&
           VerifyField<int32_t>(verifier, VT_DCTCOEFFNUM) &&
           verifier.EndTable();
  }
};

struct MfccBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_freqUpperLimit(float freqUpperLimit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQUPPERLIMIT, freqUpperLimit, 0.0f);
  }
  void add_freqLowerLimit(float freqLowerLimit) {
    fbb_.AddElement<float>(Mfcc::VT_FREQLOWERLIMIT, freqLowerLimit, 0.0f);
  }
  void add_filterBankChannelNum(int32_t filterBankChannelNum) {
    fbb_.AddElement<int32_t>(Mfcc::VT_FILTERBANKCHANNELNUM, filterBankChannelNum, 0);
  }
  void add_dctCoeffNum(int32_t dctCoeffNum) {
    fbb_.AddElement<int32_t>(Mfcc::VT_DCTCOEFFNUM, dctCoeffNum, 0);
  }
  explicit MfccBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MfccBuilder &operator=(const MfccBuilder &);
  flatbuffers::Offset<Mfcc> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Mfcc>(end);
    return o;
  }
};

inline flatbuffers::Offset<Mfcc> CreateMfcc(
    flatbuffers::FlatBufferBuilder &_fbb,
    float freqUpperLimit = 0.0f,
    float freqLowerLimit = 0.0f,
    int32_t filterBankChannelNum = 0,
    int32_t dctCoeffNum = 0) {
  MfccBuilder builder_(_fbb);
  builder_.add_dctCoeffNum(dctCoeffNum);
  builder_.add_filterBankChannelNum(filterBankChannelNum);
  builder_.add_freqLowerLimit(freqLowerLimit);
  builder_.add_freqUpperLimit(freqUpperLimit);
  return builder_.Finish();
}

struct Rfft FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_FFTLENGTH = 4
  };
  int32_t fftLength() const {
    return GetField<int32_t>(VT_FFTLENGTH, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_FFTLENGTH) &&
           verifier.EndTable();
  }
};

struct RfftBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_fftLength(int32_t fftLength) {
    fbb_.AddElement<int32_t>(Rfft::VT_FFTLENGTH, fftLength, 0);
  }
  explicit RfftBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  RfftBuilder &operator=(const RfftBuilder &);
  flatbuffers::Offset<Rfft> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Rfft>(end);
    return o;
  }
};

inline flatbuffers::Offset<Rfft> CreateRfft(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t fftLength = 0) {
  RfftBuilder builder_(_fbb);
  builder_.add_fftLength(fftLength);
  return builder_.Finish();
}

struct FftReal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FftRealBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftRealBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FftRealBuilder &operator=(const FftRealBuilder &);
  flatbuffers::Offset<FftReal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftReal>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftReal> CreateFftReal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftRealBuilder builder_(_fbb);
  return builder_.Finish();
}

struct FftImag FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct FftImagBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit FftImagBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  FftImagBuilder &operator=(const FftImagBuilder &);
  flatbuffers::Offset<FftImag> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<FftImag>(end);
    return o;
  }
};

inline flatbuffers::Offset<FftImag> CreateFftImag(
    flatbuffers::FlatBufferBuilder &_fbb) {
  FftImagBuilder builder_(_fbb);
  return builder_.Finish();
}

struct DropoutGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RATIO = 4
  };
  float ratio() const {
    return GetField<float>(VT_RATIO, 0.5f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_RATIO) &&
           verifier.EndTable();
  }
};

struct DropoutGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_ratio(float ratio) {
    fbb_.AddElement<float>(DropoutGrad::VT_RATIO, ratio, 0.5f);
  }
  explicit DropoutGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  DropoutGradBuilder &operator=(const DropoutGradBuilder &);
  flatbuffers::Offset<DropoutGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<DropoutGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<DropoutGrad> CreateDropoutGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float ratio = 0.5f) {
  DropoutGradBuilder builder_(_fbb);
  builder_.add_ratio(ratio);
  return builder_.Finish();
}

struct MaximumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MaximumGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MaximumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MaximumGradBuilder &operator=(const MaximumGradBuilder &);
  flatbuffers::Offset<MaximumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MaximumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MaximumGrad> CreateMaximumGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MaximumGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct MinimumGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MinimumGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MinimumGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MinimumGradBuilder &operator=(const MinimumGradBuilder &);
  flatbuffers::Offset<MinimumGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MinimumGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<MinimumGrad> CreateMinimumGrad(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MinimumGradBuilder builder_(_fbb);
  return builder_.Finish();
}

struct NonMaxSuppression FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CENTERPOINTBOX = 4
  };
  int32_t centerPointBox() const {
    return GetField<int32_t>(VT_CENTERPOINTBOX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CENTERPOINTBOX) &&
           verifier.EndTable();
  }
};

struct NonMaxSuppressionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_centerPointBox(int32_t centerPointBox) {
    fbb_.AddElement<int32_t>(NonMaxSuppression::VT_CENTERPOINTBOX, centerPointBox, 0);
  }
  explicit NonMaxSuppressionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  NonMaxSuppressionBuilder &operator=(const NonMaxSuppressionBuilder &);
  flatbuffers::Offset<NonMaxSuppression> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<NonMaxSuppression>(end);
    return o;
  }
};

inline flatbuffers::Offset<NonMaxSuppression> CreateNonMaxSuppression(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t centerPointBox = 0) {
  NonMaxSuppressionBuilder builder_(_fbb);
  builder_.add_centerPointBox(centerPointBox);
  return builder_.Finish();
}

struct InstanceNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_EPSILON = 4
  };
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           verifier.EndTable();
  }
};

struct InstanceNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(InstanceNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  explicit InstanceNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  InstanceNormBuilder &operator=(const InstanceNormBuilder &);
  flatbuffers::Offset<InstanceNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InstanceNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<InstanceNorm> CreateInstanceNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    float epsilon = 0.00001f) {
  InstanceNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  return builder_.Finish();
}

struct Loop FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPHINDEX = 4
  };
  int32_t subGraphIndex() const {
    return GetField<int32_t>(VT_SUBGRAPHINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SUBGRAPHINDEX) &&
           verifier.EndTable();
  }
};

struct LoopBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subGraphIndex(int32_t subGraphIndex) {
    fbb_.AddElement<int32_t>(Loop::VT_SUBGRAPHINDEX, subGraphIndex, 0);
  }
  explicit LoopBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LoopBuilder &operator=(const LoopBuilder &);
  flatbuffers::Offset<Loop> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Loop>(end);
    return o;
  }
};

inline flatbuffers::Offset<Loop> CreateLoop(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t subGraphIndex = 0) {
  LoopBuilder builder_(_fbb);
  builder_.add_subGraphIndex(subGraphIndex);
  return builder_.Finish();
}

struct Identity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct IdentityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit IdentityBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  IdentityBuilder &operator=(const IdentityBuilder &);
  flatbuffers::Offset<Identity> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Identity>(end);
    return o;
  }
};

inline flatbuffers::Offset<Identity> CreateIdentity(
    flatbuffers::FlatBufferBuilder &_fbb) {
  IdentityBuilder builder_(_fbb);
  return builder_.Finish();
}

struct LayerNorm FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NORMALIZEDSHAPE = 4,
    VT_EPSILON = 6,
    VT_ELEMENTWISEAFFINE = 8
  };
  const flatbuffers::Vector<int32_t> *normalizedShape() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_NORMALIZEDSHAPE);
  }
  float epsilon() const {
    return GetField<float>(VT_EPSILON, 0.00001f);
  }
  bool elementwiseAffine() const {
    return GetField<uint8_t>(VT_ELEMENTWISEAFFINE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NORMALIZEDSHAPE) &&
           verifier.VerifyVector(normalizedShape()) &&
           VerifyField<float>(verifier, VT_EPSILON) &&
           VerifyField<uint8_t>(verifier, VT_ELEMENTWISEAFFINE) &&
           verifier.EndTable();
  }
};

struct LayerNormBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_normalizedShape(flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalizedShape) {
    fbb_.AddOffset(LayerNorm::VT_NORMALIZEDSHAPE, normalizedShape);
  }
  void add_epsilon(float epsilon) {
    fbb_.AddElement<float>(LayerNorm::VT_EPSILON, epsilon, 0.00001f);
  }
  void add_elementwiseAffine(bool elementwiseAffine) {
    fbb_.AddElement<uint8_t>(LayerNorm::VT_ELEMENTWISEAFFINE, static_cast<uint8_t>(elementwiseAffine), 0);
  }
  explicit LayerNormBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LayerNormBuilder &operator=(const LayerNormBuilder &);
  flatbuffers::Offset<LayerNorm> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LayerNorm>(end);
    return o;
  }
};

inline flatbuffers::Offset<LayerNorm> CreateLayerNorm(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> normalizedShape = 0,
    float epsilon = 0.00001f,
    bool elementwiseAffine = false) {
  LayerNormBuilder builder_(_fbb);
  builder_.add_epsilon(epsilon);
  builder_.add_normalizedShape(normalizedShape);
  builder_.add_elementwiseAffine(elementwiseAffine);
  return builder_.Finish();
}

inline flatbuffers::Offset<LayerNorm> CreateLayerNormDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<int32_t> *normalizedShape = nullptr,
    float epsilon = 0.00001f,
    bool elementwiseAffine = false) {
  auto normalizedShape__ = normalizedShape ? _fbb.CreateVector<int32_t>(*normalizedShape) : 0;
  return mindspore::schema::CreateLayerNorm(
      _fbb,
      normalizedShape__,
      epsilon,
      elementwiseAffine);
}

struct While FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_CONDSUBGRAPHINDEX = 4,
    VT_BODYSUBGRAPHINDEX = 6
  };
  int32_t condSubgraphIndex() const {
    return GetField<int32_t>(VT_CONDSUBGRAPHINDEX, 0);
  }
  int32_t bodySubgraphIndex() const {
    return GetField<int32_t>(VT_BODYSUBGRAPHINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_CONDSUBGRAPHINDEX) &&
           VerifyField<int32_t>(verifier, VT_BODYSUBGRAPHINDEX) &&
           verifier.EndTable();
  }
};

struct WhileBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_condSubgraphIndex(int32_t condSubgraphIndex) {
    fbb_.AddElement<int32_t>(While::VT_CONDSUBGRAPHINDEX, condSubgraphIndex, 0);
  }
  void add_bodySubgraphIndex(int32_t bodySubgraphIndex) {
    fbb_.AddElement<int32_t>(While::VT_BODYSUBGRAPHINDEX, bodySubgraphIndex, 0);
  }
  explicit WhileBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  WhileBuilder &operator=(const WhileBuilder &);
  flatbuffers::Offset<While> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<While>(end);
    return o;
  }
};

inline flatbuffers::Offset<While> CreateWhile(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t condSubgraphIndex = 0,
    int32_t bodySubgraphIndex = 0) {
  WhileBuilder builder_(_fbb);
  builder_.add_bodySubgraphIndex(bodySubgraphIndex);
  builder_.add_condSubgraphIndex(condSubgraphIndex);
  return builder_.Finish();
}

struct UnsortedSegmentSum FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMSEGMENTS = 4
  };
  int32_t numSegments() const {
    return GetField<int32_t>(VT_NUMSEGMENTS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMSEGMENTS) &&
           verifier.EndTable();
  }
};

struct UnsortedSegmentSumBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numSegments(int32_t numSegments) {
    fbb_.AddElement<int32_t>(UnsortedSegmentSum::VT_NUMSEGMENTS, numSegments, 0);
  }
  explicit UnsortedSegmentSumBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  UnsortedSegmentSumBuilder &operator=(const UnsortedSegmentSumBuilder &);
  flatbuffers::Offset<UnsortedSegmentSum> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<UnsortedSegmentSum>(end);
    return o;
  }
};

inline flatbuffers::Offset<UnsortedSegmentSum> CreateUnsortedSegmentSum(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numSegments = 0) {
  UnsortedSegmentSumBuilder builder_(_fbb);
  builder_.add_numSegments(numSegments);
  return builder_.Finish();
}

struct OnesLike FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct OnesLikeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit OnesLikeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  OnesLikeBuilder &operator=(const OnesLikeBuilder &);
  flatbuffers::Offset<OnesLike> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<OnesLike>(end);
    return o;
  }
};

inline flatbuffers::Offset<OnesLike> CreateOnesLike(
    flatbuffers::FlatBufferBuilder &_fbb) {
  OnesLikeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct BinaryCrossEntropy FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  int32_t reduction() const {
    return GetField<int32_t>(VT_REDUCTION, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
};

struct BinaryCrossEntropyBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(int32_t reduction) {
    fbb_.AddElement<int32_t>(BinaryCrossEntropy::VT_REDUCTION, reduction, 1);
  }
  explicit BinaryCrossEntropyBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryCrossEntropyBuilder &operator=(const BinaryCrossEntropyBuilder &);
  flatbuffers::Offset<BinaryCrossEntropy> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropy>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropy> CreateBinaryCrossEntropy(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reduction = 1) {
  BinaryCrossEntropyBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

struct BinaryCrossEntropyGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_REDUCTION = 4
  };
  int32_t reduction() const {
    return GetField<int32_t>(VT_REDUCTION, 1);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_REDUCTION) &&
           verifier.EndTable();
  }
};

struct BinaryCrossEntropyGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_reduction(int32_t reduction) {
    fbb_.AddElement<int32_t>(BinaryCrossEntropyGrad::VT_REDUCTION, reduction, 1);
  }
  explicit BinaryCrossEntropyGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BinaryCrossEntropyGradBuilder &operator=(const BinaryCrossEntropyGradBuilder &);
  flatbuffers::Offset<BinaryCrossEntropyGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BinaryCrossEntropyGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<BinaryCrossEntropyGrad> CreateBinaryCrossEntropyGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t reduction = 1) {
  BinaryCrossEntropyGradBuilder builder_(_fbb);
  builder_.add_reduction(reduction);
  return builder_.Finish();
}

struct LpNormalization FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_AXIS = 4,
    VT_P = 6
  };
  int32_t axis() const {
    return GetField<int32_t>(VT_AXIS, 0);
  }
  int32_t p() const {
    return GetField<int32_t>(VT_P, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_AXIS) &&
           VerifyField<int32_t>(verifier, VT_P) &&
           verifier.EndTable();
  }
};

struct LpNormalizationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_axis(int32_t axis) {
    fbb_.AddElement<int32_t>(LpNormalization::VT_AXIS, axis, 0);
  }
  void add_p(int32_t p) {
    fbb_.AddElement<int32_t>(LpNormalization::VT_P, p, 0);
  }
  explicit LpNormalizationBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  LpNormalizationBuilder &operator=(const LpNormalizationBuilder &);
  flatbuffers::Offset<LpNormalization> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<LpNormalization>(end);
    return o;
  }
};

inline flatbuffers::Offset<LpNormalization> CreateLpNormalization(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t axis = 0,
    int32_t p = 0) {
  LpNormalizationBuilder builder_(_fbb);
  builder_.add_p(p);
  builder_.add_axis(axis);
  return builder_.Finish();
}

struct Switch FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SwitchBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SwitchBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SwitchBuilder &operator=(const SwitchBuilder &);
  flatbuffers::Offset<Switch> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Switch>(end);
    return o;
  }
};

inline flatbuffers::Offset<Switch> CreateSwitch(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SwitchBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Partial FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUBGRAPHINDEX = 4
  };
  int32_t subGraphIndex() const {
    return GetField<int32_t>(VT_SUBGRAPHINDEX, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SUBGRAPHINDEX) &&
           verifier.EndTable();
  }
};

struct PartialBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_subGraphIndex(int32_t subGraphIndex) {
    fbb_.AddElement<int32_t>(Partial::VT_SUBGRAPHINDEX, subGraphIndex, 0);
  }
  explicit PartialBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PartialBuilder &operator=(const PartialBuilder &);
  flatbuffers::Offset<Partial> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Partial>(end);
    return o;
  }
};

inline flatbuffers::Offset<Partial> CreatePartial(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t subGraphIndex = 0) {
  PartialBuilder builder_(_fbb);
  builder_.add_subGraphIndex(subGraphIndex);
  return builder_.Finish();
}

struct TensorListFromTensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4,
    VT_SHAPETYPE = 6
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  int32_t shapeType() const {
    return GetField<int32_t>(VT_SHAPETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           VerifyField<int32_t>(verifier, VT_SHAPETYPE) &&
           verifier.EndTable();
  }
};

struct TensorListFromTensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListFromTensor::VT_ELEMENTDTYPE, elementDType, 0);
  }
  void add_shapeType(int32_t shapeType) {
    fbb_.AddElement<int32_t>(TensorListFromTensor::VT_SHAPETYPE, shapeType, 0);
  }
  explicit TensorListFromTensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorListFromTensorBuilder &operator=(const TensorListFromTensorBuilder &);
  flatbuffers::Offset<TensorListFromTensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListFromTensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListFromTensor> CreateTensorListFromTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0,
    int32_t shapeType = 0) {
  TensorListFromTensorBuilder builder_(_fbb);
  builder_.add_shapeType(shapeType);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

struct TensorListStack FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NUMELEMENTS = 4,
    VT_ELEMENTDTYPE = 6
  };
  int32_t numElements() const {
    return GetField<int32_t>(VT_NUMELEMENTS, 0);
  }
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NUMELEMENTS) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           verifier.EndTable();
  }
};

struct TensorListStackBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_numElements(int32_t numElements) {
    fbb_.AddElement<int32_t>(TensorListStack::VT_NUMELEMENTS, numElements, 0);
  }
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListStack::VT_ELEMENTDTYPE, elementDType, 0);
  }
  explicit TensorListStackBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorListStackBuilder &operator=(const TensorListStackBuilder &);
  flatbuffers::Offset<TensorListStack> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListStack>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListStack> CreateTensorListStack(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t numElements = 0,
    int32_t elementDType = 0) {
  TensorListStackBuilder builder_(_fbb);
  builder_.add_elementDType(elementDType);
  builder_.add_numElements(numElements);
  return builder_.Finish();
}

struct TensorListGetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           verifier.EndTable();
  }
};

struct TensorListGetItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListGetItem::VT_ELEMENTDTYPE, elementDType, 0);
  }
  explicit TensorListGetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorListGetItemBuilder &operator=(const TensorListGetItemBuilder &);
  flatbuffers::Offset<TensorListGetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListGetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListGetItem> CreateTensorListGetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0) {
  TensorListGetItemBuilder builder_(_fbb);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

struct TensorListSetItem FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           verifier.EndTable();
  }
};

struct TensorListSetItemBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListSetItem::VT_ELEMENTDTYPE, elementDType, 0);
  }
  explicit TensorListSetItemBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorListSetItemBuilder &operator=(const TensorListSetItemBuilder &);
  flatbuffers::Offset<TensorListSetItem> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListSetItem>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListSetItem> CreateTensorListSetItem(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0) {
  TensorListSetItemBuilder builder_(_fbb);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

struct TensorListReserve FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ELEMENTDTYPE = 4,
    VT_SHAPETYPE = 6
  };
  int32_t elementDType() const {
    return GetField<int32_t>(VT_ELEMENTDTYPE, 0);
  }
  int32_t shapeType() const {
    return GetField<int32_t>(VT_SHAPETYPE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_ELEMENTDTYPE) &&
           VerifyField<int32_t>(verifier, VT_SHAPETYPE) &&
           verifier.EndTable();
  }
};

struct TensorListReserveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_elementDType(int32_t elementDType) {
    fbb_.AddElement<int32_t>(TensorListReserve::VT_ELEMENTDTYPE, elementDType, 0);
  }
  void add_shapeType(int32_t shapeType) {
    fbb_.AddElement<int32_t>(TensorListReserve::VT_SHAPETYPE, shapeType, 0);
  }
  explicit TensorListReserveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorListReserveBuilder &operator=(const TensorListReserveBuilder &);
  flatbuffers::Offset<TensorListReserve> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<TensorListReserve>(end);
    return o;
  }
};

inline flatbuffers::Offset<TensorListReserve> CreateTensorListReserve(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t elementDType = 0,
    int32_t shapeType = 0) {
  TensorListReserveBuilder builder_(_fbb);
  builder_.add_shapeType(shapeType);
  builder_.add_elementDType(elementDType);
  return builder_.Finish();
}

struct All FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_KEEPDIMS = 4
  };
  int32_t keepDims() const {
    return GetField<int32_t>(VT_KEEPDIMS, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_KEEPDIMS) &&
           verifier.EndTable();
  }
};

struct AllBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_keepDims(int32_t keepDims) {
    fbb_.AddElement<int32_t>(All::VT_KEEPDIMS, keepDims, 0);
  }
  explicit AllBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AllBuilder &operator=(const AllBuilder &);
  flatbuffers::Offset<All> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<All>(end);
    return o;
  }
};

inline flatbuffers::Offset<All> CreateAll(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t keepDims = 0) {
  AllBuilder builder_(_fbb);
  builder_.add_keepDims(keepDims);
  return builder_.Finish();
}

struct Assert FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SUMMARIZE = 4
  };
  int32_t summarize() const {
    return GetField<int32_t>(VT_SUMMARIZE, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_SUMMARIZE) &&
           verifier.EndTable();
  }
};

struct AssertBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_summarize(int32_t summarize) {
    fbb_.AddElement<int32_t>(Assert::VT_SUMMARIZE, summarize, 0);
  }
  explicit AssertBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  AssertBuilder &operator=(const AssertBuilder &);
  flatbuffers::Offset<Assert> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Assert>(end);
    return o;
  }
};

inline flatbuffers::Offset<Assert> CreateAssert(
    flatbuffers::FlatBufferBuilder &_fbb,
    int32_t summarize = 0) {
  AssertBuilder builder_(_fbb);
  builder_.add_summarize(summarize);
  return builder_.Finish();
}

struct SmoothL1Loss FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct SmoothL1LossBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1Loss::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SmoothL1LossBuilder &operator=(const SmoothL1LossBuilder &);
  flatbuffers::Offset<SmoothL1Loss> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1Loss>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1Loss> CreateSmoothL1Loss(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct SmoothL1LossGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct SmoothL1LossGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SmoothL1LossGrad::VT_BETA, beta, 0.0f);
  }
  explicit SmoothL1LossGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SmoothL1LossGradBuilder &operator=(const SmoothL1LossGradBuilder &);
  flatbuffers::Offset<SmoothL1LossGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SmoothL1LossGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SmoothL1LossGrad> CreateSmoothL1LossGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SmoothL1LossGradBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct SigmoidCrossEntropyWithLogits FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct SigmoidCrossEntropyWithLogitsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SigmoidCrossEntropyWithLogits::VT_BETA, beta, 0.0f);
  }
  explicit SigmoidCrossEntropyWithLogitsBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SigmoidCrossEntropyWithLogitsBuilder &operator=(const SigmoidCrossEntropyWithLogitsBuilder &);
  flatbuffers::Offset<SigmoidCrossEntropyWithLogits> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogits>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogits> CreateSigmoidCrossEntropyWithLogits(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SigmoidCrossEntropyWithLogitsBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct SigmoidCrossEntropyWithLogitsGrad FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BETA = 4
  };
  float beta() const {
    return GetField<float>(VT_BETA, 0.0f);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_BETA) &&
           verifier.EndTable();
  }
};

struct SigmoidCrossEntropyWithLogitsGradBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_beta(float beta) {
    fbb_.AddElement<float>(SigmoidCrossEntropyWithLogitsGrad::VT_BETA, beta, 0.0f);
  }
  explicit SigmoidCrossEntropyWithLogitsGradBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SigmoidCrossEntropyWithLogitsGradBuilder &operator=(const SigmoidCrossEntropyWithLogitsGradBuilder &);
  flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad>(end);
    return o;
  }
};

inline flatbuffers::Offset<SigmoidCrossEntropyWithLogitsGrad> CreateSigmoidCrossEntropyWithLogitsGrad(
    flatbuffers::FlatBufferBuilder &_fbb,
    float beta = 0.0f) {
  SigmoidCrossEntropyWithLogitsGradBuilder builder_(_fbb);
  builder_.add_beta(beta);
  return builder_.Finish();
}

struct Reciprocal FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct ReciprocalBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit ReciprocalBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  ReciprocalBuilder &operator=(const ReciprocalBuilder &);
  flatbuffers::Offset<Reciprocal> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Reciprocal>(end);
    return o;
  }
};

inline flatbuffers::Offset<Reciprocal> CreateReciprocal(
    flatbuffers::FlatBufferBuilder &_fbb) {
  ReciprocalBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Merge FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct MergeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit MergeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MergeBuilder &operator=(const MergeBuilder &);
  flatbuffers::Offset<Merge> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Merge>(end);
    return o;
  }
};

inline flatbuffers::Offset<Merge> CreateMerge(
    flatbuffers::FlatBufferBuilder &_fbb) {
  MergeBuilder builder_(_fbb);
  return builder_.Finish();
}

struct GeLU FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_APPROXIMATE = 4
  };
  bool approximate() const {
    return GetField<uint8_t>(VT_APPROXIMATE, 0) != 0;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_APPROXIMATE) &&
           verifier.EndTable();
  }
};

struct GeLUBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_approximate(bool approximate) {
    fbb_.AddElement<uint8_t>(GeLU::VT_APPROXIMATE, static_cast<uint8_t>(approximate), 0);
  }
  explicit GeLUBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  GeLUBuilder &operator=(const GeLUBuilder &);
  flatbuffers::Offset<GeLU> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<GeLU>(end);
    return o;
  }
};

inline flatbuffers::Offset<GeLU> CreateGeLU(
    flatbuffers::FlatBufferBuilder &_fbb,
    bool approximate = false) {
  GeLUBuilder builder_(_fbb);
  builder_.add_approximate(approximate);
  return builder_.Finish();
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_OPS_MINDSPORE_SCHEMA_H_
