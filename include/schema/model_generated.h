// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"

#include "ops_generated.h"

namespace mindspore {
namespace schema {

struct QuantParam;

struct Tensor;

struct Primitive;

struct CNode;

struct SubGraph;

struct MetaGraph;

enum NodeType {
  NodeType_ValueNode = 0,
  NodeType_Parameter = 1,
  NodeType_CNode = 2,
  NodeType_MIN = NodeType_ValueNode,
  NodeType_MAX = NodeType_CNode
};

inline const NodeType (&EnumValuesNodeType())[3] {
  static const NodeType values[] = {
    NodeType_ValueNode,
    NodeType_Parameter,
    NodeType_CNode
  };
  return values;
}

inline const char * const *EnumNamesNodeType() {
  static const char * const names[] = {
    "ValueNode",
    "Parameter",
    "CNode",
    nullptr
  };
  return names;
}

inline const char *EnumNameNodeType(NodeType e) {
  if (e < NodeType_ValueNode || e > NodeType_CNode) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesNodeType()[index];
}

enum PrimitiveType {
  PrimitiveType_NONE = 0,
  PrimitiveType_Concat = 1,
  PrimitiveType_SoftMax = 2,
  PrimitiveType_Activation = 3,
  PrimitiveType_Conv2D = 4,
  PrimitiveType_FusedBatchNorm = 5,
  PrimitiveType_BatchNorm = 6,
  PrimitiveType_BiasAdd = 7,
  PrimitiveType_Pooling = 8,
  PrimitiveType_ROIPooling = 9,
  PrimitiveType_DepthwiseConv2D = 10,
  PrimitiveType_DeDepthwiseConv2D = 11,
  PrimitiveType_Resize = 12,
  PrimitiveType_DetectionPostProcess = 13,
  PrimitiveType_FullConnection = 14,
  PrimitiveType_Mean = 15,
  PrimitiveType_DeConv2D = 16,
  PrimitiveType_Scale = 17,
  PrimitiveType_Reshape = 18,
  PrimitiveType_Eltwise = 19,
  PrimitiveType_NetOutput = 20,
  PrimitiveType_Add = 21,
  PrimitiveType_Sub = 22,
  PrimitiveType_MatMul = 23,
  PrimitiveType_StridedSlice = 24,
  PrimitiveType_Power = 25,
  PrimitiveType_Slice = 26,
  PrimitiveType_Stack = 27,
  PrimitiveType_Mul = 28,
  PrimitiveType_RealDiv = 29,
  PrimitiveType_Pad = 30,
  PrimitiveType_Maximum = 31,
  PrimitiveType_Minimum = 32,
  PrimitiveType_PReLU = 33,
  PrimitiveType_LeakyReLU = 34,
  PrimitiveType_ArgMax = 35,
  PrimitiveType_ArgMin = 36,
  PrimitiveType_Exp = 37,
  PrimitiveType_Crop = 38,
  PrimitiveType_Range = 39,
  PrimitiveType_Rsqrt = 40,
  PrimitiveType_ExpandDims = 41,
  PrimitiveType_Tile = 42,
  PrimitiveType_Cast = 43,
  PrimitiveType_Shape = 44,
  PrimitiveType_Nchw2Nhwc = 45,
  PrimitiveType_Nhwc2Nchw = 46,
  PrimitiveType_QuantDTypeCast = 47,
  PrimitiveType_Split = 48,
  PrimitiveType_Permute = 49,
  PrimitiveType_FakeQuantWithMinMaxVars = 50,
  PrimitiveType_Equal = 51,
  PrimitiveType_Less = 52,
  PrimitiveType_Greater = 53,
  PrimitiveType_NotEqual = 54,
  PrimitiveType_LessEqual = 55,
  PrimitiveType_GreaterEqual = 56,
  PrimitiveType_Min = 57,
  PrimitiveType_Floor = 58,
  PrimitiveType_Abs = 59,
  PrimitiveType_Neg = 60,
  PrimitiveType_Cos = 61,
  PrimitiveType_Sin = 62,
  PrimitiveType_Sqrt = 63,
  PrimitiveType_Square = 64,
  PrimitiveType_Constant = 65,
  PrimitiveType_Log = 66,
  PrimitiveType_Tan = 67,
  PrimitiveType_Atan = 68,
  PrimitiveType_Asin = 69,
  PrimitiveType_Clip = 70,
  PrimitiveType_Transpose = 71,
  PrimitiveType_Squeeze = 72,
  PrimitiveType_Unsqueeze = 73,
  PrimitiveType_Upsample = 74,
  PrimitiveType_Dropout = 75,
  PrimitiveType_Broadcast = 76,
  PrimitiveType_BroadcastTo = 77,
  PrimitiveType_Lrn = 78,
  PrimitiveType_ZerosLike = 79,
  PrimitiveType_TopK = 80,
  PrimitiveType_SpaceToDepth = 81,
  PrimitiveType_SpaceToBatch = 82,
  PrimitiveType_SparseToDense = 83,
  PrimitiveType_ReverseSequence = 84,
  PrimitiveType_Rank = 85,
  PrimitiveType_Gather = 86,
  PrimitiveType_GatherNd = 87,
  PrimitiveType_Fill = 88,
  PrimitiveType_Elu = 89,
  PrimitiveType_DepthToSpace = 90,
  PrimitiveType_BatchToSpace = 91,
  PrimitiveType_AddN = 92,
  PrimitiveType_Ceil = 93,
  PrimitiveType_EmbeddingLookup = 94,
  PrimitiveType_EmbeddingLookupSparse = 95,
  PrimitiveType_FloorDiv = 96,
  PrimitiveType_FloorMod = 97,
  PrimitiveType_L2Norm = 98,
  PrimitiveType_LocalResponseNormalization = 99,
  PrimitiveType_MatrixDiag = 100,
  PrimitiveType_Reduce = 101,
  PrimitiveType_Reverse = 102,
  PrimitiveType_Round = 103,
  PrimitiveType_Select = 104,
  PrimitiveType_Scatter = 105,
  PrimitiveType_ScatterND = 106,
  PrimitiveType_ConstantOfShape = 107,
  PrimitiveType_Unique = 108,
  PrimitiveType_Unstack = 109,
  PrimitiveType_LogicalAnd = 110,
  PrimitiveType_LogicalOr = 111,
  PrimitiveType_LogicalXor = 112,
  PrimitiveType_LogicalNot = 113,
  PrimitiveType_OnnxInt8Quantize = 114,
  PrimitiveType_OnnxInt8Dequantize = 115,
  PrimitiveType_FakeQuantWithMinMax = 116,
  PrimitiveType_FakeQuantWithMinMaxPerChannel = 117,
  PrimitiveType_BatchNormFold = 118,
  PrimitiveType_MulFold = 119,
  PrimitiveType_AddFold = 120,
  PrimitiveType_SquaredDifference = 121,
  PrimitiveType_Flatten = 122,
  PrimitiveType_FlattenGrad = 123,
  PrimitiveType_TupleGetItem = 124,
  PrimitiveType_Div = 125,
  PrimitiveType_Where = 126,
  PrimitiveType_OneHot = 127,
  PrimitiveType_Lstm = 128,
  PrimitiveType_Conv2DGradFilter = 129,
  PrimitiveType_Conv2DGradInput = 130,
  PrimitiveType_PoolingGrad = 131,
  PrimitiveType_BNGrad = 132,
  PrimitiveType_Assign = 133,
  PrimitiveType_ApplyMomentum = 134,
  PrimitiveType_BiasGrad = 135,
  PrimitiveType_SoftmaxCrossEntropy = 136,
  PrimitiveType_AddGrad = 137,
  PrimitiveType_SubGrad = 138,
  PrimitiveType_MulGrad = 139,
  PrimitiveType_DivGrad = 140,
  PrimitiveType_PowerGrad = 141,
  PrimitiveType_ActivationGrad = 142,
  PrimitiveType_PriorBox = 143,
  PrimitiveType_SpaceToBatchND = 144,
  PrimitiveType_Depend = 145,
  PrimitiveType_Return = 146,
  PrimitiveType_MakeTuple = 147,
  PrimitiveType_ToFormat = 148,
  PrimitiveType_Proposal = 149,
  PrimitiveType_Custom = 150,
  PrimitiveType_BlackBox = 151,
  PrimitiveType_NegGrad = 152,
  PrimitiveType_LogGrad = 153,
  PrimitiveType_BatchToSpaceND = 154,
  PrimitiveType_LshProjection = 155,
  PrimitiveType_HashtableLookup = 156,
  PrimitiveType_SkipGram = 157,
  PrimitiveType_DeConv2DGradFilter = 158,
  PrimitiveType_CustomPredict = 159,
  PrimitiveType_CustomNormalize = 160,
  PrimitiveType_CustomExtractFeatures = 161,
  PrimitiveType_AudioSpectrogram = 162,
  PrimitiveType_Mfcc = 163,
  PrimitiveType_Rfft = 164,
  PrimitiveType_FftReal = 165,
  PrimitiveType_FftImag = 166,
  PrimitiveType_Sgd = 167,
  PrimitiveType_Adam = 168,
  PrimitiveType_GroupConv2DGradInput = 169,
  PrimitiveType_Loop = 170,
  PrimitiveType_NonMaxSuppression = 171,
  PrimitiveType_InstanceNorm = 172,
  PrimitiveType_Identity = 173,
  PrimitiveType_LayerNorm = 174,
  PrimitiveType_While = 175,
  PrimitiveType_ControlDepend = 176,
  PrimitiveType_UnsortedSegmentSum = 177,
  PrimitiveType_AssignAdd = 178,
  PrimitiveType_OnesLike = 179,
  PrimitiveType_BinaryCrossEntropyGrad = 180,
  PrimitiveType_BinaryCrossEntropy = 181,
  PrimitiveType_LpNormalization = 182,
  PrimitiveType_DropoutGrad = 183,
  PrimitiveType_MaximumGrad = 184,
  PrimitiveType_MinimumGrad = 185,
  PrimitiveType_Switch = 186,
  PrimitiveType_Partial = 187,
  PrimitiveType_TensorListFromTensor = 188,
  PrimitiveType_TensorListStack = 189,
  PrimitiveType_TensorListGetItem = 190,
  PrimitiveType_TensorListSetItem = 191,
  PrimitiveType_TensorListReserve = 192,
  PrimitiveType_All = 193,
  PrimitiveType_Assert = 194,
  PrimitiveType_Adder = 195,
  PrimitiveType_SparseSoftmaxCrossEntropy = 196,
  PrimitiveType_SmoothL1Loss = 197,
  PrimitiveType_SmoothL1LossGrad = 198,
  PrimitiveType_SigmoidCrossEntropyWithLogits = 199,
  PrimitiveType_SigmoidCrossEntropyWithLogitsGrad = 200,
  PrimitiveType_Reciprocal = 201,
  PrimitiveType_Merge = 202,
  PrimitiveType_Mod = 203,
  PrimitiveType_GeLU = 204,
  PrimitiveType_MIN = PrimitiveType_NONE,
  PrimitiveType_MAX = PrimitiveType_GeLU
};

inline const PrimitiveType (&EnumValuesPrimitiveType())[205] {
  static const PrimitiveType values[] = {
    PrimitiveType_NONE,
    PrimitiveType_Concat,
    PrimitiveType_SoftMax,
    PrimitiveType_Activation,
    PrimitiveType_Conv2D,
    PrimitiveType_FusedBatchNorm,
    PrimitiveType_BatchNorm,
    PrimitiveType_BiasAdd,
    PrimitiveType_Pooling,
    PrimitiveType_ROIPooling,
    PrimitiveType_DepthwiseConv2D,
    PrimitiveType_DeDepthwiseConv2D,
    PrimitiveType_Resize,
    PrimitiveType_DetectionPostProcess,
    PrimitiveType_FullConnection,
    PrimitiveType_Mean,
    PrimitiveType_DeConv2D,
    PrimitiveType_Scale,
    PrimitiveType_Reshape,
    PrimitiveType_Eltwise,
    PrimitiveType_NetOutput,
    PrimitiveType_Add,
    PrimitiveType_Sub,
    PrimitiveType_MatMul,
    PrimitiveType_StridedSlice,
    PrimitiveType_Power,
    PrimitiveType_Slice,
    PrimitiveType_Stack,
    PrimitiveType_Mul,
    PrimitiveType_RealDiv,
    PrimitiveType_Pad,
    PrimitiveType_Maximum,
    PrimitiveType_Minimum,
    PrimitiveType_PReLU,
    PrimitiveType_LeakyReLU,
    PrimitiveType_ArgMax,
    PrimitiveType_ArgMin,
    PrimitiveType_Exp,
    PrimitiveType_Crop,
    PrimitiveType_Range,
    PrimitiveType_Rsqrt,
    PrimitiveType_ExpandDims,
    PrimitiveType_Tile,
    PrimitiveType_Cast,
    PrimitiveType_Shape,
    PrimitiveType_Nchw2Nhwc,
    PrimitiveType_Nhwc2Nchw,
    PrimitiveType_QuantDTypeCast,
    PrimitiveType_Split,
    PrimitiveType_Permute,
    PrimitiveType_FakeQuantWithMinMaxVars,
    PrimitiveType_Equal,
    PrimitiveType_Less,
    PrimitiveType_Greater,
    PrimitiveType_NotEqual,
    PrimitiveType_LessEqual,
    PrimitiveType_GreaterEqual,
    PrimitiveType_Min,
    PrimitiveType_Floor,
    PrimitiveType_Abs,
    PrimitiveType_Neg,
    PrimitiveType_Cos,
    PrimitiveType_Sin,
    PrimitiveType_Sqrt,
    PrimitiveType_Square,
    PrimitiveType_Constant,
    PrimitiveType_Log,
    PrimitiveType_Tan,
    PrimitiveType_Atan,
    PrimitiveType_Asin,
    PrimitiveType_Clip,
    PrimitiveType_Transpose,
    PrimitiveType_Squeeze,
    PrimitiveType_Unsqueeze,
    PrimitiveType_Upsample,
    PrimitiveType_Dropout,
    PrimitiveType_Broadcast,
    PrimitiveType_BroadcastTo,
    PrimitiveType_Lrn,
    PrimitiveType_ZerosLike,
    PrimitiveType_TopK,
    PrimitiveType_SpaceToDepth,
    PrimitiveType_SpaceToBatch,
    PrimitiveType_SparseToDense,
    PrimitiveType_ReverseSequence,
    PrimitiveType_Rank,
    PrimitiveType_Gather,
    PrimitiveType_GatherNd,
    PrimitiveType_Fill,
    PrimitiveType_Elu,
    PrimitiveType_DepthToSpace,
    PrimitiveType_BatchToSpace,
    PrimitiveType_AddN,
    PrimitiveType_Ceil,
    PrimitiveType_EmbeddingLookup,
    PrimitiveType_EmbeddingLookupSparse,
    PrimitiveType_FloorDiv,
    PrimitiveType_FloorMod,
    PrimitiveType_L2Norm,
    PrimitiveType_LocalResponseNormalization,
    PrimitiveType_MatrixDiag,
    PrimitiveType_Reduce,
    PrimitiveType_Reverse,
    PrimitiveType_Round,
    PrimitiveType_Select,
    PrimitiveType_Scatter,
    PrimitiveType_ScatterND,
    PrimitiveType_ConstantOfShape,
    PrimitiveType_Unique,
    PrimitiveType_Unstack,
    PrimitiveType_LogicalAnd,
    PrimitiveType_LogicalOr,
    PrimitiveType_LogicalXor,
    PrimitiveType_LogicalNot,
    PrimitiveType_OnnxInt8Quantize,
    PrimitiveType_OnnxInt8Dequantize,
    PrimitiveType_FakeQuantWithMinMax,
    PrimitiveType_FakeQuantWithMinMaxPerChannel,
    PrimitiveType_BatchNormFold,
    PrimitiveType_MulFold,
    PrimitiveType_AddFold,
    PrimitiveType_SquaredDifference,
    PrimitiveType_Flatten,
    PrimitiveType_FlattenGrad,
    PrimitiveType_TupleGetItem,
    PrimitiveType_Div,
    PrimitiveType_Where,
    PrimitiveType_OneHot,
    PrimitiveType_Lstm,
    PrimitiveType_Conv2DGradFilter,
    PrimitiveType_Conv2DGradInput,
    PrimitiveType_PoolingGrad,
    PrimitiveType_BNGrad,
    PrimitiveType_Assign,
    PrimitiveType_ApplyMomentum,
    PrimitiveType_BiasGrad,
    PrimitiveType_SoftmaxCrossEntropy,
    PrimitiveType_AddGrad,
    PrimitiveType_SubGrad,
    PrimitiveType_MulGrad,
    PrimitiveType_DivGrad,
    PrimitiveType_PowerGrad,
    PrimitiveType_ActivationGrad,
    PrimitiveType_PriorBox,
    PrimitiveType_SpaceToBatchND,
    PrimitiveType_Depend,
    PrimitiveType_Return,
    PrimitiveType_MakeTuple,
    PrimitiveType_ToFormat,
    PrimitiveType_Proposal,
    PrimitiveType_Custom,
    PrimitiveType_BlackBox,
    PrimitiveType_NegGrad,
    PrimitiveType_LogGrad,
    PrimitiveType_BatchToSpaceND,
    PrimitiveType_LshProjection,
    PrimitiveType_HashtableLookup,
    PrimitiveType_SkipGram,
    PrimitiveType_DeConv2DGradFilter,
    PrimitiveType_CustomPredict,
    PrimitiveType_CustomNormalize,
    PrimitiveType_CustomExtractFeatures,
    PrimitiveType_AudioSpectrogram,
    PrimitiveType_Mfcc,
    PrimitiveType_Rfft,
    PrimitiveType_FftReal,
    PrimitiveType_FftImag,
    PrimitiveType_Sgd,
    PrimitiveType_Adam,
    PrimitiveType_GroupConv2DGradInput,
    PrimitiveType_Loop,
    PrimitiveType_NonMaxSuppression,
    PrimitiveType_InstanceNorm,
    PrimitiveType_Identity,
    PrimitiveType_LayerNorm,
    PrimitiveType_While,
    PrimitiveType_ControlDepend,
    PrimitiveType_UnsortedSegmentSum,
    PrimitiveType_AssignAdd,
    PrimitiveType_OnesLike,
    PrimitiveType_BinaryCrossEntropyGrad,
    PrimitiveType_BinaryCrossEntropy,
    PrimitiveType_LpNormalization,
    PrimitiveType_DropoutGrad,
    PrimitiveType_MaximumGrad,
    PrimitiveType_MinimumGrad,
    PrimitiveType_Switch,
    PrimitiveType_Partial,
    PrimitiveType_TensorListFromTensor,
    PrimitiveType_TensorListStack,
    PrimitiveType_TensorListGetItem,
    PrimitiveType_TensorListSetItem,
    PrimitiveType_TensorListReserve,
    PrimitiveType_All,
    PrimitiveType_Assert,
    PrimitiveType_Adder,
    PrimitiveType_SparseSoftmaxCrossEntropy,
    PrimitiveType_SmoothL1Loss,
    PrimitiveType_SmoothL1LossGrad,
    PrimitiveType_SigmoidCrossEntropyWithLogits,
    PrimitiveType_SigmoidCrossEntropyWithLogitsGrad,
    PrimitiveType_Reciprocal,
    PrimitiveType_Merge,
    PrimitiveType_Mod,
    PrimitiveType_GeLU
  };
  return values;
}

inline const char * const *EnumNamesPrimitiveType() {
  static const char * const names[] = {
    "NONE",
    "Concat",
    "SoftMax",
    "Activation",
    "Conv2D",
    "FusedBatchNorm",
    "BatchNorm",
    "BiasAdd",
    "Pooling",
    "ROIPooling",
    "DepthwiseConv2D",
    "DeDepthwiseConv2D",
    "Resize",
    "DetectionPostProcess",
    "FullConnection",
    "Mean",
    "DeConv2D",
    "Scale",
    "Reshape",
    "Eltwise",
    "NetOutput",
    "Add",
    "Sub",
    "MatMul",
    "StridedSlice",
    "Power",
    "Slice",
    "Stack",
    "Mul",
    "RealDiv",
    "Pad",
    "Maximum",
    "Minimum",
    "PReLU",
    "LeakyReLU",
    "ArgMax",
    "ArgMin",
    "Exp",
    "Crop",
    "Range",
    "Rsqrt",
    "ExpandDims",
    "Tile",
    "Cast",
    "Shape",
    "Nchw2Nhwc",
    "Nhwc2Nchw",
    "QuantDTypeCast",
    "Split",
    "Permute",
    "FakeQuantWithMinMaxVars",
    "Equal",
    "Less",
    "Greater",
    "NotEqual",
    "LessEqual",
    "GreaterEqual",
    "Min",
    "Floor",
    "Abs",
    "Neg",
    "Cos",
    "Sin",
    "Sqrt",
    "Square",
    "Constant",
    "Log",
    "Tan",
    "Atan",
    "Asin",
    "Clip",
    "Transpose",
    "Squeeze",
    "Unsqueeze",
    "Upsample",
    "Dropout",
    "Broadcast",
    "BroadcastTo",
    "Lrn",
    "ZerosLike",
    "TopK",
    "SpaceToDepth",
    "SpaceToBatch",
    "SparseToDense",
    "ReverseSequence",
    "Rank",
    "Gather",
    "GatherNd",
    "Fill",
    "Elu",
    "DepthToSpace",
    "BatchToSpace",
    "AddN",
    "Ceil",
    "EmbeddingLookup",
    "EmbeddingLookupSparse",
    "FloorDiv",
    "FloorMod",
    "L2Norm",
    "LocalResponseNormalization",
    "MatrixDiag",
    "Reduce",
    "Reverse",
    "Round",
    "Select",
    "Scatter",
    "ScatterND",
    "ConstantOfShape",
    "Unique",
    "Unstack",
    "LogicalAnd",
    "LogicalOr",
    "LogicalXor",
    "LogicalNot",
    "OnnxInt8Quantize",
    "OnnxInt8Dequantize",
    "FakeQuantWithMinMax",
    "FakeQuantWithMinMaxPerChannel",
    "BatchNormFold",
    "MulFold",
    "AddFold",
    "SquaredDifference",
    "Flatten",
    "FlattenGrad",
    "TupleGetItem",
    "Div",
    "Where",
    "OneHot",
    "Lstm",
    "Conv2DGradFilter",
    "Conv2DGradInput",
    "PoolingGrad",
    "BNGrad",
    "Assign",
    "ApplyMomentum",
    "BiasGrad",
    "SoftmaxCrossEntropy",
    "AddGrad",
    "SubGrad",
    "MulGrad",
    "DivGrad",
    "PowerGrad",
    "ActivationGrad",
    "PriorBox",
    "SpaceToBatchND",
    "Depend",
    "Return",
    "MakeTuple",
    "ToFormat",
    "Proposal",
    "Custom",
    "BlackBox",
    "NegGrad",
    "LogGrad",
    "BatchToSpaceND",
    "LshProjection",
    "HashtableLookup",
    "SkipGram",
    "DeConv2DGradFilter",
    "CustomPredict",
    "CustomNormalize",
    "CustomExtractFeatures",
    "AudioSpectrogram",
    "Mfcc",
    "Rfft",
    "FftReal",
    "FftImag",
    "Sgd",
    "Adam",
    "GroupConv2DGradInput",
    "Loop",
    "NonMaxSuppression",
    "InstanceNorm",
    "Identity",
    "LayerNorm",
    "While",
    "ControlDepend",
    "UnsortedSegmentSum",
    "AssignAdd",
    "OnesLike",
    "BinaryCrossEntropyGrad",
    "BinaryCrossEntropy",
    "LpNormalization",
    "DropoutGrad",
    "MaximumGrad",
    "MinimumGrad",
    "Switch",
    "Partial",
    "TensorListFromTensor",
    "TensorListStack",
    "TensorListGetItem",
    "TensorListSetItem",
    "TensorListReserve",
    "All",
    "Assert",
    "Adder",
    "SparseSoftmaxCrossEntropy",
    "SmoothL1Loss",
    "SmoothL1LossGrad",
    "SigmoidCrossEntropyWithLogits",
    "SigmoidCrossEntropyWithLogitsGrad",
    "Reciprocal",
    "Merge",
    "Mod",
    "GeLU",
    nullptr
  };
  return names;
}

inline const char *EnumNamePrimitiveType(PrimitiveType e) {
  if (e < PrimitiveType_NONE || e > PrimitiveType_GeLU) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPrimitiveType()[index];
}

template<typename T> struct PrimitiveTypeTraits {
  static const PrimitiveType enum_value = PrimitiveType_NONE;
};

template<> struct PrimitiveTypeTraits<Concat> {
  static const PrimitiveType enum_value = PrimitiveType_Concat;
};

template<> struct PrimitiveTypeTraits<SoftMax> {
  static const PrimitiveType enum_value = PrimitiveType_SoftMax;
};

template<> struct PrimitiveTypeTraits<Activation> {
  static const PrimitiveType enum_value = PrimitiveType_Activation;
};

template<> struct PrimitiveTypeTraits<Conv2D> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2D;
};

template<> struct PrimitiveTypeTraits<FusedBatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_FusedBatchNorm;
};

template<> struct PrimitiveTypeTraits<BatchNorm> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNorm;
};

template<> struct PrimitiveTypeTraits<BiasAdd> {
  static const PrimitiveType enum_value = PrimitiveType_BiasAdd;
};

template<> struct PrimitiveTypeTraits<Pooling> {
  static const PrimitiveType enum_value = PrimitiveType_Pooling;
};

template<> struct PrimitiveTypeTraits<ROIPooling> {
  static const PrimitiveType enum_value = PrimitiveType_ROIPooling;
};

template<> struct PrimitiveTypeTraits<DepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<DeDepthwiseConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeDepthwiseConv2D;
};

template<> struct PrimitiveTypeTraits<Resize> {
  static const PrimitiveType enum_value = PrimitiveType_Resize;
};

template<> struct PrimitiveTypeTraits<DetectionPostProcess> {
  static const PrimitiveType enum_value = PrimitiveType_DetectionPostProcess;
};

template<> struct PrimitiveTypeTraits<FullConnection> {
  static const PrimitiveType enum_value = PrimitiveType_FullConnection;
};

template<> struct PrimitiveTypeTraits<Mean> {
  static const PrimitiveType enum_value = PrimitiveType_Mean;
};

template<> struct PrimitiveTypeTraits<DeConv2D> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2D;
};

template<> struct PrimitiveTypeTraits<Scale> {
  static const PrimitiveType enum_value = PrimitiveType_Scale;
};

template<> struct PrimitiveTypeTraits<Reshape> {
  static const PrimitiveType enum_value = PrimitiveType_Reshape;
};

template<> struct PrimitiveTypeTraits<Eltwise> {
  static const PrimitiveType enum_value = PrimitiveType_Eltwise;
};

template<> struct PrimitiveTypeTraits<NetOutput> {
  static const PrimitiveType enum_value = PrimitiveType_NetOutput;
};

template<> struct PrimitiveTypeTraits<Add> {
  static const PrimitiveType enum_value = PrimitiveType_Add;
};

template<> struct PrimitiveTypeTraits<Sub> {
  static const PrimitiveType enum_value = PrimitiveType_Sub;
};

template<> struct PrimitiveTypeTraits<MatMul> {
  static const PrimitiveType enum_value = PrimitiveType_MatMul;
};

template<> struct PrimitiveTypeTraits<StridedSlice> {
  static const PrimitiveType enum_value = PrimitiveType_StridedSlice;
};

template<> struct PrimitiveTypeTraits<Power> {
  static const PrimitiveType enum_value = PrimitiveType_Power;
};

template<> struct PrimitiveTypeTraits<Slice> {
  static const PrimitiveType enum_value = PrimitiveType_Slice;
};

template<> struct PrimitiveTypeTraits<Stack> {
  static const PrimitiveType enum_value = PrimitiveType_Stack;
};

template<> struct PrimitiveTypeTraits<Mul> {
  static const PrimitiveType enum_value = PrimitiveType_Mul;
};

template<> struct PrimitiveTypeTraits<RealDiv> {
  static const PrimitiveType enum_value = PrimitiveType_RealDiv;
};

template<> struct PrimitiveTypeTraits<Pad> {
  static const PrimitiveType enum_value = PrimitiveType_Pad;
};

template<> struct PrimitiveTypeTraits<Maximum> {
  static const PrimitiveType enum_value = PrimitiveType_Maximum;
};

template<> struct PrimitiveTypeTraits<Minimum> {
  static const PrimitiveType enum_value = PrimitiveType_Minimum;
};

template<> struct PrimitiveTypeTraits<PReLU> {
  static const PrimitiveType enum_value = PrimitiveType_PReLU;
};

template<> struct PrimitiveTypeTraits<LeakyReLU> {
  static const PrimitiveType enum_value = PrimitiveType_LeakyReLU;
};

template<> struct PrimitiveTypeTraits<ArgMax> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMax;
};

template<> struct PrimitiveTypeTraits<ArgMin> {
  static const PrimitiveType enum_value = PrimitiveType_ArgMin;
};

template<> struct PrimitiveTypeTraits<Exp> {
  static const PrimitiveType enum_value = PrimitiveType_Exp;
};

template<> struct PrimitiveTypeTraits<Crop> {
  static const PrimitiveType enum_value = PrimitiveType_Crop;
};

template<> struct PrimitiveTypeTraits<Range> {
  static const PrimitiveType enum_value = PrimitiveType_Range;
};

template<> struct PrimitiveTypeTraits<Rsqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Rsqrt;
};

template<> struct PrimitiveTypeTraits<ExpandDims> {
  static const PrimitiveType enum_value = PrimitiveType_ExpandDims;
};

template<> struct PrimitiveTypeTraits<Tile> {
  static const PrimitiveType enum_value = PrimitiveType_Tile;
};

template<> struct PrimitiveTypeTraits<Cast> {
  static const PrimitiveType enum_value = PrimitiveType_Cast;
};

template<> struct PrimitiveTypeTraits<Shape> {
  static const PrimitiveType enum_value = PrimitiveType_Shape;
};

template<> struct PrimitiveTypeTraits<Nchw2Nhwc> {
  static const PrimitiveType enum_value = PrimitiveType_Nchw2Nhwc;
};

template<> struct PrimitiveTypeTraits<Nhwc2Nchw> {
  static const PrimitiveType enum_value = PrimitiveType_Nhwc2Nchw;
};

template<> struct PrimitiveTypeTraits<QuantDTypeCast> {
  static const PrimitiveType enum_value = PrimitiveType_QuantDTypeCast;
};

template<> struct PrimitiveTypeTraits<Split> {
  static const PrimitiveType enum_value = PrimitiveType_Split;
};

template<> struct PrimitiveTypeTraits<Permute> {
  static const PrimitiveType enum_value = PrimitiveType_Permute;
};

template<> struct PrimitiveTypeTraits<FakeQuantWithMinMaxVars> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxVars;
};

template<> struct PrimitiveTypeTraits<Equal> {
  static const PrimitiveType enum_value = PrimitiveType_Equal;
};

template<> struct PrimitiveTypeTraits<Less> {
  static const PrimitiveType enum_value = PrimitiveType_Less;
};

template<> struct PrimitiveTypeTraits<Greater> {
  static const PrimitiveType enum_value = PrimitiveType_Greater;
};

template<> struct PrimitiveTypeTraits<NotEqual> {
  static const PrimitiveType enum_value = PrimitiveType_NotEqual;
};

template<> struct PrimitiveTypeTraits<LessEqual> {
  static const PrimitiveType enum_value = PrimitiveType_LessEqual;
};

template<> struct PrimitiveTypeTraits<GreaterEqual> {
  static const PrimitiveType enum_value = PrimitiveType_GreaterEqual;
};

template<> struct PrimitiveTypeTraits<Min> {
  static const PrimitiveType enum_value = PrimitiveType_Min;
};

template<> struct PrimitiveTypeTraits<Floor> {
  static const PrimitiveType enum_value = PrimitiveType_Floor;
};

template<> struct PrimitiveTypeTraits<Abs> {
  static const PrimitiveType enum_value = PrimitiveType_Abs;
};

template<> struct PrimitiveTypeTraits<Neg> {
  static const PrimitiveType enum_value = PrimitiveType_Neg;
};

template<> struct PrimitiveTypeTraits<Cos> {
  static const PrimitiveType enum_value = PrimitiveType_Cos;
};

template<> struct PrimitiveTypeTraits<Sin> {
  static const PrimitiveType enum_value = PrimitiveType_Sin;
};

template<> struct PrimitiveTypeTraits<Sqrt> {
  static const PrimitiveType enum_value = PrimitiveType_Sqrt;
};

template<> struct PrimitiveTypeTraits<Square> {
  static const PrimitiveType enum_value = PrimitiveType_Square;
};

template<> struct PrimitiveTypeTraits<Constant> {
  static const PrimitiveType enum_value = PrimitiveType_Constant;
};

template<> struct PrimitiveTypeTraits<Log> {
  static const PrimitiveType enum_value = PrimitiveType_Log;
};

template<> struct PrimitiveTypeTraits<Tan> {
  static const PrimitiveType enum_value = PrimitiveType_Tan;
};

template<> struct PrimitiveTypeTraits<Atan> {
  static const PrimitiveType enum_value = PrimitiveType_Atan;
};

template<> struct PrimitiveTypeTraits<Asin> {
  static const PrimitiveType enum_value = PrimitiveType_Asin;
};

template<> struct PrimitiveTypeTraits<Clip> {
  static const PrimitiveType enum_value = PrimitiveType_Clip;
};

template<> struct PrimitiveTypeTraits<Transpose> {
  static const PrimitiveType enum_value = PrimitiveType_Transpose;
};

template<> struct PrimitiveTypeTraits<Squeeze> {
  static const PrimitiveType enum_value = PrimitiveType_Squeeze;
};

template<> struct PrimitiveTypeTraits<Unsqueeze> {
  static const PrimitiveType enum_value = PrimitiveType_Unsqueeze;
};

template<> struct PrimitiveTypeTraits<Upsample> {
  static const PrimitiveType enum_value = PrimitiveType_Upsample;
};

template<> struct PrimitiveTypeTraits<Dropout> {
  static const PrimitiveType enum_value = PrimitiveType_Dropout;
};

template<> struct PrimitiveTypeTraits<Broadcast> {
  static const PrimitiveType enum_value = PrimitiveType_Broadcast;
};

template<> struct PrimitiveTypeTraits<BroadcastTo> {
  static const PrimitiveType enum_value = PrimitiveType_BroadcastTo;
};

template<> struct PrimitiveTypeTraits<Lrn> {
  static const PrimitiveType enum_value = PrimitiveType_Lrn;
};

template<> struct PrimitiveTypeTraits<ZerosLike> {
  static const PrimitiveType enum_value = PrimitiveType_ZerosLike;
};

template<> struct PrimitiveTypeTraits<TopK> {
  static const PrimitiveType enum_value = PrimitiveType_TopK;
};

template<> struct PrimitiveTypeTraits<SpaceToDepth> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToDepth;
};

template<> struct PrimitiveTypeTraits<SpaceToBatch> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatch;
};

template<> struct PrimitiveTypeTraits<SparseToDense> {
  static const PrimitiveType enum_value = PrimitiveType_SparseToDense;
};

template<> struct PrimitiveTypeTraits<ReverseSequence> {
  static const PrimitiveType enum_value = PrimitiveType_ReverseSequence;
};

template<> struct PrimitiveTypeTraits<Rank> {
  static const PrimitiveType enum_value = PrimitiveType_Rank;
};

template<> struct PrimitiveTypeTraits<Gather> {
  static const PrimitiveType enum_value = PrimitiveType_Gather;
};

template<> struct PrimitiveTypeTraits<GatherNd> {
  static const PrimitiveType enum_value = PrimitiveType_GatherNd;
};

template<> struct PrimitiveTypeTraits<Fill> {
  static const PrimitiveType enum_value = PrimitiveType_Fill;
};

template<> struct PrimitiveTypeTraits<Elu> {
  static const PrimitiveType enum_value = PrimitiveType_Elu;
};

template<> struct PrimitiveTypeTraits<DepthToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_DepthToSpace;
};

template<> struct PrimitiveTypeTraits<BatchToSpace> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpace;
};

template<> struct PrimitiveTypeTraits<AddN> {
  static const PrimitiveType enum_value = PrimitiveType_AddN;
};

template<> struct PrimitiveTypeTraits<Ceil> {
  static const PrimitiveType enum_value = PrimitiveType_Ceil;
};

template<> struct PrimitiveTypeTraits<EmbeddingLookup> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookup;
};

template<> struct PrimitiveTypeTraits<EmbeddingLookupSparse> {
  static const PrimitiveType enum_value = PrimitiveType_EmbeddingLookupSparse;
};

template<> struct PrimitiveTypeTraits<FloorDiv> {
  static const PrimitiveType enum_value = PrimitiveType_FloorDiv;
};

template<> struct PrimitiveTypeTraits<FloorMod> {
  static const PrimitiveType enum_value = PrimitiveType_FloorMod;
};

template<> struct PrimitiveTypeTraits<L2Norm> {
  static const PrimitiveType enum_value = PrimitiveType_L2Norm;
};

template<> struct PrimitiveTypeTraits<LocalResponseNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LocalResponseNormalization;
};

template<> struct PrimitiveTypeTraits<MatrixDiag> {
  static const PrimitiveType enum_value = PrimitiveType_MatrixDiag;
};

template<> struct PrimitiveTypeTraits<Reduce> {
  static const PrimitiveType enum_value = PrimitiveType_Reduce;
};

template<> struct PrimitiveTypeTraits<Reverse> {
  static const PrimitiveType enum_value = PrimitiveType_Reverse;
};

template<> struct PrimitiveTypeTraits<Round> {
  static const PrimitiveType enum_value = PrimitiveType_Round;
};

template<> struct PrimitiveTypeTraits<Select> {
  static const PrimitiveType enum_value = PrimitiveType_Select;
};

template<> struct PrimitiveTypeTraits<Scatter> {
  static const PrimitiveType enum_value = PrimitiveType_Scatter;
};

template<> struct PrimitiveTypeTraits<ScatterND> {
  static const PrimitiveType enum_value = PrimitiveType_ScatterND;
};

template<> struct PrimitiveTypeTraits<ConstantOfShape> {
  static const PrimitiveType enum_value = PrimitiveType_ConstantOfShape;
};

template<> struct PrimitiveTypeTraits<Unique> {
  static const PrimitiveType enum_value = PrimitiveType_Unique;
};

template<> struct PrimitiveTypeTraits<Unstack> {
  static const PrimitiveType enum_value = PrimitiveType_Unstack;
};

template<> struct PrimitiveTypeTraits<LogicalAnd> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalAnd;
};

template<> struct PrimitiveTypeTraits<LogicalOr> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalOr;
};

template<> struct PrimitiveTypeTraits<LogicalXor> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalXor;
};

template<> struct PrimitiveTypeTraits<LogicalNot> {
  static const PrimitiveType enum_value = PrimitiveType_LogicalNot;
};

template<> struct PrimitiveTypeTraits<OnnxInt8Quantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Quantize;
};

template<> struct PrimitiveTypeTraits<OnnxInt8Dequantize> {
  static const PrimitiveType enum_value = PrimitiveType_OnnxInt8Dequantize;
};

template<> struct PrimitiveTypeTraits<FakeQuantWithMinMax> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMax;
};

template<> struct PrimitiveTypeTraits<FakeQuantWithMinMaxPerChannel> {
  static const PrimitiveType enum_value = PrimitiveType_FakeQuantWithMinMaxPerChannel;
};

template<> struct PrimitiveTypeTraits<BatchNormFold> {
  static const PrimitiveType enum_value = PrimitiveType_BatchNormFold;
};

template<> struct PrimitiveTypeTraits<MulFold> {
  static const PrimitiveType enum_value = PrimitiveType_MulFold;
};

template<> struct PrimitiveTypeTraits<AddFold> {
  static const PrimitiveType enum_value = PrimitiveType_AddFold;
};

template<> struct PrimitiveTypeTraits<SquaredDifference> {
  static const PrimitiveType enum_value = PrimitiveType_SquaredDifference;
};

template<> struct PrimitiveTypeTraits<Flatten> {
  static const PrimitiveType enum_value = PrimitiveType_Flatten;
};

template<> struct PrimitiveTypeTraits<FlattenGrad> {
  static const PrimitiveType enum_value = PrimitiveType_FlattenGrad;
};

template<> struct PrimitiveTypeTraits<TupleGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TupleGetItem;
};

template<> struct PrimitiveTypeTraits<Div> {
  static const PrimitiveType enum_value = PrimitiveType_Div;
};

template<> struct PrimitiveTypeTraits<Where> {
  static const PrimitiveType enum_value = PrimitiveType_Where;
};

template<> struct PrimitiveTypeTraits<OneHot> {
  static const PrimitiveType enum_value = PrimitiveType_OneHot;
};

template<> struct PrimitiveTypeTraits<Lstm> {
  static const PrimitiveType enum_value = PrimitiveType_Lstm;
};

template<> struct PrimitiveTypeTraits<Conv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<Conv2DGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_Conv2DGradInput;
};

template<> struct PrimitiveTypeTraits<PoolingGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PoolingGrad;
};

template<> struct PrimitiveTypeTraits<BNGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BNGrad;
};

template<> struct PrimitiveTypeTraits<Assign> {
  static const PrimitiveType enum_value = PrimitiveType_Assign;
};

template<> struct PrimitiveTypeTraits<ApplyMomentum> {
  static const PrimitiveType enum_value = PrimitiveType_ApplyMomentum;
};

template<> struct PrimitiveTypeTraits<BiasGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BiasGrad;
};

template<> struct PrimitiveTypeTraits<SoftmaxCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_SoftmaxCrossEntropy;
};

template<> struct PrimitiveTypeTraits<AddGrad> {
  static const PrimitiveType enum_value = PrimitiveType_AddGrad;
};

template<> struct PrimitiveTypeTraits<SubGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SubGrad;
};

template<> struct PrimitiveTypeTraits<MulGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MulGrad;
};

template<> struct PrimitiveTypeTraits<DivGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DivGrad;
};

template<> struct PrimitiveTypeTraits<PowerGrad> {
  static const PrimitiveType enum_value = PrimitiveType_PowerGrad;
};

template<> struct PrimitiveTypeTraits<ActivationGrad> {
  static const PrimitiveType enum_value = PrimitiveType_ActivationGrad;
};

template<> struct PrimitiveTypeTraits<PriorBox> {
  static const PrimitiveType enum_value = PrimitiveType_PriorBox;
};

template<> struct PrimitiveTypeTraits<SpaceToBatchND> {
  static const PrimitiveType enum_value = PrimitiveType_SpaceToBatchND;
};

template<> struct PrimitiveTypeTraits<Depend> {
  static const PrimitiveType enum_value = PrimitiveType_Depend;
};

template<> struct PrimitiveTypeTraits<Return> {
  static const PrimitiveType enum_value = PrimitiveType_Return;
};

template<> struct PrimitiveTypeTraits<MakeTuple> {
  static const PrimitiveType enum_value = PrimitiveType_MakeTuple;
};

template<> struct PrimitiveTypeTraits<ToFormat> {
  static const PrimitiveType enum_value = PrimitiveType_ToFormat;
};

template<> struct PrimitiveTypeTraits<Proposal> {
  static const PrimitiveType enum_value = PrimitiveType_Proposal;
};

template<> struct PrimitiveTypeTraits<Custom> {
  static const PrimitiveType enum_value = PrimitiveType_Custom;
};

template<> struct PrimitiveTypeTraits<BlackBox> {
  static const PrimitiveType enum_value = PrimitiveType_BlackBox;
};

template<> struct PrimitiveTypeTraits<NegGrad> {
  static const PrimitiveType enum_value = PrimitiveType_NegGrad;
};

template<> struct PrimitiveTypeTraits<LogGrad> {
  static const PrimitiveType enum_value = PrimitiveType_LogGrad;
};

template<> struct PrimitiveTypeTraits<BatchToSpaceND> {
  static const PrimitiveType enum_value = PrimitiveType_BatchToSpaceND;
};

template<> struct PrimitiveTypeTraits<LshProjection> {
  static const PrimitiveType enum_value = PrimitiveType_LshProjection;
};

template<> struct PrimitiveTypeTraits<HashtableLookup> {
  static const PrimitiveType enum_value = PrimitiveType_HashtableLookup;
};

template<> struct PrimitiveTypeTraits<SkipGram> {
  static const PrimitiveType enum_value = PrimitiveType_SkipGram;
};

template<> struct PrimitiveTypeTraits<DeConv2DGradFilter> {
  static const PrimitiveType enum_value = PrimitiveType_DeConv2DGradFilter;
};

template<> struct PrimitiveTypeTraits<CustomPredict> {
  static const PrimitiveType enum_value = PrimitiveType_CustomPredict;
};

template<> struct PrimitiveTypeTraits<CustomNormalize> {
  static const PrimitiveType enum_value = PrimitiveType_CustomNormalize;
};

template<> struct PrimitiveTypeTraits<CustomExtractFeatures> {
  static const PrimitiveType enum_value = PrimitiveType_CustomExtractFeatures;
};

template<> struct PrimitiveTypeTraits<AudioSpectrogram> {
  static const PrimitiveType enum_value = PrimitiveType_AudioSpectrogram;
};

template<> struct PrimitiveTypeTraits<Mfcc> {
  static const PrimitiveType enum_value = PrimitiveType_Mfcc;
};

template<> struct PrimitiveTypeTraits<Rfft> {
  static const PrimitiveType enum_value = PrimitiveType_Rfft;
};

template<> struct PrimitiveTypeTraits<FftReal> {
  static const PrimitiveType enum_value = PrimitiveType_FftReal;
};

template<> struct PrimitiveTypeTraits<FftImag> {
  static const PrimitiveType enum_value = PrimitiveType_FftImag;
};

template<> struct PrimitiveTypeTraits<Sgd> {
  static const PrimitiveType enum_value = PrimitiveType_Sgd;
};

template<> struct PrimitiveTypeTraits<Adam> {
  static const PrimitiveType enum_value = PrimitiveType_Adam;
};

template<> struct PrimitiveTypeTraits<GroupConv2DGradInput> {
  static const PrimitiveType enum_value = PrimitiveType_GroupConv2DGradInput;
};

template<> struct PrimitiveTypeTraits<Loop> {
  static const PrimitiveType enum_value = PrimitiveType_Loop;
};

template<> struct PrimitiveTypeTraits<NonMaxSuppression> {
  static const PrimitiveType enum_value = PrimitiveType_NonMaxSuppression;
};

template<> struct PrimitiveTypeTraits<InstanceNorm> {
  static const PrimitiveType enum_value = PrimitiveType_InstanceNorm;
};

template<> struct PrimitiveTypeTraits<Identity> {
  static const PrimitiveType enum_value = PrimitiveType_Identity;
};

template<> struct PrimitiveTypeTraits<LayerNorm> {
  static const PrimitiveType enum_value = PrimitiveType_LayerNorm;
};

template<> struct PrimitiveTypeTraits<While> {
  static const PrimitiveType enum_value = PrimitiveType_While;
};

template<> struct PrimitiveTypeTraits<ControlDepend> {
  static const PrimitiveType enum_value = PrimitiveType_ControlDepend;
};

template<> struct PrimitiveTypeTraits<UnsortedSegmentSum> {
  static const PrimitiveType enum_value = PrimitiveType_UnsortedSegmentSum;
};

template<> struct PrimitiveTypeTraits<AssignAdd> {
  static const PrimitiveType enum_value = PrimitiveType_AssignAdd;
};

template<> struct PrimitiveTypeTraits<OnesLike> {
  static const PrimitiveType enum_value = PrimitiveType_OnesLike;
};

template<> struct PrimitiveTypeTraits<BinaryCrossEntropyGrad> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropyGrad;
};

template<> struct PrimitiveTypeTraits<BinaryCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_BinaryCrossEntropy;
};

template<> struct PrimitiveTypeTraits<LpNormalization> {
  static const PrimitiveType enum_value = PrimitiveType_LpNormalization;
};

template<> struct PrimitiveTypeTraits<DropoutGrad> {
  static const PrimitiveType enum_value = PrimitiveType_DropoutGrad;
};

template<> struct PrimitiveTypeTraits<MaximumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MaximumGrad;
};

template<> struct PrimitiveTypeTraits<MinimumGrad> {
  static const PrimitiveType enum_value = PrimitiveType_MinimumGrad;
};

template<> struct PrimitiveTypeTraits<Switch> {
  static const PrimitiveType enum_value = PrimitiveType_Switch;
};

template<> struct PrimitiveTypeTraits<Partial> {
  static const PrimitiveType enum_value = PrimitiveType_Partial;
};

template<> struct PrimitiveTypeTraits<TensorListFromTensor> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListFromTensor;
};

template<> struct PrimitiveTypeTraits<TensorListStack> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListStack;
};

template<> struct PrimitiveTypeTraits<TensorListGetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListGetItem;
};

template<> struct PrimitiveTypeTraits<TensorListSetItem> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListSetItem;
};

template<> struct PrimitiveTypeTraits<TensorListReserve> {
  static const PrimitiveType enum_value = PrimitiveType_TensorListReserve;
};

template<> struct PrimitiveTypeTraits<All> {
  static const PrimitiveType enum_value = PrimitiveType_All;
};

template<> struct PrimitiveTypeTraits<Assert> {
  static const PrimitiveType enum_value = PrimitiveType_Assert;
};

template<> struct PrimitiveTypeTraits<Adder> {
  static const PrimitiveType enum_value = PrimitiveType_Adder;
};

template<> struct PrimitiveTypeTraits<SparseSoftmaxCrossEntropy> {
  static const PrimitiveType enum_value = PrimitiveType_SparseSoftmaxCrossEntropy;
};

template<> struct PrimitiveTypeTraits<SmoothL1Loss> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1Loss;
};

template<> struct PrimitiveTypeTraits<SmoothL1LossGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SmoothL1LossGrad;
};

template<> struct PrimitiveTypeTraits<SigmoidCrossEntropyWithLogits> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogits;
};

template<> struct PrimitiveTypeTraits<SigmoidCrossEntropyWithLogitsGrad> {
  static const PrimitiveType enum_value = PrimitiveType_SigmoidCrossEntropyWithLogitsGrad;
};

template<> struct PrimitiveTypeTraits<Reciprocal> {
  static const PrimitiveType enum_value = PrimitiveType_Reciprocal;
};

template<> struct PrimitiveTypeTraits<Merge> {
  static const PrimitiveType enum_value = PrimitiveType_Merge;
};

template<> struct PrimitiveTypeTraits<Mod> {
  static const PrimitiveType enum_value = PrimitiveType_Mod;
};

template<> struct PrimitiveTypeTraits<GeLU> {
  static const PrimitiveType enum_value = PrimitiveType_GeLU;
};

bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type);
bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

enum QuantType {
  QuantType_QUANT_NONE = 0,
  QuantType_AwareTraining = 1,
  QuantType_WeightQuant = 2,
  QuantType_PostTraining = 3,
  QuantType_MIN = QuantType_QUANT_NONE,
  QuantType_MAX = QuantType_PostTraining
};

inline const QuantType (&EnumValuesQuantType())[4] {
  static const QuantType values[] = {
    QuantType_QUANT_NONE,
    QuantType_AwareTraining,
    QuantType_WeightQuant,
    QuantType_PostTraining
  };
  return values;
}

inline const char * const *EnumNamesQuantType() {
  static const char * const names[] = {
    "QUANT_NONE",
    "AwareTraining",
    "WeightQuant",
    "PostTraining",
    nullptr
  };
  return names;
}

inline const char *EnumNameQuantType(QuantType e) {
  if (e < QuantType_QUANT_NONE || e > QuantType_PostTraining) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesQuantType()[index];
}

struct QuantParam FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SCALE = 4,
    VT_ZEROPOINT = 6,
    VT_MIN = 8,
    VT_MAX = 10,
    VT_NARROWRANGE = 12,
    VT_NUMBITS = 14,
    VT_INITED = 16,
    VT_VARCORR = 18,
    VT_MEANCORR = 20,
    VT_DSTDTYPE = 22
  };
  double scale() const {
    return GetField<double>(VT_SCALE, 0.0);
  }
  int32_t zeroPoint() const {
    return GetField<int32_t>(VT_ZEROPOINT, 0);
  }
  double min() const {
    return GetField<double>(VT_MIN, 0.0);
  }
  double max() const {
    return GetField<double>(VT_MAX, 0.0);
  }
  bool narrowRange() const {
    return GetField<uint8_t>(VT_NARROWRANGE, 1) != 0;
  }
  int32_t numBits() const {
    return GetField<int32_t>(VT_NUMBITS, 8);
  }
  bool inited() const {
    return GetField<uint8_t>(VT_INITED, 0) != 0;
  }
  float varCorr() const {
    return GetField<float>(VT_VARCORR, 1.0f);
  }
  float meanCorr() const {
    return GetField<float>(VT_MEANCORR, 0.0f);
  }
  int32_t dstDtype() const {
    return GetField<int32_t>(VT_DSTDTYPE, 32);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<double>(verifier, VT_SCALE) &&
           VerifyField<int32_t>(verifier, VT_ZEROPOINT) &&
           VerifyField<double>(verifier, VT_MIN) &&
           VerifyField<double>(verifier, VT_MAX) &&
           VerifyField<uint8_t>(verifier, VT_NARROWRANGE) &&
           VerifyField<int32_t>(verifier, VT_NUMBITS) &&
           VerifyField<uint8_t>(verifier, VT_INITED) &&
           VerifyField<float>(verifier, VT_VARCORR) &&
           VerifyField<float>(verifier, VT_MEANCORR) &&
           VerifyField<int32_t>(verifier, VT_DSTDTYPE) &&
           verifier.EndTable();
  }
};

struct QuantParamBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_scale(double scale) {
    fbb_.AddElement<double>(QuantParam::VT_SCALE, scale, 0.0);
  }
  void add_zeroPoint(int32_t zeroPoint) {
    fbb_.AddElement<int32_t>(QuantParam::VT_ZEROPOINT, zeroPoint, 0);
  }
  void add_min(double min) {
    fbb_.AddElement<double>(QuantParam::VT_MIN, min, 0.0);
  }
  void add_max(double max) {
    fbb_.AddElement<double>(QuantParam::VT_MAX, max, 0.0);
  }
  void add_narrowRange(bool narrowRange) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_NARROWRANGE, static_cast<uint8_t>(narrowRange), 1);
  }
  void add_numBits(int32_t numBits) {
    fbb_.AddElement<int32_t>(QuantParam::VT_NUMBITS, numBits, 8);
  }
  void add_inited(bool inited) {
    fbb_.AddElement<uint8_t>(QuantParam::VT_INITED, static_cast<uint8_t>(inited), 0);
  }
  void add_varCorr(float varCorr) {
    fbb_.AddElement<float>(QuantParam::VT_VARCORR, varCorr, 1.0f);
  }
  void add_meanCorr(float meanCorr) {
    fbb_.AddElement<float>(QuantParam::VT_MEANCORR, meanCorr, 0.0f);
  }
  void add_dstDtype(int32_t dstDtype) {
    fbb_.AddElement<int32_t>(QuantParam::VT_DSTDTYPE, dstDtype, 32);
  }
  explicit QuantParamBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  QuantParamBuilder &operator=(const QuantParamBuilder &);
  flatbuffers::Offset<QuantParam> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<QuantParam>(end);
    return o;
  }
};

inline flatbuffers::Offset<QuantParam> CreateQuantParam(
    flatbuffers::FlatBufferBuilder &_fbb,
    double scale = 0.0,
    int32_t zeroPoint = 0,
    double min = 0.0,
    double max = 0.0,
    bool narrowRange = true,
    int32_t numBits = 8,
    bool inited = false,
    float varCorr = 1.0f,
    float meanCorr = 0.0f,
    int32_t dstDtype = 32) {
  QuantParamBuilder builder_(_fbb);
  builder_.add_max(max);
  builder_.add_min(min);
  builder_.add_scale(scale);
  builder_.add_dstDtype(dstDtype);
  builder_.add_meanCorr(meanCorr);
  builder_.add_varCorr(varCorr);
  builder_.add_numBits(numBits);
  builder_.add_zeroPoint(zeroPoint);
  builder_.add_inited(inited);
  builder_.add_narrowRange(narrowRange);
  return builder_.Finish();
}

struct Tensor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NODETYPE = 4,
    VT_DATATYPE = 6,
    VT_DIMS = 8,
    VT_FORMAT = 10,
    VT_REFCOUNT = 12,
    VT_OFFSET = 14,
    VT_DATA = 16,
    VT_QUANTPARAMS = 18,
    VT_QUANTCLUSTERS = 20,
    VT_NAME = 22
  };
  NodeType nodeType() const {
    return static_cast<NodeType>(GetField<int32_t>(VT_NODETYPE, 0));
  }
  int32_t dataType() const {
    return GetField<int32_t>(VT_DATATYPE, 0);
  }
  const flatbuffers::Vector<int32_t> *dims() const {
    return GetPointer<const flatbuffers::Vector<int32_t> *>(VT_DIMS);
  }
  Format format() const {
    return static_cast<Format>(GetField<int32_t>(VT_FORMAT, 0));
  }
  int32_t refCount() const {
    return GetField<int32_t>(VT_REFCOUNT, 0);
  }
  int32_t offset() const {
    return GetField<int32_t>(VT_OFFSET, 0);
  }
  const flatbuffers::Vector<uint8_t> *data() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_DATA);
  }
  const flatbuffers::Vector<flatbuffers::Offset<QuantParam>> *quantParams() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<QuantParam>> *>(VT_QUANTPARAMS);
  }
  const flatbuffers::Vector<float> *quantClusters() const {
    return GetPointer<const flatbuffers::Vector<float> *>(VT_QUANTCLUSTERS);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyField<int32_t>(verifier, VT_DATATYPE) &&
           VerifyOffset(verifier, VT_DIMS) &&
           verifier.VerifyVector(dims()) &&
           VerifyField<int32_t>(verifier, VT_FORMAT) &&
           VerifyField<int32_t>(verifier, VT_REFCOUNT) &&
           VerifyField<int32_t>(verifier, VT_OFFSET) &&
           VerifyOffset(verifier, VT_DATA) &&
           verifier.VerifyVector(data()) &&
           VerifyOffset(verifier, VT_QUANTPARAMS) &&
           verifier.VerifyVector(quantParams()) &&
           verifier.VerifyVectorOfTables(quantParams()) &&
           VerifyOffset(verifier, VT_QUANTCLUSTERS) &&
           verifier.VerifyVector(quantClusters()) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           verifier.EndTable();
  }
};

struct TensorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeType(NodeType nodeType) {
    fbb_.AddElement<int32_t>(Tensor::VT_NODETYPE, static_cast<int32_t>(nodeType), 0);
  }
  void add_dataType(int32_t dataType) {
    fbb_.AddElement<int32_t>(Tensor::VT_DATATYPE, dataType, 0);
  }
  void add_dims(flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims) {
    fbb_.AddOffset(Tensor::VT_DIMS, dims);
  }
  void add_format(Format format) {
    fbb_.AddElement<int32_t>(Tensor::VT_FORMAT, static_cast<int32_t>(format), 0);
  }
  void add_refCount(int32_t refCount) {
    fbb_.AddElement<int32_t>(Tensor::VT_REFCOUNT, refCount, 0);
  }
  void add_offset(int32_t offset) {
    fbb_.AddElement<int32_t>(Tensor::VT_OFFSET, offset, 0);
  }
  void add_data(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data) {
    fbb_.AddOffset(Tensor::VT_DATA, data);
  }
  void add_quantParams(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuantParam>>> quantParams) {
    fbb_.AddOffset(Tensor::VT_QUANTPARAMS, quantParams);
  }
  void add_quantClusters(flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters) {
    fbb_.AddOffset(Tensor::VT_QUANTCLUSTERS, quantClusters);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Tensor::VT_NAME, name);
  }
  explicit TensorBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  TensorBuilder &operator=(const TensorBuilder &);
  flatbuffers::Offset<Tensor> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Tensor>(end);
    return o;
  }
};

inline flatbuffers::Offset<Tensor> CreateTensor(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeType nodeType = NodeType_ValueNode,
    int32_t dataType = 0,
    flatbuffers::Offset<flatbuffers::Vector<int32_t>> dims = 0,
    Format format = Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> data = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<QuantParam>>> quantParams = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> quantClusters = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0) {
  TensorBuilder builder_(_fbb);
  builder_.add_name(name);
  builder_.add_quantClusters(quantClusters);
  builder_.add_quantParams(quantParams);
  builder_.add_data(data);
  builder_.add_offset(offset);
  builder_.add_refCount(refCount);
  builder_.add_format(format);
  builder_.add_dims(dims);
  builder_.add_dataType(dataType);
  builder_.add_nodeType(nodeType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Tensor> CreateTensorDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    NodeType nodeType = NodeType_ValueNode,
    int32_t dataType = 0,
    const std::vector<int32_t> *dims = nullptr,
    Format format = Format_NCHW,
    int32_t refCount = 0,
    int32_t offset = 0,
    const std::vector<uint8_t> *data = nullptr,
    const std::vector<flatbuffers::Offset<QuantParam>> *quantParams = nullptr,
    const std::vector<float> *quantClusters = nullptr,
    const char *name = nullptr) {
  auto dims__ = dims ? _fbb.CreateVector<int32_t>(*dims) : 0;
  auto data__ = data ? _fbb.CreateVector<uint8_t>(*data) : 0;
  auto quantParams__ = quantParams ? _fbb.CreateVector<flatbuffers::Offset<QuantParam>>(*quantParams) : 0;
  auto quantClusters__ = quantClusters ? _fbb.CreateVector<float>(*quantClusters) : 0;
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return mindspore::schema::CreateTensor(
      _fbb,
      nodeType,
      dataType,
      dims__,
      format,
      refCount,
      offset,
      data__,
      quantParams__,
      quantClusters__,
      name__);
}

struct Primitive FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE_TYPE = 4,
    VT_VALUE = 6
  };
  PrimitiveType value_type() const {
    return static_cast<PrimitiveType>(GetField<uint8_t>(VT_VALUE_TYPE, 0));
  }
  const void *value() const {
    return GetPointer<const void *>(VT_VALUE);
  }
  template<typename T> const T *value_as() const;
  const Concat *value_as_Concat() const {
    return value_type() == PrimitiveType_Concat ? static_cast<const Concat *>(value()) : nullptr;
  }
  const SoftMax *value_as_SoftMax() const {
    return value_type() == PrimitiveType_SoftMax ? static_cast<const SoftMax *>(value()) : nullptr;
  }
  const Activation *value_as_Activation() const {
    return value_type() == PrimitiveType_Activation ? static_cast<const Activation *>(value()) : nullptr;
  }
  const Conv2D *value_as_Conv2D() const {
    return value_type() == PrimitiveType_Conv2D ? static_cast<const Conv2D *>(value()) : nullptr;
  }
  const FusedBatchNorm *value_as_FusedBatchNorm() const {
    return value_type() == PrimitiveType_FusedBatchNorm ? static_cast<const FusedBatchNorm *>(value()) : nullptr;
  }
  const BatchNorm *value_as_BatchNorm() const {
    return value_type() == PrimitiveType_BatchNorm ? static_cast<const BatchNorm *>(value()) : nullptr;
  }
  const BiasAdd *value_as_BiasAdd() const {
    return value_type() == PrimitiveType_BiasAdd ? static_cast<const BiasAdd *>(value()) : nullptr;
  }
  const Pooling *value_as_Pooling() const {
    return value_type() == PrimitiveType_Pooling ? static_cast<const Pooling *>(value()) : nullptr;
  }
  const ROIPooling *value_as_ROIPooling() const {
    return value_type() == PrimitiveType_ROIPooling ? static_cast<const ROIPooling *>(value()) : nullptr;
  }
  const DepthwiseConv2D *value_as_DepthwiseConv2D() const {
    return value_type() == PrimitiveType_DepthwiseConv2D ? static_cast<const DepthwiseConv2D *>(value()) : nullptr;
  }
  const DeDepthwiseConv2D *value_as_DeDepthwiseConv2D() const {
    return value_type() == PrimitiveType_DeDepthwiseConv2D ? static_cast<const DeDepthwiseConv2D *>(value()) : nullptr;
  }
  const Resize *value_as_Resize() const {
    return value_type() == PrimitiveType_Resize ? static_cast<const Resize *>(value()) : nullptr;
  }
  const DetectionPostProcess *value_as_DetectionPostProcess() const {
    return value_type() == PrimitiveType_DetectionPostProcess ? static_cast<const DetectionPostProcess *>(value()) : nullptr;
  }
  const FullConnection *value_as_FullConnection() const {
    return value_type() == PrimitiveType_FullConnection ? static_cast<const FullConnection *>(value()) : nullptr;
  }
  const Mean *value_as_Mean() const {
    return value_type() == PrimitiveType_Mean ? static_cast<const Mean *>(value()) : nullptr;
  }
  const DeConv2D *value_as_DeConv2D() const {
    return value_type() == PrimitiveType_DeConv2D ? static_cast<const DeConv2D *>(value()) : nullptr;
  }
  const Scale *value_as_Scale() const {
    return value_type() == PrimitiveType_Scale ? static_cast<const Scale *>(value()) : nullptr;
  }
  const Reshape *value_as_Reshape() const {
    return value_type() == PrimitiveType_Reshape ? static_cast<const Reshape *>(value()) : nullptr;
  }
  const Eltwise *value_as_Eltwise() const {
    return value_type() == PrimitiveType_Eltwise ? static_cast<const Eltwise *>(value()) : nullptr;
  }
  const NetOutput *value_as_NetOutput() const {
    return value_type() == PrimitiveType_NetOutput ? static_cast<const NetOutput *>(value()) : nullptr;
  }
  const Add *value_as_Add() const {
    return value_type() == PrimitiveType_Add ? static_cast<const Add *>(value()) : nullptr;
  }
  const Sub *value_as_Sub() const {
    return value_type() == PrimitiveType_Sub ? static_cast<const Sub *>(value()) : nullptr;
  }
  const MatMul *value_as_MatMul() const {
    return value_type() == PrimitiveType_MatMul ? static_cast<const MatMul *>(value()) : nullptr;
  }
  const StridedSlice *value_as_StridedSlice() const {
    return value_type() == PrimitiveType_StridedSlice ? static_cast<const StridedSlice *>(value()) : nullptr;
  }
  const Power *value_as_Power() const {
    return value_type() == PrimitiveType_Power ? static_cast<const Power *>(value()) : nullptr;
  }
  const Slice *value_as_Slice() const {
    return value_type() == PrimitiveType_Slice ? static_cast<const Slice *>(value()) : nullptr;
  }
  const Stack *value_as_Stack() const {
    return value_type() == PrimitiveType_Stack ? static_cast<const Stack *>(value()) : nullptr;
  }
  const Mul *value_as_Mul() const {
    return value_type() == PrimitiveType_Mul ? static_cast<const Mul *>(value()) : nullptr;
  }
  const RealDiv *value_as_RealDiv() const {
    return value_type() == PrimitiveType_RealDiv ? static_cast<const RealDiv *>(value()) : nullptr;
  }
  const Pad *value_as_Pad() const {
    return value_type() == PrimitiveType_Pad ? static_cast<const Pad *>(value()) : nullptr;
  }
  const Maximum *value_as_Maximum() const {
    return value_type() == PrimitiveType_Maximum ? static_cast<const Maximum *>(value()) : nullptr;
  }
  const Minimum *value_as_Minimum() const {
    return value_type() == PrimitiveType_Minimum ? static_cast<const Minimum *>(value()) : nullptr;
  }
  const PReLU *value_as_PReLU() const {
    return value_type() == PrimitiveType_PReLU ? static_cast<const PReLU *>(value()) : nullptr;
  }
  const LeakyReLU *value_as_LeakyReLU() const {
    return value_type() == PrimitiveType_LeakyReLU ? static_cast<const LeakyReLU *>(value()) : nullptr;
  }
  const ArgMax *value_as_ArgMax() const {
    return value_type() == PrimitiveType_ArgMax ? static_cast<const ArgMax *>(value()) : nullptr;
  }
  const ArgMin *value_as_ArgMin() const {
    return value_type() == PrimitiveType_ArgMin ? static_cast<const ArgMin *>(value()) : nullptr;
  }
  const Exp *value_as_Exp() const {
    return value_type() == PrimitiveType_Exp ? static_cast<const Exp *>(value()) : nullptr;
  }
  const Crop *value_as_Crop() const {
    return value_type() == PrimitiveType_Crop ? static_cast<const Crop *>(value()) : nullptr;
  }
  const Range *value_as_Range() const {
    return value_type() == PrimitiveType_Range ? static_cast<const Range *>(value()) : nullptr;
  }
  const Rsqrt *value_as_Rsqrt() const {
    return value_type() == PrimitiveType_Rsqrt ? static_cast<const Rsqrt *>(value()) : nullptr;
  }
  const ExpandDims *value_as_ExpandDims() const {
    return value_type() == PrimitiveType_ExpandDims ? static_cast<const ExpandDims *>(value()) : nullptr;
  }
  const Tile *value_as_Tile() const {
    return value_type() == PrimitiveType_Tile ? static_cast<const Tile *>(value()) : nullptr;
  }
  const Cast *value_as_Cast() const {
    return value_type() == PrimitiveType_Cast ? static_cast<const Cast *>(value()) : nullptr;
  }
  const Shape *value_as_Shape() const {
    return value_type() == PrimitiveType_Shape ? static_cast<const Shape *>(value()) : nullptr;
  }
  const Nchw2Nhwc *value_as_Nchw2Nhwc() const {
    return value_type() == PrimitiveType_Nchw2Nhwc ? static_cast<const Nchw2Nhwc *>(value()) : nullptr;
  }
  const Nhwc2Nchw *value_as_Nhwc2Nchw() const {
    return value_type() == PrimitiveType_Nhwc2Nchw ? static_cast<const Nhwc2Nchw *>(value()) : nullptr;
  }
  const QuantDTypeCast *value_as_QuantDTypeCast() const {
    return value_type() == PrimitiveType_QuantDTypeCast ? static_cast<const QuantDTypeCast *>(value()) : nullptr;
  }
  const Split *value_as_Split() const {
    return value_type() == PrimitiveType_Split ? static_cast<const Split *>(value()) : nullptr;
  }
  const Permute *value_as_Permute() const {
    return value_type() == PrimitiveType_Permute ? static_cast<const Permute *>(value()) : nullptr;
  }
  const FakeQuantWithMinMaxVars *value_as_FakeQuantWithMinMaxVars() const {
    return value_type() == PrimitiveType_FakeQuantWithMinMaxVars ? static_cast<const FakeQuantWithMinMaxVars *>(value()) : nullptr;
  }
  const Equal *value_as_Equal() const {
    return value_type() == PrimitiveType_Equal ? static_cast<const Equal *>(value()) : nullptr;
  }
  const Less *value_as_Less() const {
    return value_type() == PrimitiveType_Less ? static_cast<const Less *>(value()) : nullptr;
  }
  const Greater *value_as_Greater() const {
    return value_type() == PrimitiveType_Greater ? static_cast<const Greater *>(value()) : nullptr;
  }
  const NotEqual *value_as_NotEqual() const {
    return value_type() == PrimitiveType_NotEqual ? static_cast<const NotEqual *>(value()) : nullptr;
  }
  const LessEqual *value_as_LessEqual() const {
    return value_type() == PrimitiveType_LessEqual ? static_cast<const LessEqual *>(value()) : nullptr;
  }
  const GreaterEqual *value_as_GreaterEqual() const {
    return value_type() == PrimitiveType_GreaterEqual ? static_cast<const GreaterEqual *>(value()) : nullptr;
  }
  const Min *value_as_Min() const {
    return value_type() == PrimitiveType_Min ? static_cast<const Min *>(value()) : nullptr;
  }
  const Floor *value_as_Floor() const {
    return value_type() == PrimitiveType_Floor ? static_cast<const Floor *>(value()) : nullptr;
  }
  const Abs *value_as_Abs() const {
    return value_type() == PrimitiveType_Abs ? static_cast<const Abs *>(value()) : nullptr;
  }
  const Neg *value_as_Neg() const {
    return value_type() == PrimitiveType_Neg ? static_cast<const Neg *>(value()) : nullptr;
  }
  const Cos *value_as_Cos() const {
    return value_type() == PrimitiveType_Cos ? static_cast<const Cos *>(value()) : nullptr;
  }
  const Sin *value_as_Sin() const {
    return value_type() == PrimitiveType_Sin ? static_cast<const Sin *>(value()) : nullptr;
  }
  const Sqrt *value_as_Sqrt() const {
    return value_type() == PrimitiveType_Sqrt ? static_cast<const Sqrt *>(value()) : nullptr;
  }
  const Square *value_as_Square() const {
    return value_type() == PrimitiveType_Square ? static_cast<const Square *>(value()) : nullptr;
  }
  const Constant *value_as_Constant() const {
    return value_type() == PrimitiveType_Constant ? static_cast<const Constant *>(value()) : nullptr;
  }
  const Log *value_as_Log() const {
    return value_type() == PrimitiveType_Log ? static_cast<const Log *>(value()) : nullptr;
  }
  const Tan *value_as_Tan() const {
    return value_type() == PrimitiveType_Tan ? static_cast<const Tan *>(value()) : nullptr;
  }
  const Atan *value_as_Atan() const {
    return value_type() == PrimitiveType_Atan ? static_cast<const Atan *>(value()) : nullptr;
  }
  const Asin *value_as_Asin() const {
    return value_type() == PrimitiveType_Asin ? static_cast<const Asin *>(value()) : nullptr;
  }
  const Clip *value_as_Clip() const {
    return value_type() == PrimitiveType_Clip ? static_cast<const Clip *>(value()) : nullptr;
  }
  const Transpose *value_as_Transpose() const {
    return value_type() == PrimitiveType_Transpose ? static_cast<const Transpose *>(value()) : nullptr;
  }
  const Squeeze *value_as_Squeeze() const {
    return value_type() == PrimitiveType_Squeeze ? static_cast<const Squeeze *>(value()) : nullptr;
  }
  const Unsqueeze *value_as_Unsqueeze() const {
    return value_type() == PrimitiveType_Unsqueeze ? static_cast<const Unsqueeze *>(value()) : nullptr;
  }
  const Upsample *value_as_Upsample() const {
    return value_type() == PrimitiveType_Upsample ? static_cast<const Upsample *>(value()) : nullptr;
  }
  const Dropout *value_as_Dropout() const {
    return value_type() == PrimitiveType_Dropout ? static_cast<const Dropout *>(value()) : nullptr;
  }
  const Broadcast *value_as_Broadcast() const {
    return value_type() == PrimitiveType_Broadcast ? static_cast<const Broadcast *>(value()) : nullptr;
  }
  const BroadcastTo *value_as_BroadcastTo() const {
    return value_type() == PrimitiveType_BroadcastTo ? static_cast<const BroadcastTo *>(value()) : nullptr;
  }
  const Lrn *value_as_Lrn() const {
    return value_type() == PrimitiveType_Lrn ? static_cast<const Lrn *>(value()) : nullptr;
  }
  const ZerosLike *value_as_ZerosLike() const {
    return value_type() == PrimitiveType_ZerosLike ? static_cast<const ZerosLike *>(value()) : nullptr;
  }
  const TopK *value_as_TopK() const {
    return value_type() == PrimitiveType_TopK ? static_cast<const TopK *>(value()) : nullptr;
  }
  const SpaceToDepth *value_as_SpaceToDepth() const {
    return value_type() == PrimitiveType_SpaceToDepth ? static_cast<const SpaceToDepth *>(value()) : nullptr;
  }
  const SpaceToBatch *value_as_SpaceToBatch() const {
    return value_type() == PrimitiveType_SpaceToBatch ? static_cast<const SpaceToBatch *>(value()) : nullptr;
  }
  const SparseToDense *value_as_SparseToDense() const {
    return value_type() == PrimitiveType_SparseToDense ? static_cast<const SparseToDense *>(value()) : nullptr;
  }
  const ReverseSequence *value_as_ReverseSequence() const {
    return value_type() == PrimitiveType_ReverseSequence ? static_cast<const ReverseSequence *>(value()) : nullptr;
  }
  const Rank *value_as_Rank() const {
    return value_type() == PrimitiveType_Rank ? static_cast<const Rank *>(value()) : nullptr;
  }
  const Gather *value_as_Gather() const {
    return value_type() == PrimitiveType_Gather ? static_cast<const Gather *>(value()) : nullptr;
  }
  const GatherNd *value_as_GatherNd() const {
    return value_type() == PrimitiveType_GatherNd ? static_cast<const GatherNd *>(value()) : nullptr;
  }
  const Fill *value_as_Fill() const {
    return value_type() == PrimitiveType_Fill ? static_cast<const Fill *>(value()) : nullptr;
  }
  const Elu *value_as_Elu() const {
    return value_type() == PrimitiveType_Elu ? static_cast<const Elu *>(value()) : nullptr;
  }
  const DepthToSpace *value_as_DepthToSpace() const {
    return value_type() == PrimitiveType_DepthToSpace ? static_cast<const DepthToSpace *>(value()) : nullptr;
  }
  const BatchToSpace *value_as_BatchToSpace() const {
    return value_type() == PrimitiveType_BatchToSpace ? static_cast<const BatchToSpace *>(value()) : nullptr;
  }
  const AddN *value_as_AddN() const {
    return value_type() == PrimitiveType_AddN ? static_cast<const AddN *>(value()) : nullptr;
  }
  const Ceil *value_as_Ceil() const {
    return value_type() == PrimitiveType_Ceil ? static_cast<const Ceil *>(value()) : nullptr;
  }
  const EmbeddingLookup *value_as_EmbeddingLookup() const {
    return value_type() == PrimitiveType_EmbeddingLookup ? static_cast<const EmbeddingLookup *>(value()) : nullptr;
  }
  const EmbeddingLookupSparse *value_as_EmbeddingLookupSparse() const {
    return value_type() == PrimitiveType_EmbeddingLookupSparse ? static_cast<const EmbeddingLookupSparse *>(value()) : nullptr;
  }
  const FloorDiv *value_as_FloorDiv() const {
    return value_type() == PrimitiveType_FloorDiv ? static_cast<const FloorDiv *>(value()) : nullptr;
  }
  const FloorMod *value_as_FloorMod() const {
    return value_type() == PrimitiveType_FloorMod ? static_cast<const FloorMod *>(value()) : nullptr;
  }
  const L2Norm *value_as_L2Norm() const {
    return value_type() == PrimitiveType_L2Norm ? static_cast<const L2Norm *>(value()) : nullptr;
  }
  const LocalResponseNormalization *value_as_LocalResponseNormalization() const {
    return value_type() == PrimitiveType_LocalResponseNormalization ? static_cast<const LocalResponseNormalization *>(value()) : nullptr;
  }
  const MatrixDiag *value_as_MatrixDiag() const {
    return value_type() == PrimitiveType_MatrixDiag ? static_cast<const MatrixDiag *>(value()) : nullptr;
  }
  const Reduce *value_as_Reduce() const {
    return value_type() == PrimitiveType_Reduce ? static_cast<const Reduce *>(value()) : nullptr;
  }
  const Reverse *value_as_Reverse() const {
    return value_type() == PrimitiveType_Reverse ? static_cast<const Reverse *>(value()) : nullptr;
  }
  const Round *value_as_Round() const {
    return value_type() == PrimitiveType_Round ? static_cast<const Round *>(value()) : nullptr;
  }
  const Select *value_as_Select() const {
    return value_type() == PrimitiveType_Select ? static_cast<const Select *>(value()) : nullptr;
  }
  const Scatter *value_as_Scatter() const {
    return value_type() == PrimitiveType_Scatter ? static_cast<const Scatter *>(value()) : nullptr;
  }
  const ScatterND *value_as_ScatterND() const {
    return value_type() == PrimitiveType_ScatterND ? static_cast<const ScatterND *>(value()) : nullptr;
  }
  const ConstantOfShape *value_as_ConstantOfShape() const {
    return value_type() == PrimitiveType_ConstantOfShape ? static_cast<const ConstantOfShape *>(value()) : nullptr;
  }
  const Unique *value_as_Unique() const {
    return value_type() == PrimitiveType_Unique ? static_cast<const Unique *>(value()) : nullptr;
  }
  const Unstack *value_as_Unstack() const {
    return value_type() == PrimitiveType_Unstack ? static_cast<const Unstack *>(value()) : nullptr;
  }
  const LogicalAnd *value_as_LogicalAnd() const {
    return value_type() == PrimitiveType_LogicalAnd ? static_cast<const LogicalAnd *>(value()) : nullptr;
  }
  const LogicalOr *value_as_LogicalOr() const {
    return value_type() == PrimitiveType_LogicalOr ? static_cast<const LogicalOr *>(value()) : nullptr;
  }
  const LogicalXor *value_as_LogicalXor() const {
    return value_type() == PrimitiveType_LogicalXor ? static_cast<const LogicalXor *>(value()) : nullptr;
  }
  const LogicalNot *value_as_LogicalNot() const {
    return value_type() == PrimitiveType_LogicalNot ? static_cast<const LogicalNot *>(value()) : nullptr;
  }
  const OnnxInt8Quantize *value_as_OnnxInt8Quantize() const {
    return value_type() == PrimitiveType_OnnxInt8Quantize ? static_cast<const OnnxInt8Quantize *>(value()) : nullptr;
  }
  const OnnxInt8Dequantize *value_as_OnnxInt8Dequantize() const {
    return value_type() == PrimitiveType_OnnxInt8Dequantize ? static_cast<const OnnxInt8Dequantize *>(value()) : nullptr;
  }
  const FakeQuantWithMinMax *value_as_FakeQuantWithMinMax() const {
    return value_type() == PrimitiveType_FakeQuantWithMinMax ? static_cast<const FakeQuantWithMinMax *>(value()) : nullptr;
  }
  const FakeQuantWithMinMaxPerChannel *value_as_FakeQuantWithMinMaxPerChannel() const {
    return value_type() == PrimitiveType_FakeQuantWithMinMaxPerChannel ? static_cast<const FakeQuantWithMinMaxPerChannel *>(value()) : nullptr;
  }
  const BatchNormFold *value_as_BatchNormFold() const {
    return value_type() == PrimitiveType_BatchNormFold ? static_cast<const BatchNormFold *>(value()) : nullptr;
  }
  const MulFold *value_as_MulFold() const {
    return value_type() == PrimitiveType_MulFold ? static_cast<const MulFold *>(value()) : nullptr;
  }
  const AddFold *value_as_AddFold() const {
    return value_type() == PrimitiveType_AddFold ? static_cast<const AddFold *>(value()) : nullptr;
  }
  const SquaredDifference *value_as_SquaredDifference() const {
    return value_type() == PrimitiveType_SquaredDifference ? static_cast<const SquaredDifference *>(value()) : nullptr;
  }
  const Flatten *value_as_Flatten() const {
    return value_type() == PrimitiveType_Flatten ? static_cast<const Flatten *>(value()) : nullptr;
  }
  const FlattenGrad *value_as_FlattenGrad() const {
    return value_type() == PrimitiveType_FlattenGrad ? static_cast<const FlattenGrad *>(value()) : nullptr;
  }
  const TupleGetItem *value_as_TupleGetItem() const {
    return value_type() == PrimitiveType_TupleGetItem ? static_cast<const TupleGetItem *>(value()) : nullptr;
  }
  const Div *value_as_Div() const {
    return value_type() == PrimitiveType_Div ? static_cast<const Div *>(value()) : nullptr;
  }
  const Where *value_as_Where() const {
    return value_type() == PrimitiveType_Where ? static_cast<const Where *>(value()) : nullptr;
  }
  const OneHot *value_as_OneHot() const {
    return value_type() == PrimitiveType_OneHot ? static_cast<const OneHot *>(value()) : nullptr;
  }
  const Lstm *value_as_Lstm() const {
    return value_type() == PrimitiveType_Lstm ? static_cast<const Lstm *>(value()) : nullptr;
  }
  const Conv2DGradFilter *value_as_Conv2DGradFilter() const {
    return value_type() == PrimitiveType_Conv2DGradFilter ? static_cast<const Conv2DGradFilter *>(value()) : nullptr;
  }
  const Conv2DGradInput *value_as_Conv2DGradInput() const {
    return value_type() == PrimitiveType_Conv2DGradInput ? static_cast<const Conv2DGradInput *>(value()) : nullptr;
  }
  const PoolingGrad *value_as_PoolingGrad() const {
    return value_type() == PrimitiveType_PoolingGrad ? static_cast<const PoolingGrad *>(value()) : nullptr;
  }
  const BNGrad *value_as_BNGrad() const {
    return value_type() == PrimitiveType_BNGrad ? static_cast<const BNGrad *>(value()) : nullptr;
  }
  const Assign *value_as_Assign() const {
    return value_type() == PrimitiveType_Assign ? static_cast<const Assign *>(value()) : nullptr;
  }
  const ApplyMomentum *value_as_ApplyMomentum() const {
    return value_type() == PrimitiveType_ApplyMomentum ? static_cast<const ApplyMomentum *>(value()) : nullptr;
  }
  const BiasGrad *value_as_BiasGrad() const {
    return value_type() == PrimitiveType_BiasGrad ? static_cast<const BiasGrad *>(value()) : nullptr;
  }
  const SoftmaxCrossEntropy *value_as_SoftmaxCrossEntropy() const {
    return value_type() == PrimitiveType_SoftmaxCrossEntropy ? static_cast<const SoftmaxCrossEntropy *>(value()) : nullptr;
  }
  const AddGrad *value_as_AddGrad() const {
    return value_type() == PrimitiveType_AddGrad ? static_cast<const AddGrad *>(value()) : nullptr;
  }
  const SubGrad *value_as_SubGrad() const {
    return value_type() == PrimitiveType_SubGrad ? static_cast<const SubGrad *>(value()) : nullptr;
  }
  const MulGrad *value_as_MulGrad() const {
    return value_type() == PrimitiveType_MulGrad ? static_cast<const MulGrad *>(value()) : nullptr;
  }
  const DivGrad *value_as_DivGrad() const {
    return value_type() == PrimitiveType_DivGrad ? static_cast<const DivGrad *>(value()) : nullptr;
  }
  const PowerGrad *value_as_PowerGrad() const {
    return value_type() == PrimitiveType_PowerGrad ? static_cast<const PowerGrad *>(value()) : nullptr;
  }
  const ActivationGrad *value_as_ActivationGrad() const {
    return value_type() == PrimitiveType_ActivationGrad ? static_cast<const ActivationGrad *>(value()) : nullptr;
  }
  const PriorBox *value_as_PriorBox() const {
    return value_type() == PrimitiveType_PriorBox ? static_cast<const PriorBox *>(value()) : nullptr;
  }
  const SpaceToBatchND *value_as_SpaceToBatchND() const {
    return value_type() == PrimitiveType_SpaceToBatchND ? static_cast<const SpaceToBatchND *>(value()) : nullptr;
  }
  const Depend *value_as_Depend() const {
    return value_type() == PrimitiveType_Depend ? static_cast<const Depend *>(value()) : nullptr;
  }
  const Return *value_as_Return() const {
    return value_type() == PrimitiveType_Return ? static_cast<const Return *>(value()) : nullptr;
  }
  const MakeTuple *value_as_MakeTuple() const {
    return value_type() == PrimitiveType_MakeTuple ? static_cast<const MakeTuple *>(value()) : nullptr;
  }
  const ToFormat *value_as_ToFormat() const {
    return value_type() == PrimitiveType_ToFormat ? static_cast<const ToFormat *>(value()) : nullptr;
  }
  const Proposal *value_as_Proposal() const {
    return value_type() == PrimitiveType_Proposal ? static_cast<const Proposal *>(value()) : nullptr;
  }
  const Custom *value_as_Custom() const {
    return value_type() == PrimitiveType_Custom ? static_cast<const Custom *>(value()) : nullptr;
  }
  const BlackBox *value_as_BlackBox() const {
    return value_type() == PrimitiveType_BlackBox ? static_cast<const BlackBox *>(value()) : nullptr;
  }
  const NegGrad *value_as_NegGrad() const {
    return value_type() == PrimitiveType_NegGrad ? static_cast<const NegGrad *>(value()) : nullptr;
  }
  const LogGrad *value_as_LogGrad() const {
    return value_type() == PrimitiveType_LogGrad ? static_cast<const LogGrad *>(value()) : nullptr;
  }
  const BatchToSpaceND *value_as_BatchToSpaceND() const {
    return value_type() == PrimitiveType_BatchToSpaceND ? static_cast<const BatchToSpaceND *>(value()) : nullptr;
  }
  const LshProjection *value_as_LshProjection() const {
    return value_type() == PrimitiveType_LshProjection ? static_cast<const LshProjection *>(value()) : nullptr;
  }
  const HashtableLookup *value_as_HashtableLookup() const {
    return value_type() == PrimitiveType_HashtableLookup ? static_cast<const HashtableLookup *>(value()) : nullptr;
  }
  const SkipGram *value_as_SkipGram() const {
    return value_type() == PrimitiveType_SkipGram ? static_cast<const SkipGram *>(value()) : nullptr;
  }
  const DeConv2DGradFilter *value_as_DeConv2DGradFilter() const {
    return value_type() == PrimitiveType_DeConv2DGradFilter ? static_cast<const DeConv2DGradFilter *>(value()) : nullptr;
  }
  const CustomPredict *value_as_CustomPredict() const {
    return value_type() == PrimitiveType_CustomPredict ? static_cast<const CustomPredict *>(value()) : nullptr;
  }
  const CustomNormalize *value_as_CustomNormalize() const {
    return value_type() == PrimitiveType_CustomNormalize ? static_cast<const CustomNormalize *>(value()) : nullptr;
  }
  const CustomExtractFeatures *value_as_CustomExtractFeatures() const {
    return value_type() == PrimitiveType_CustomExtractFeatures ? static_cast<const CustomExtractFeatures *>(value()) : nullptr;
  }
  const AudioSpectrogram *value_as_AudioSpectrogram() const {
    return value_type() == PrimitiveType_AudioSpectrogram ? static_cast<const AudioSpectrogram *>(value()) : nullptr;
  }
  const Mfcc *value_as_Mfcc() const {
    return value_type() == PrimitiveType_Mfcc ? static_cast<const Mfcc *>(value()) : nullptr;
  }
  const Rfft *value_as_Rfft() const {
    return value_type() == PrimitiveType_Rfft ? static_cast<const Rfft *>(value()) : nullptr;
  }
  const FftReal *value_as_FftReal() const {
    return value_type() == PrimitiveType_FftReal ? static_cast<const FftReal *>(value()) : nullptr;
  }
  const FftImag *value_as_FftImag() const {
    return value_type() == PrimitiveType_FftImag ? static_cast<const FftImag *>(value()) : nullptr;
  }
  const Sgd *value_as_Sgd() const {
    return value_type() == PrimitiveType_Sgd ? static_cast<const Sgd *>(value()) : nullptr;
  }
  const Adam *value_as_Adam() const {
    return value_type() == PrimitiveType_Adam ? static_cast<const Adam *>(value()) : nullptr;
  }
  const GroupConv2DGradInput *value_as_GroupConv2DGradInput() const {
    return value_type() == PrimitiveType_GroupConv2DGradInput ? static_cast<const GroupConv2DGradInput *>(value()) : nullptr;
  }
  const Loop *value_as_Loop() const {
    return value_type() == PrimitiveType_Loop ? static_cast<const Loop *>(value()) : nullptr;
  }
  const NonMaxSuppression *value_as_NonMaxSuppression() const {
    return value_type() == PrimitiveType_NonMaxSuppression ? static_cast<const NonMaxSuppression *>(value()) : nullptr;
  }
  const InstanceNorm *value_as_InstanceNorm() const {
    return value_type() == PrimitiveType_InstanceNorm ? static_cast<const InstanceNorm *>(value()) : nullptr;
  }
  const Identity *value_as_Identity() const {
    return value_type() == PrimitiveType_Identity ? static_cast<const Identity *>(value()) : nullptr;
  }
  const LayerNorm *value_as_LayerNorm() const {
    return value_type() == PrimitiveType_LayerNorm ? static_cast<const LayerNorm *>(value()) : nullptr;
  }
  const While *value_as_While() const {
    return value_type() == PrimitiveType_While ? static_cast<const While *>(value()) : nullptr;
  }
  const ControlDepend *value_as_ControlDepend() const {
    return value_type() == PrimitiveType_ControlDepend ? static_cast<const ControlDepend *>(value()) : nullptr;
  }
  const UnsortedSegmentSum *value_as_UnsortedSegmentSum() const {
    return value_type() == PrimitiveType_UnsortedSegmentSum ? static_cast<const UnsortedSegmentSum *>(value()) : nullptr;
  }
  const AssignAdd *value_as_AssignAdd() const {
    return value_type() == PrimitiveType_AssignAdd ? static_cast<const AssignAdd *>(value()) : nullptr;
  }
  const OnesLike *value_as_OnesLike() const {
    return value_type() == PrimitiveType_OnesLike ? static_cast<const OnesLike *>(value()) : nullptr;
  }
  const BinaryCrossEntropyGrad *value_as_BinaryCrossEntropyGrad() const {
    return value_type() == PrimitiveType_BinaryCrossEntropyGrad ? static_cast<const BinaryCrossEntropyGrad *>(value()) : nullptr;
  }
  const BinaryCrossEntropy *value_as_BinaryCrossEntropy() const {
    return value_type() == PrimitiveType_BinaryCrossEntropy ? static_cast<const BinaryCrossEntropy *>(value()) : nullptr;
  }
  const LpNormalization *value_as_LpNormalization() const {
    return value_type() == PrimitiveType_LpNormalization ? static_cast<const LpNormalization *>(value()) : nullptr;
  }
  const DropoutGrad *value_as_DropoutGrad() const {
    return value_type() == PrimitiveType_DropoutGrad ? static_cast<const DropoutGrad *>(value()) : nullptr;
  }
  const MaximumGrad *value_as_MaximumGrad() const {
    return value_type() == PrimitiveType_MaximumGrad ? static_cast<const MaximumGrad *>(value()) : nullptr;
  }
  const MinimumGrad *value_as_MinimumGrad() const {
    return value_type() == PrimitiveType_MinimumGrad ? static_cast<const MinimumGrad *>(value()) : nullptr;
  }
  const Switch *value_as_Switch() const {
    return value_type() == PrimitiveType_Switch ? static_cast<const Switch *>(value()) : nullptr;
  }
  const Partial *value_as_Partial() const {
    return value_type() == PrimitiveType_Partial ? static_cast<const Partial *>(value()) : nullptr;
  }
  const TensorListFromTensor *value_as_TensorListFromTensor() const {
    return value_type() == PrimitiveType_TensorListFromTensor ? static_cast<const TensorListFromTensor *>(value()) : nullptr;
  }
  const TensorListStack *value_as_TensorListStack() const {
    return value_type() == PrimitiveType_TensorListStack ? static_cast<const TensorListStack *>(value()) : nullptr;
  }
  const TensorListGetItem *value_as_TensorListGetItem() const {
    return value_type() == PrimitiveType_TensorListGetItem ? static_cast<const TensorListGetItem *>(value()) : nullptr;
  }
  const TensorListSetItem *value_as_TensorListSetItem() const {
    return value_type() == PrimitiveType_TensorListSetItem ? static_cast<const TensorListSetItem *>(value()) : nullptr;
  }
  const TensorListReserve *value_as_TensorListReserve() const {
    return value_type() == PrimitiveType_TensorListReserve ? static_cast<const TensorListReserve *>(value()) : nullptr;
  }
  const All *value_as_All() const {
    return value_type() == PrimitiveType_All ? static_cast<const All *>(value()) : nullptr;
  }
  const Assert *value_as_Assert() const {
    return value_type() == PrimitiveType_Assert ? static_cast<const Assert *>(value()) : nullptr;
  }
  const Adder *value_as_Adder() const {
    return value_type() == PrimitiveType_Adder ? static_cast<const Adder *>(value()) : nullptr;
  }
  const SparseSoftmaxCrossEntropy *value_as_SparseSoftmaxCrossEntropy() const {
    return value_type() == PrimitiveType_SparseSoftmaxCrossEntropy ? static_cast<const SparseSoftmaxCrossEntropy *>(value()) : nullptr;
  }
  const SmoothL1Loss *value_as_SmoothL1Loss() const {
    return value_type() == PrimitiveType_SmoothL1Loss ? static_cast<const SmoothL1Loss *>(value()) : nullptr;
  }
  const SmoothL1LossGrad *value_as_SmoothL1LossGrad() const {
    return value_type() == PrimitiveType_SmoothL1LossGrad ? static_cast<const SmoothL1LossGrad *>(value()) : nullptr;
  }
  const SigmoidCrossEntropyWithLogits *value_as_SigmoidCrossEntropyWithLogits() const {
    return value_type() == PrimitiveType_SigmoidCrossEntropyWithLogits ? static_cast<const SigmoidCrossEntropyWithLogits *>(value()) : nullptr;
  }
  const SigmoidCrossEntropyWithLogitsGrad *value_as_SigmoidCrossEntropyWithLogitsGrad() const {
    return value_type() == PrimitiveType_SigmoidCrossEntropyWithLogitsGrad ? static_cast<const SigmoidCrossEntropyWithLogitsGrad *>(value()) : nullptr;
  }
  const Reciprocal *value_as_Reciprocal() const {
    return value_type() == PrimitiveType_Reciprocal ? static_cast<const Reciprocal *>(value()) : nullptr;
  }
  const Merge *value_as_Merge() const {
    return value_type() == PrimitiveType_Merge ? static_cast<const Merge *>(value()) : nullptr;
  }
  const Mod *value_as_Mod() const {
    return value_type() == PrimitiveType_Mod ? static_cast<const Mod *>(value()) : nullptr;
  }
  const GeLU *value_as_GeLU() const {
    return value_type() == PrimitiveType_GeLU ? static_cast<const GeLU *>(value()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_VALUE_TYPE) &&
           VerifyOffset(verifier, VT_VALUE) &&
           VerifyPrimitiveType(verifier, value(), value_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Concat *Primitive::value_as<Concat>() const {
  return value_as_Concat();
}

template<> inline const SoftMax *Primitive::value_as<SoftMax>() const {
  return value_as_SoftMax();
}

template<> inline const Activation *Primitive::value_as<Activation>() const {
  return value_as_Activation();
}

template<> inline const Conv2D *Primitive::value_as<Conv2D>() const {
  return value_as_Conv2D();
}

template<> inline const FusedBatchNorm *Primitive::value_as<FusedBatchNorm>() const {
  return value_as_FusedBatchNorm();
}

template<> inline const BatchNorm *Primitive::value_as<BatchNorm>() const {
  return value_as_BatchNorm();
}

template<> inline const BiasAdd *Primitive::value_as<BiasAdd>() const {
  return value_as_BiasAdd();
}

template<> inline const Pooling *Primitive::value_as<Pooling>() const {
  return value_as_Pooling();
}

template<> inline const ROIPooling *Primitive::value_as<ROIPooling>() const {
  return value_as_ROIPooling();
}

template<> inline const DepthwiseConv2D *Primitive::value_as<DepthwiseConv2D>() const {
  return value_as_DepthwiseConv2D();
}

template<> inline const DeDepthwiseConv2D *Primitive::value_as<DeDepthwiseConv2D>() const {
  return value_as_DeDepthwiseConv2D();
}

template<> inline const Resize *Primitive::value_as<Resize>() const {
  return value_as_Resize();
}

template<> inline const DetectionPostProcess *Primitive::value_as<DetectionPostProcess>() const {
  return value_as_DetectionPostProcess();
}

template<> inline const FullConnection *Primitive::value_as<FullConnection>() const {
  return value_as_FullConnection();
}

template<> inline const Mean *Primitive::value_as<Mean>() const {
  return value_as_Mean();
}

template<> inline const DeConv2D *Primitive::value_as<DeConv2D>() const {
  return value_as_DeConv2D();
}

template<> inline const Scale *Primitive::value_as<Scale>() const {
  return value_as_Scale();
}

template<> inline const Reshape *Primitive::value_as<Reshape>() const {
  return value_as_Reshape();
}

template<> inline const Eltwise *Primitive::value_as<Eltwise>() const {
  return value_as_Eltwise();
}

template<> inline const NetOutput *Primitive::value_as<NetOutput>() const {
  return value_as_NetOutput();
}

template<> inline const Add *Primitive::value_as<Add>() const {
  return value_as_Add();
}

template<> inline const Sub *Primitive::value_as<Sub>() const {
  return value_as_Sub();
}

template<> inline const MatMul *Primitive::value_as<MatMul>() const {
  return value_as_MatMul();
}

template<> inline const StridedSlice *Primitive::value_as<StridedSlice>() const {
  return value_as_StridedSlice();
}

template<> inline const Power *Primitive::value_as<Power>() const {
  return value_as_Power();
}

template<> inline const Slice *Primitive::value_as<Slice>() const {
  return value_as_Slice();
}

template<> inline const Stack *Primitive::value_as<Stack>() const {
  return value_as_Stack();
}

template<> inline const Mul *Primitive::value_as<Mul>() const {
  return value_as_Mul();
}

template<> inline const RealDiv *Primitive::value_as<RealDiv>() const {
  return value_as_RealDiv();
}

template<> inline const Pad *Primitive::value_as<Pad>() const {
  return value_as_Pad();
}

template<> inline const Maximum *Primitive::value_as<Maximum>() const {
  return value_as_Maximum();
}

template<> inline const Minimum *Primitive::value_as<Minimum>() const {
  return value_as_Minimum();
}

template<> inline const PReLU *Primitive::value_as<PReLU>() const {
  return value_as_PReLU();
}

template<> inline const LeakyReLU *Primitive::value_as<LeakyReLU>() const {
  return value_as_LeakyReLU();
}

template<> inline const ArgMax *Primitive::value_as<ArgMax>() const {
  return value_as_ArgMax();
}

template<> inline const ArgMin *Primitive::value_as<ArgMin>() const {
  return value_as_ArgMin();
}

template<> inline const Exp *Primitive::value_as<Exp>() const {
  return value_as_Exp();
}

template<> inline const Crop *Primitive::value_as<Crop>() const {
  return value_as_Crop();
}

template<> inline const Range *Primitive::value_as<Range>() const {
  return value_as_Range();
}

template<> inline const Rsqrt *Primitive::value_as<Rsqrt>() const {
  return value_as_Rsqrt();
}

template<> inline const ExpandDims *Primitive::value_as<ExpandDims>() const {
  return value_as_ExpandDims();
}

template<> inline const Tile *Primitive::value_as<Tile>() const {
  return value_as_Tile();
}

template<> inline const Cast *Primitive::value_as<Cast>() const {
  return value_as_Cast();
}

template<> inline const Shape *Primitive::value_as<Shape>() const {
  return value_as_Shape();
}

template<> inline const Nchw2Nhwc *Primitive::value_as<Nchw2Nhwc>() const {
  return value_as_Nchw2Nhwc();
}

template<> inline const Nhwc2Nchw *Primitive::value_as<Nhwc2Nchw>() const {
  return value_as_Nhwc2Nchw();
}

template<> inline const QuantDTypeCast *Primitive::value_as<QuantDTypeCast>() const {
  return value_as_QuantDTypeCast();
}

template<> inline const Split *Primitive::value_as<Split>() const {
  return value_as_Split();
}

template<> inline const Permute *Primitive::value_as<Permute>() const {
  return value_as_Permute();
}

template<> inline const FakeQuantWithMinMaxVars *Primitive::value_as<FakeQuantWithMinMaxVars>() const {
  return value_as_FakeQuantWithMinMaxVars();
}

template<> inline const Equal *Primitive::value_as<Equal>() const {
  return value_as_Equal();
}

template<> inline const Less *Primitive::value_as<Less>() const {
  return value_as_Less();
}

template<> inline const Greater *Primitive::value_as<Greater>() const {
  return value_as_Greater();
}

template<> inline const NotEqual *Primitive::value_as<NotEqual>() const {
  return value_as_NotEqual();
}

template<> inline const LessEqual *Primitive::value_as<LessEqual>() const {
  return value_as_LessEqual();
}

template<> inline const GreaterEqual *Primitive::value_as<GreaterEqual>() const {
  return value_as_GreaterEqual();
}

template<> inline const Min *Primitive::value_as<Min>() const {
  return value_as_Min();
}

template<> inline const Floor *Primitive::value_as<Floor>() const {
  return value_as_Floor();
}

template<> inline const Abs *Primitive::value_as<Abs>() const {
  return value_as_Abs();
}

template<> inline const Neg *Primitive::value_as<Neg>() const {
  return value_as_Neg();
}

template<> inline const Cos *Primitive::value_as<Cos>() const {
  return value_as_Cos();
}

template<> inline const Sin *Primitive::value_as<Sin>() const {
  return value_as_Sin();
}

template<> inline const Sqrt *Primitive::value_as<Sqrt>() const {
  return value_as_Sqrt();
}

template<> inline const Square *Primitive::value_as<Square>() const {
  return value_as_Square();
}

template<> inline const Constant *Primitive::value_as<Constant>() const {
  return value_as_Constant();
}

template<> inline const Log *Primitive::value_as<Log>() const {
  return value_as_Log();
}

template<> inline const Tan *Primitive::value_as<Tan>() const {
  return value_as_Tan();
}

template<> inline const Atan *Primitive::value_as<Atan>() const {
  return value_as_Atan();
}

template<> inline const Asin *Primitive::value_as<Asin>() const {
  return value_as_Asin();
}

template<> inline const Clip *Primitive::value_as<Clip>() const {
  return value_as_Clip();
}

template<> inline const Transpose *Primitive::value_as<Transpose>() const {
  return value_as_Transpose();
}

template<> inline const Squeeze *Primitive::value_as<Squeeze>() const {
  return value_as_Squeeze();
}

template<> inline const Unsqueeze *Primitive::value_as<Unsqueeze>() const {
  return value_as_Unsqueeze();
}

template<> inline const Upsample *Primitive::value_as<Upsample>() const {
  return value_as_Upsample();
}

template<> inline const Dropout *Primitive::value_as<Dropout>() const {
  return value_as_Dropout();
}

template<> inline const Broadcast *Primitive::value_as<Broadcast>() const {
  return value_as_Broadcast();
}

template<> inline const BroadcastTo *Primitive::value_as<BroadcastTo>() const {
  return value_as_BroadcastTo();
}

template<> inline const Lrn *Primitive::value_as<Lrn>() const {
  return value_as_Lrn();
}

template<> inline const ZerosLike *Primitive::value_as<ZerosLike>() const {
  return value_as_ZerosLike();
}

template<> inline const TopK *Primitive::value_as<TopK>() const {
  return value_as_TopK();
}

template<> inline const SpaceToDepth *Primitive::value_as<SpaceToDepth>() const {
  return value_as_SpaceToDepth();
}

template<> inline const SpaceToBatch *Primitive::value_as<SpaceToBatch>() const {
  return value_as_SpaceToBatch();
}

template<> inline const SparseToDense *Primitive::value_as<SparseToDense>() const {
  return value_as_SparseToDense();
}

template<> inline const ReverseSequence *Primitive::value_as<ReverseSequence>() const {
  return value_as_ReverseSequence();
}

template<> inline const Rank *Primitive::value_as<Rank>() const {
  return value_as_Rank();
}

template<> inline const Gather *Primitive::value_as<Gather>() const {
  return value_as_Gather();
}

template<> inline const GatherNd *Primitive::value_as<GatherNd>() const {
  return value_as_GatherNd();
}

template<> inline const Fill *Primitive::value_as<Fill>() const {
  return value_as_Fill();
}

template<> inline const Elu *Primitive::value_as<Elu>() const {
  return value_as_Elu();
}

template<> inline const DepthToSpace *Primitive::value_as<DepthToSpace>() const {
  return value_as_DepthToSpace();
}

template<> inline const BatchToSpace *Primitive::value_as<BatchToSpace>() const {
  return value_as_BatchToSpace();
}

template<> inline const AddN *Primitive::value_as<AddN>() const {
  return value_as_AddN();
}

template<> inline const Ceil *Primitive::value_as<Ceil>() const {
  return value_as_Ceil();
}

template<> inline const EmbeddingLookup *Primitive::value_as<EmbeddingLookup>() const {
  return value_as_EmbeddingLookup();
}

template<> inline const EmbeddingLookupSparse *Primitive::value_as<EmbeddingLookupSparse>() const {
  return value_as_EmbeddingLookupSparse();
}

template<> inline const FloorDiv *Primitive::value_as<FloorDiv>() const {
  return value_as_FloorDiv();
}

template<> inline const FloorMod *Primitive::value_as<FloorMod>() const {
  return value_as_FloorMod();
}

template<> inline const L2Norm *Primitive::value_as<L2Norm>() const {
  return value_as_L2Norm();
}

template<> inline const LocalResponseNormalization *Primitive::value_as<LocalResponseNormalization>() const {
  return value_as_LocalResponseNormalization();
}

template<> inline const MatrixDiag *Primitive::value_as<MatrixDiag>() const {
  return value_as_MatrixDiag();
}

template<> inline const Reduce *Primitive::value_as<Reduce>() const {
  return value_as_Reduce();
}

template<> inline const Reverse *Primitive::value_as<Reverse>() const {
  return value_as_Reverse();
}

template<> inline const Round *Primitive::value_as<Round>() const {
  return value_as_Round();
}

template<> inline const Select *Primitive::value_as<Select>() const {
  return value_as_Select();
}

template<> inline const Scatter *Primitive::value_as<Scatter>() const {
  return value_as_Scatter();
}

template<> inline const ScatterND *Primitive::value_as<ScatterND>() const {
  return value_as_ScatterND();
}

template<> inline const ConstantOfShape *Primitive::value_as<ConstantOfShape>() const {
  return value_as_ConstantOfShape();
}

template<> inline const Unique *Primitive::value_as<Unique>() const {
  return value_as_Unique();
}

template<> inline const Unstack *Primitive::value_as<Unstack>() const {
  return value_as_Unstack();
}

template<> inline const LogicalAnd *Primitive::value_as<LogicalAnd>() const {
  return value_as_LogicalAnd();
}

template<> inline const LogicalOr *Primitive::value_as<LogicalOr>() const {
  return value_as_LogicalOr();
}

template<> inline const LogicalXor *Primitive::value_as<LogicalXor>() const {
  return value_as_LogicalXor();
}

template<> inline const LogicalNot *Primitive::value_as<LogicalNot>() const {
  return value_as_LogicalNot();
}

template<> inline const OnnxInt8Quantize *Primitive::value_as<OnnxInt8Quantize>() const {
  return value_as_OnnxInt8Quantize();
}

template<> inline const OnnxInt8Dequantize *Primitive::value_as<OnnxInt8Dequantize>() const {
  return value_as_OnnxInt8Dequantize();
}

template<> inline const FakeQuantWithMinMax *Primitive::value_as<FakeQuantWithMinMax>() const {
  return value_as_FakeQuantWithMinMax();
}

template<> inline const FakeQuantWithMinMaxPerChannel *Primitive::value_as<FakeQuantWithMinMaxPerChannel>() const {
  return value_as_FakeQuantWithMinMaxPerChannel();
}

template<> inline const BatchNormFold *Primitive::value_as<BatchNormFold>() const {
  return value_as_BatchNormFold();
}

template<> inline const MulFold *Primitive::value_as<MulFold>() const {
  return value_as_MulFold();
}

template<> inline const AddFold *Primitive::value_as<AddFold>() const {
  return value_as_AddFold();
}

template<> inline const SquaredDifference *Primitive::value_as<SquaredDifference>() const {
  return value_as_SquaredDifference();
}

template<> inline const Flatten *Primitive::value_as<Flatten>() const {
  return value_as_Flatten();
}

template<> inline const FlattenGrad *Primitive::value_as<FlattenGrad>() const {
  return value_as_FlattenGrad();
}

template<> inline const TupleGetItem *Primitive::value_as<TupleGetItem>() const {
  return value_as_TupleGetItem();
}

template<> inline const Div *Primitive::value_as<Div>() const {
  return value_as_Div();
}

template<> inline const Where *Primitive::value_as<Where>() const {
  return value_as_Where();
}

template<> inline const OneHot *Primitive::value_as<OneHot>() const {
  return value_as_OneHot();
}

template<> inline const Lstm *Primitive::value_as<Lstm>() const {
  return value_as_Lstm();
}

template<> inline const Conv2DGradFilter *Primitive::value_as<Conv2DGradFilter>() const {
  return value_as_Conv2DGradFilter();
}

template<> inline const Conv2DGradInput *Primitive::value_as<Conv2DGradInput>() const {
  return value_as_Conv2DGradInput();
}

template<> inline const PoolingGrad *Primitive::value_as<PoolingGrad>() const {
  return value_as_PoolingGrad();
}

template<> inline const BNGrad *Primitive::value_as<BNGrad>() const {
  return value_as_BNGrad();
}

template<> inline const Assign *Primitive::value_as<Assign>() const {
  return value_as_Assign();
}

template<> inline const ApplyMomentum *Primitive::value_as<ApplyMomentum>() const {
  return value_as_ApplyMomentum();
}

template<> inline const BiasGrad *Primitive::value_as<BiasGrad>() const {
  return value_as_BiasGrad();
}

template<> inline const SoftmaxCrossEntropy *Primitive::value_as<SoftmaxCrossEntropy>() const {
  return value_as_SoftmaxCrossEntropy();
}

template<> inline const AddGrad *Primitive::value_as<AddGrad>() const {
  return value_as_AddGrad();
}

template<> inline const SubGrad *Primitive::value_as<SubGrad>() const {
  return value_as_SubGrad();
}

template<> inline const MulGrad *Primitive::value_as<MulGrad>() const {
  return value_as_MulGrad();
}

template<> inline const DivGrad *Primitive::value_as<DivGrad>() const {
  return value_as_DivGrad();
}

template<> inline const PowerGrad *Primitive::value_as<PowerGrad>() const {
  return value_as_PowerGrad();
}

template<> inline const ActivationGrad *Primitive::value_as<ActivationGrad>() const {
  return value_as_ActivationGrad();
}

template<> inline const PriorBox *Primitive::value_as<PriorBox>() const {
  return value_as_PriorBox();
}

template<> inline const SpaceToBatchND *Primitive::value_as<SpaceToBatchND>() const {
  return value_as_SpaceToBatchND();
}

template<> inline const Depend *Primitive::value_as<Depend>() const {
  return value_as_Depend();
}

template<> inline const Return *Primitive::value_as<Return>() const {
  return value_as_Return();
}

template<> inline const MakeTuple *Primitive::value_as<MakeTuple>() const {
  return value_as_MakeTuple();
}

template<> inline const ToFormat *Primitive::value_as<ToFormat>() const {
  return value_as_ToFormat();
}

template<> inline const Proposal *Primitive::value_as<Proposal>() const {
  return value_as_Proposal();
}

template<> inline const Custom *Primitive::value_as<Custom>() const {
  return value_as_Custom();
}

template<> inline const BlackBox *Primitive::value_as<BlackBox>() const {
  return value_as_BlackBox();
}

template<> inline const NegGrad *Primitive::value_as<NegGrad>() const {
  return value_as_NegGrad();
}

template<> inline const LogGrad *Primitive::value_as<LogGrad>() const {
  return value_as_LogGrad();
}

template<> inline const BatchToSpaceND *Primitive::value_as<BatchToSpaceND>() const {
  return value_as_BatchToSpaceND();
}

template<> inline const LshProjection *Primitive::value_as<LshProjection>() const {
  return value_as_LshProjection();
}

template<> inline const HashtableLookup *Primitive::value_as<HashtableLookup>() const {
  return value_as_HashtableLookup();
}

template<> inline const SkipGram *Primitive::value_as<SkipGram>() const {
  return value_as_SkipGram();
}

template<> inline const DeConv2DGradFilter *Primitive::value_as<DeConv2DGradFilter>() const {
  return value_as_DeConv2DGradFilter();
}

template<> inline const CustomPredict *Primitive::value_as<CustomPredict>() const {
  return value_as_CustomPredict();
}

template<> inline const CustomNormalize *Primitive::value_as<CustomNormalize>() const {
  return value_as_CustomNormalize();
}

template<> inline const CustomExtractFeatures *Primitive::value_as<CustomExtractFeatures>() const {
  return value_as_CustomExtractFeatures();
}

template<> inline const AudioSpectrogram *Primitive::value_as<AudioSpectrogram>() const {
  return value_as_AudioSpectrogram();
}

template<> inline const Mfcc *Primitive::value_as<Mfcc>() const {
  return value_as_Mfcc();
}

template<> inline const Rfft *Primitive::value_as<Rfft>() const {
  return value_as_Rfft();
}

template<> inline const FftReal *Primitive::value_as<FftReal>() const {
  return value_as_FftReal();
}

template<> inline const FftImag *Primitive::value_as<FftImag>() const {
  return value_as_FftImag();
}

template<> inline const Sgd *Primitive::value_as<Sgd>() const {
  return value_as_Sgd();
}

template<> inline const Adam *Primitive::value_as<Adam>() const {
  return value_as_Adam();
}

template<> inline const GroupConv2DGradInput *Primitive::value_as<GroupConv2DGradInput>() const {
  return value_as_GroupConv2DGradInput();
}

template<> inline const Loop *Primitive::value_as<Loop>() const {
  return value_as_Loop();
}

template<> inline const NonMaxSuppression *Primitive::value_as<NonMaxSuppression>() const {
  return value_as_NonMaxSuppression();
}

template<> inline const InstanceNorm *Primitive::value_as<InstanceNorm>() const {
  return value_as_InstanceNorm();
}

template<> inline const Identity *Primitive::value_as<Identity>() const {
  return value_as_Identity();
}

template<> inline const LayerNorm *Primitive::value_as<LayerNorm>() const {
  return value_as_LayerNorm();
}

template<> inline const While *Primitive::value_as<While>() const {
  return value_as_While();
}

template<> inline const ControlDepend *Primitive::value_as<ControlDepend>() const {
  return value_as_ControlDepend();
}

template<> inline const UnsortedSegmentSum *Primitive::value_as<UnsortedSegmentSum>() const {
  return value_as_UnsortedSegmentSum();
}

template<> inline const AssignAdd *Primitive::value_as<AssignAdd>() const {
  return value_as_AssignAdd();
}

template<> inline const OnesLike *Primitive::value_as<OnesLike>() const {
  return value_as_OnesLike();
}

template<> inline const BinaryCrossEntropyGrad *Primitive::value_as<BinaryCrossEntropyGrad>() const {
  return value_as_BinaryCrossEntropyGrad();
}

template<> inline const BinaryCrossEntropy *Primitive::value_as<BinaryCrossEntropy>() const {
  return value_as_BinaryCrossEntropy();
}

template<> inline const LpNormalization *Primitive::value_as<LpNormalization>() const {
  return value_as_LpNormalization();
}

template<> inline const DropoutGrad *Primitive::value_as<DropoutGrad>() const {
  return value_as_DropoutGrad();
}

template<> inline const MaximumGrad *Primitive::value_as<MaximumGrad>() const {
  return value_as_MaximumGrad();
}

template<> inline const MinimumGrad *Primitive::value_as<MinimumGrad>() const {
  return value_as_MinimumGrad();
}

template<> inline const Switch *Primitive::value_as<Switch>() const {
  return value_as_Switch();
}

template<> inline const Partial *Primitive::value_as<Partial>() const {
  return value_as_Partial();
}

template<> inline const TensorListFromTensor *Primitive::value_as<TensorListFromTensor>() const {
  return value_as_TensorListFromTensor();
}

template<> inline const TensorListStack *Primitive::value_as<TensorListStack>() const {
  return value_as_TensorListStack();
}

template<> inline const TensorListGetItem *Primitive::value_as<TensorListGetItem>() const {
  return value_as_TensorListGetItem();
}

template<> inline const TensorListSetItem *Primitive::value_as<TensorListSetItem>() const {
  return value_as_TensorListSetItem();
}

template<> inline const TensorListReserve *Primitive::value_as<TensorListReserve>() const {
  return value_as_TensorListReserve();
}

template<> inline const All *Primitive::value_as<All>() const {
  return value_as_All();
}

template<> inline const Assert *Primitive::value_as<Assert>() const {
  return value_as_Assert();
}

template<> inline const Adder *Primitive::value_as<Adder>() const {
  return value_as_Adder();
}

template<> inline const SparseSoftmaxCrossEntropy *Primitive::value_as<SparseSoftmaxCrossEntropy>() const {
  return value_as_SparseSoftmaxCrossEntropy();
}

template<> inline const SmoothL1Loss *Primitive::value_as<SmoothL1Loss>() const {
  return value_as_SmoothL1Loss();
}

template<> inline const SmoothL1LossGrad *Primitive::value_as<SmoothL1LossGrad>() const {
  return value_as_SmoothL1LossGrad();
}

template<> inline const SigmoidCrossEntropyWithLogits *Primitive::value_as<SigmoidCrossEntropyWithLogits>() const {
  return value_as_SigmoidCrossEntropyWithLogits();
}

template<> inline const SigmoidCrossEntropyWithLogitsGrad *Primitive::value_as<SigmoidCrossEntropyWithLogitsGrad>() const {
  return value_as_SigmoidCrossEntropyWithLogitsGrad();
}

template<> inline const Reciprocal *Primitive::value_as<Reciprocal>() const {
  return value_as_Reciprocal();
}

template<> inline const Merge *Primitive::value_as<Merge>() const {
  return value_as_Merge();
}

template<> inline const Mod *Primitive::value_as<Mod>() const {
  return value_as_Mod();
}

template<> inline const GeLU *Primitive::value_as<GeLU>() const {
  return value_as_GeLU();
}

struct PrimitiveBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value_type(PrimitiveType value_type) {
    fbb_.AddElement<uint8_t>(Primitive::VT_VALUE_TYPE, static_cast<uint8_t>(value_type), 0);
  }
  void add_value(flatbuffers::Offset<void> value) {
    fbb_.AddOffset(Primitive::VT_VALUE, value);
  }
  explicit PrimitiveBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  PrimitiveBuilder &operator=(const PrimitiveBuilder &);
  flatbuffers::Offset<Primitive> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Primitive>(end);
    return o;
  }
};

inline flatbuffers::Offset<Primitive> CreatePrimitive(
    flatbuffers::FlatBufferBuilder &_fbb,
    PrimitiveType value_type = PrimitiveType_NONE,
    flatbuffers::Offset<void> value = 0) {
  PrimitiveBuilder builder_(_fbb);
  builder_.add_value(value);
  builder_.add_value_type(value_type);
  return builder_.Finish();
}

struct CNode FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_NODETYPE = 6,
    VT_PRIMITIVE = 8,
    VT_INPUTINDEX = 10,
    VT_OUTPUTINDEX = 12,
    VT_QUANTTYPE = 14
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  NodeType nodeType() const {
    return static_cast<NodeType>(GetField<int32_t>(VT_NODETYPE, 2));
  }
  const Primitive *primitive() const {
    return GetPointer<const Primitive *>(VT_PRIMITIVE);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  QuantType quantType() const {
    return static_cast<QuantType>(GetField<int32_t>(VT_QUANTTYPE, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<int32_t>(verifier, VT_NODETYPE) &&
           VerifyOffset(verifier, VT_PRIMITIVE) &&
           verifier.VerifyTable(primitive()) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<int32_t>(verifier, VT_QUANTTYPE) &&
           verifier.EndTable();
  }
};

struct CNodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CNode::VT_NAME, name);
  }
  void add_nodeType(NodeType nodeType) {
    fbb_.AddElement<int32_t>(CNode::VT_NODETYPE, static_cast<int32_t>(nodeType), 2);
  }
  void add_primitive(flatbuffers::Offset<Primitive> primitive) {
    fbb_.AddOffset(CNode::VT_PRIMITIVE, primitive);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(CNode::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(CNode::VT_OUTPUTINDEX, outputIndex);
  }
  void add_quantType(QuantType quantType) {
    fbb_.AddElement<int32_t>(CNode::VT_QUANTTYPE, static_cast<int32_t>(quantType), 0);
  }
  explicit CNodeBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  CNodeBuilder &operator=(const CNodeBuilder &);
  flatbuffers::Offset<CNode> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CNode>(end);
    return o;
  }
};

inline flatbuffers::Offset<CNode> CreateCNode(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    NodeType nodeType = NodeType_CNode,
    flatbuffers::Offset<Primitive> primitive = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    QuantType quantType = QuantType_QUANT_NONE) {
  CNodeBuilder builder_(_fbb);
  builder_.add_quantType(quantType);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_primitive(primitive);
  builder_.add_nodeType(nodeType);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<CNode> CreateCNodeDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    NodeType nodeType = NodeType_CNode,
    flatbuffers::Offset<Primitive> primitive = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    QuantType quantType = QuantType_QUANT_NONE) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  return mindspore::schema::CreateCNode(
      _fbb,
      name__,
      nodeType,
      primitive,
      inputIndex__,
      outputIndex__,
      quantType);
}

struct SubGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_INPUTINDICES = 6,
    VT_OUTPUTINDICES = 8,
    VT_NODEINDICES = 10,
    VT_TENSORINDICES = 12
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::Vector<uint32_t> *inputIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDICES);
  }
  const flatbuffers::Vector<uint32_t> *outputIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDICES);
  }
  const flatbuffers::Vector<uint32_t> *nodeIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_NODEINDICES);
  }
  const flatbuffers::Vector<uint32_t> *tensorIndices() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_TENSORINDICES);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_INPUTINDICES) &&
           verifier.VerifyVector(inputIndices()) &&
           VerifyOffset(verifier, VT_OUTPUTINDICES) &&
           verifier.VerifyVector(outputIndices()) &&
           VerifyOffset(verifier, VT_NODEINDICES) &&
           verifier.VerifyVector(nodeIndices()) &&
           VerifyOffset(verifier, VT_TENSORINDICES) &&
           verifier.VerifyVector(tensorIndices()) &&
           verifier.EndTable();
  }
};

struct SubGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(SubGraph::VT_NAME, name);
  }
  void add_inputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices) {
    fbb_.AddOffset(SubGraph::VT_INPUTINDICES, inputIndices);
  }
  void add_outputIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices) {
    fbb_.AddOffset(SubGraph::VT_OUTPUTINDICES, outputIndices);
  }
  void add_nodeIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices) {
    fbb_.AddOffset(SubGraph::VT_NODEINDICES, nodeIndices);
  }
  void add_tensorIndices(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices) {
    fbb_.AddOffset(SubGraph::VT_TENSORINDICES, tensorIndices);
  }
  explicit SubGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  SubGraphBuilder &operator=(const SubGraphBuilder &);
  flatbuffers::Offset<SubGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SubGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<SubGraph> CreateSubGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> nodeIndices = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> tensorIndices = 0) {
  SubGraphBuilder builder_(_fbb);
  builder_.add_tensorIndices(tensorIndices);
  builder_.add_nodeIndices(nodeIndices);
  builder_.add_outputIndices(outputIndices);
  builder_.add_inputIndices(inputIndices);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<SubGraph> CreateSubGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const std::vector<uint32_t> *inputIndices = nullptr,
    const std::vector<uint32_t> *outputIndices = nullptr,
    const std::vector<uint32_t> *nodeIndices = nullptr,
    const std::vector<uint32_t> *tensorIndices = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto inputIndices__ = inputIndices ? _fbb.CreateVector<uint32_t>(*inputIndices) : 0;
  auto outputIndices__ = outputIndices ? _fbb.CreateVector<uint32_t>(*outputIndices) : 0;
  auto nodeIndices__ = nodeIndices ? _fbb.CreateVector<uint32_t>(*nodeIndices) : 0;
  auto tensorIndices__ = tensorIndices ? _fbb.CreateVector<uint32_t>(*tensorIndices) : 0;
  return mindspore::schema::CreateSubGraph(
      _fbb,
      name__,
      inputIndices__,
      outputIndices__,
      nodeIndices__,
      tensorIndices__);
}

struct MetaGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_VERSION = 6,
    VT_FMKTYPE = 8,
    VT_INPUTINDEX = 10,
    VT_OUTPUTINDEX = 12,
    VT_MEMPOOLSIZE = 14,
    VT_NODES = 16,
    VT_ALLTENSORS = 18,
    VT_SUBGRAPH = 20
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  const flatbuffers::String *version() const {
    return GetPointer<const flatbuffers::String *>(VT_VERSION);
  }
  int32_t fmkType() const {
    return GetField<int32_t>(VT_FMKTYPE, 0);
  }
  const flatbuffers::Vector<uint32_t> *inputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_INPUTINDEX);
  }
  const flatbuffers::Vector<uint32_t> *outputIndex() const {
    return GetPointer<const flatbuffers::Vector<uint32_t> *>(VT_OUTPUTINDEX);
  }
  uint32_t mempoolSize() const {
    return GetField<uint32_t>(VT_MEMPOOLSIZE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<CNode>> *nodes() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CNode>> *>(VT_NODES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *allTensors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Tensor>> *>(VT_ALLTENSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *subGraph() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SubGraph>> *>(VT_SUBGRAPH);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyOffset(verifier, VT_VERSION) &&
           verifier.VerifyString(version()) &&
           VerifyField<int32_t>(verifier, VT_FMKTYPE) &&
           VerifyOffset(verifier, VT_INPUTINDEX) &&
           verifier.VerifyVector(inputIndex()) &&
           VerifyOffset(verifier, VT_OUTPUTINDEX) &&
           verifier.VerifyVector(outputIndex()) &&
           VerifyField<uint32_t>(verifier, VT_MEMPOOLSIZE) &&
           VerifyOffset(verifier, VT_NODES) &&
           verifier.VerifyVector(nodes()) &&
           verifier.VerifyVectorOfTables(nodes()) &&
           VerifyOffset(verifier, VT_ALLTENSORS) &&
           verifier.VerifyVector(allTensors()) &&
           verifier.VerifyVectorOfTables(allTensors()) &&
           VerifyOffset(verifier, VT_SUBGRAPH) &&
           verifier.VerifyVector(subGraph()) &&
           verifier.VerifyVectorOfTables(subGraph()) &&
           verifier.EndTable();
  }
};

struct MetaGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(MetaGraph::VT_NAME, name);
  }
  void add_version(flatbuffers::Offset<flatbuffers::String> version) {
    fbb_.AddOffset(MetaGraph::VT_VERSION, version);
  }
  void add_fmkType(int32_t fmkType) {
    fbb_.AddElement<int32_t>(MetaGraph::VT_FMKTYPE, fmkType, 0);
  }
  void add_inputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex) {
    fbb_.AddOffset(MetaGraph::VT_INPUTINDEX, inputIndex);
  }
  void add_outputIndex(flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex) {
    fbb_.AddOffset(MetaGraph::VT_OUTPUTINDEX, outputIndex);
  }
  void add_mempoolSize(uint32_t mempoolSize) {
    fbb_.AddElement<uint32_t>(MetaGraph::VT_MEMPOOLSIZE, mempoolSize, 0);
  }
  void add_nodes(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CNode>>> nodes) {
    fbb_.AddOffset(MetaGraph::VT_NODES, nodes);
  }
  void add_allTensors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> allTensors) {
    fbb_.AddOffset(MetaGraph::VT_ALLTENSORS, allTensors);
  }
  void add_subGraph(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subGraph) {
    fbb_.AddOffset(MetaGraph::VT_SUBGRAPH, subGraph);
  }
  explicit MetaGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  MetaGraphBuilder &operator=(const MetaGraphBuilder &);
  flatbuffers::Offset<MetaGraph> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MetaGraph>(end);
    return o;
  }
};

inline flatbuffers::Offset<MetaGraph> CreateMetaGraph(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    int32_t fmkType = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> inputIndex = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint32_t>> outputIndex = 0,
    uint32_t mempoolSize = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CNode>>> nodes = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Tensor>>> allTensors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SubGraph>>> subGraph = 0) {
  MetaGraphBuilder builder_(_fbb);
  builder_.add_subGraph(subGraph);
  builder_.add_allTensors(allTensors);
  builder_.add_nodes(nodes);
  builder_.add_mempoolSize(mempoolSize);
  builder_.add_outputIndex(outputIndex);
  builder_.add_inputIndex(inputIndex);
  builder_.add_fmkType(fmkType);
  builder_.add_version(version);
  builder_.add_name(name);
  return builder_.Finish();
}

inline flatbuffers::Offset<MetaGraph> CreateMetaGraphDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *version = nullptr,
    int32_t fmkType = 0,
    const std::vector<uint32_t> *inputIndex = nullptr,
    const std::vector<uint32_t> *outputIndex = nullptr,
    uint32_t mempoolSize = 0,
    const std::vector<flatbuffers::Offset<CNode>> *nodes = nullptr,
    const std::vector<flatbuffers::Offset<Tensor>> *allTensors = nullptr,
    const std::vector<flatbuffers::Offset<SubGraph>> *subGraph = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto version__ = version ? _fbb.CreateString(version) : 0;
  auto inputIndex__ = inputIndex ? _fbb.CreateVector<uint32_t>(*inputIndex) : 0;
  auto outputIndex__ = outputIndex ? _fbb.CreateVector<uint32_t>(*outputIndex) : 0;
  auto nodes__ = nodes ? _fbb.CreateVector<flatbuffers::Offset<CNode>>(*nodes) : 0;
  auto allTensors__ = allTensors ? _fbb.CreateVector<flatbuffers::Offset<Tensor>>(*allTensors) : 0;
  auto subGraph__ = subGraph ? _fbb.CreateVector<flatbuffers::Offset<SubGraph>>(*subGraph) : 0;
  return mindspore::schema::CreateMetaGraph(
      _fbb,
      name__,
      version__,
      fmkType,
      inputIndex__,
      outputIndex__,
      mempoolSize,
      nodes__,
      allTensors__,
      subGraph__);
}

inline bool VerifyPrimitiveType(flatbuffers::Verifier &verifier, const void *obj, PrimitiveType type) {
  switch (type) {
    case PrimitiveType_NONE: {
      return true;
    }
    case PrimitiveType_Concat: {
      auto ptr = reinterpret_cast<const Concat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftMax: {
      auto ptr = reinterpret_cast<const SoftMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Activation: {
      auto ptr = reinterpret_cast<const Activation *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2D: {
      auto ptr = reinterpret_cast<const Conv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FusedBatchNorm: {
      auto ptr = reinterpret_cast<const FusedBatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNorm: {
      auto ptr = reinterpret_cast<const BatchNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasAdd: {
      auto ptr = reinterpret_cast<const BiasAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pooling: {
      auto ptr = reinterpret_cast<const Pooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ROIPooling: {
      auto ptr = reinterpret_cast<const ROIPooling *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthwiseConv2D: {
      auto ptr = reinterpret_cast<const DepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeDepthwiseConv2D: {
      auto ptr = reinterpret_cast<const DeDepthwiseConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Resize: {
      auto ptr = reinterpret_cast<const Resize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DetectionPostProcess: {
      auto ptr = reinterpret_cast<const DetectionPostProcess *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FullConnection: {
      auto ptr = reinterpret_cast<const FullConnection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mean: {
      auto ptr = reinterpret_cast<const Mean *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2D: {
      auto ptr = reinterpret_cast<const DeConv2D *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scale: {
      auto ptr = reinterpret_cast<const Scale *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reshape: {
      auto ptr = reinterpret_cast<const Reshape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Eltwise: {
      auto ptr = reinterpret_cast<const Eltwise *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NetOutput: {
      auto ptr = reinterpret_cast<const NetOutput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Add: {
      auto ptr = reinterpret_cast<const Add *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sub: {
      auto ptr = reinterpret_cast<const Sub *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatMul: {
      auto ptr = reinterpret_cast<const MatMul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_StridedSlice: {
      auto ptr = reinterpret_cast<const StridedSlice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Power: {
      auto ptr = reinterpret_cast<const Power *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Slice: {
      auto ptr = reinterpret_cast<const Slice *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Stack: {
      auto ptr = reinterpret_cast<const Stack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mul: {
      auto ptr = reinterpret_cast<const Mul *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_RealDiv: {
      auto ptr = reinterpret_cast<const RealDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Pad: {
      auto ptr = reinterpret_cast<const Pad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Maximum: {
      auto ptr = reinterpret_cast<const Maximum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Minimum: {
      auto ptr = reinterpret_cast<const Minimum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PReLU: {
      auto ptr = reinterpret_cast<const PReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LeakyReLU: {
      auto ptr = reinterpret_cast<const LeakyReLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMax: {
      auto ptr = reinterpret_cast<const ArgMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ArgMin: {
      auto ptr = reinterpret_cast<const ArgMin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Exp: {
      auto ptr = reinterpret_cast<const Exp *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Crop: {
      auto ptr = reinterpret_cast<const Crop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Range: {
      auto ptr = reinterpret_cast<const Range *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rsqrt: {
      auto ptr = reinterpret_cast<const Rsqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ExpandDims: {
      auto ptr = reinterpret_cast<const ExpandDims *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tile: {
      auto ptr = reinterpret_cast<const Tile *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cast: {
      auto ptr = reinterpret_cast<const Cast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Shape: {
      auto ptr = reinterpret_cast<const Shape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nchw2Nhwc: {
      auto ptr = reinterpret_cast<const Nchw2Nhwc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Nhwc2Nchw: {
      auto ptr = reinterpret_cast<const Nhwc2Nchw *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_QuantDTypeCast: {
      auto ptr = reinterpret_cast<const QuantDTypeCast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Split: {
      auto ptr = reinterpret_cast<const Split *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Permute: {
      auto ptr = reinterpret_cast<const Permute *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxVars: {
      auto ptr = reinterpret_cast<const FakeQuantWithMinMaxVars *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Equal: {
      auto ptr = reinterpret_cast<const Equal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Less: {
      auto ptr = reinterpret_cast<const Less *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Greater: {
      auto ptr = reinterpret_cast<const Greater *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NotEqual: {
      auto ptr = reinterpret_cast<const NotEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LessEqual: {
      auto ptr = reinterpret_cast<const LessEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GreaterEqual: {
      auto ptr = reinterpret_cast<const GreaterEqual *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Min: {
      auto ptr = reinterpret_cast<const Min *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Floor: {
      auto ptr = reinterpret_cast<const Floor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Abs: {
      auto ptr = reinterpret_cast<const Abs *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Neg: {
      auto ptr = reinterpret_cast<const Neg *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Cos: {
      auto ptr = reinterpret_cast<const Cos *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sin: {
      auto ptr = reinterpret_cast<const Sin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sqrt: {
      auto ptr = reinterpret_cast<const Sqrt *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Square: {
      auto ptr = reinterpret_cast<const Square *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Constant: {
      auto ptr = reinterpret_cast<const Constant *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Log: {
      auto ptr = reinterpret_cast<const Log *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Tan: {
      auto ptr = reinterpret_cast<const Tan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Atan: {
      auto ptr = reinterpret_cast<const Atan *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Asin: {
      auto ptr = reinterpret_cast<const Asin *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Clip: {
      auto ptr = reinterpret_cast<const Clip *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Transpose: {
      auto ptr = reinterpret_cast<const Transpose *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Squeeze: {
      auto ptr = reinterpret_cast<const Squeeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unsqueeze: {
      auto ptr = reinterpret_cast<const Unsqueeze *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Upsample: {
      auto ptr = reinterpret_cast<const Upsample *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Dropout: {
      auto ptr = reinterpret_cast<const Dropout *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Broadcast: {
      auto ptr = reinterpret_cast<const Broadcast *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BroadcastTo: {
      auto ptr = reinterpret_cast<const BroadcastTo *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lrn: {
      auto ptr = reinterpret_cast<const Lrn *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ZerosLike: {
      auto ptr = reinterpret_cast<const ZerosLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TopK: {
      auto ptr = reinterpret_cast<const TopK *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToDepth: {
      auto ptr = reinterpret_cast<const SpaceToDepth *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatch: {
      auto ptr = reinterpret_cast<const SpaceToBatch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseToDense: {
      auto ptr = reinterpret_cast<const SparseToDense *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ReverseSequence: {
      auto ptr = reinterpret_cast<const ReverseSequence *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rank: {
      auto ptr = reinterpret_cast<const Rank *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Gather: {
      auto ptr = reinterpret_cast<const Gather *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GatherNd: {
      auto ptr = reinterpret_cast<const GatherNd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Fill: {
      auto ptr = reinterpret_cast<const Fill *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Elu: {
      auto ptr = reinterpret_cast<const Elu *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DepthToSpace: {
      auto ptr = reinterpret_cast<const DepthToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpace: {
      auto ptr = reinterpret_cast<const BatchToSpace *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddN: {
      auto ptr = reinterpret_cast<const AddN *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Ceil: {
      auto ptr = reinterpret_cast<const Ceil *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookup: {
      auto ptr = reinterpret_cast<const EmbeddingLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_EmbeddingLookupSparse: {
      auto ptr = reinterpret_cast<const EmbeddingLookupSparse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorDiv: {
      auto ptr = reinterpret_cast<const FloorDiv *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FloorMod: {
      auto ptr = reinterpret_cast<const FloorMod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_L2Norm: {
      auto ptr = reinterpret_cast<const L2Norm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LocalResponseNormalization: {
      auto ptr = reinterpret_cast<const LocalResponseNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MatrixDiag: {
      auto ptr = reinterpret_cast<const MatrixDiag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reduce: {
      auto ptr = reinterpret_cast<const Reduce *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reverse: {
      auto ptr = reinterpret_cast<const Reverse *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Round: {
      auto ptr = reinterpret_cast<const Round *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Select: {
      auto ptr = reinterpret_cast<const Select *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Scatter: {
      auto ptr = reinterpret_cast<const Scatter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ScatterND: {
      auto ptr = reinterpret_cast<const ScatterND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ConstantOfShape: {
      auto ptr = reinterpret_cast<const ConstantOfShape *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unique: {
      auto ptr = reinterpret_cast<const Unique *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Unstack: {
      auto ptr = reinterpret_cast<const Unstack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalAnd: {
      auto ptr = reinterpret_cast<const LogicalAnd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalOr: {
      auto ptr = reinterpret_cast<const LogicalOr *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalXor: {
      auto ptr = reinterpret_cast<const LogicalXor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogicalNot: {
      auto ptr = reinterpret_cast<const LogicalNot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Quantize: {
      auto ptr = reinterpret_cast<const OnnxInt8Quantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnnxInt8Dequantize: {
      auto ptr = reinterpret_cast<const OnnxInt8Dequantize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMax: {
      auto ptr = reinterpret_cast<const FakeQuantWithMinMax *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FakeQuantWithMinMaxPerChannel: {
      auto ptr = reinterpret_cast<const FakeQuantWithMinMaxPerChannel *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchNormFold: {
      auto ptr = reinterpret_cast<const BatchNormFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulFold: {
      auto ptr = reinterpret_cast<const MulFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddFold: {
      auto ptr = reinterpret_cast<const AddFold *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SquaredDifference: {
      auto ptr = reinterpret_cast<const SquaredDifference *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Flatten: {
      auto ptr = reinterpret_cast<const Flatten *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FlattenGrad: {
      auto ptr = reinterpret_cast<const FlattenGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TupleGetItem: {
      auto ptr = reinterpret_cast<const TupleGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Div: {
      auto ptr = reinterpret_cast<const Div *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Where: {
      auto ptr = reinterpret_cast<const Where *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OneHot: {
      auto ptr = reinterpret_cast<const OneHot *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Lstm: {
      auto ptr = reinterpret_cast<const Lstm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradFilter: {
      auto ptr = reinterpret_cast<const Conv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Conv2DGradInput: {
      auto ptr = reinterpret_cast<const Conv2DGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PoolingGrad: {
      auto ptr = reinterpret_cast<const PoolingGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BNGrad: {
      auto ptr = reinterpret_cast<const BNGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assign: {
      auto ptr = reinterpret_cast<const Assign *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ApplyMomentum: {
      auto ptr = reinterpret_cast<const ApplyMomentum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BiasGrad: {
      auto ptr = reinterpret_cast<const BiasGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const SoftmaxCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AddGrad: {
      auto ptr = reinterpret_cast<const AddGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SubGrad: {
      auto ptr = reinterpret_cast<const SubGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MulGrad: {
      auto ptr = reinterpret_cast<const MulGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DivGrad: {
      auto ptr = reinterpret_cast<const DivGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PowerGrad: {
      auto ptr = reinterpret_cast<const PowerGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ActivationGrad: {
      auto ptr = reinterpret_cast<const ActivationGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_PriorBox: {
      auto ptr = reinterpret_cast<const PriorBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SpaceToBatchND: {
      auto ptr = reinterpret_cast<const SpaceToBatchND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Depend: {
      auto ptr = reinterpret_cast<const Depend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Return: {
      auto ptr = reinterpret_cast<const Return *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MakeTuple: {
      auto ptr = reinterpret_cast<const MakeTuple *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ToFormat: {
      auto ptr = reinterpret_cast<const ToFormat *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Proposal: {
      auto ptr = reinterpret_cast<const Proposal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Custom: {
      auto ptr = reinterpret_cast<const Custom *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BlackBox: {
      auto ptr = reinterpret_cast<const BlackBox *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NegGrad: {
      auto ptr = reinterpret_cast<const NegGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LogGrad: {
      auto ptr = reinterpret_cast<const LogGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BatchToSpaceND: {
      auto ptr = reinterpret_cast<const BatchToSpaceND *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LshProjection: {
      auto ptr = reinterpret_cast<const LshProjection *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_HashtableLookup: {
      auto ptr = reinterpret_cast<const HashtableLookup *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SkipGram: {
      auto ptr = reinterpret_cast<const SkipGram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DeConv2DGradFilter: {
      auto ptr = reinterpret_cast<const DeConv2DGradFilter *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomPredict: {
      auto ptr = reinterpret_cast<const CustomPredict *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomNormalize: {
      auto ptr = reinterpret_cast<const CustomNormalize *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_CustomExtractFeatures: {
      auto ptr = reinterpret_cast<const CustomExtractFeatures *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AudioSpectrogram: {
      auto ptr = reinterpret_cast<const AudioSpectrogram *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mfcc: {
      auto ptr = reinterpret_cast<const Mfcc *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Rfft: {
      auto ptr = reinterpret_cast<const Rfft *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftReal: {
      auto ptr = reinterpret_cast<const FftReal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_FftImag: {
      auto ptr = reinterpret_cast<const FftImag *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Sgd: {
      auto ptr = reinterpret_cast<const Sgd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adam: {
      auto ptr = reinterpret_cast<const Adam *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GroupConv2DGradInput: {
      auto ptr = reinterpret_cast<const GroupConv2DGradInput *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Loop: {
      auto ptr = reinterpret_cast<const Loop *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_NonMaxSuppression: {
      auto ptr = reinterpret_cast<const NonMaxSuppression *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_InstanceNorm: {
      auto ptr = reinterpret_cast<const InstanceNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Identity: {
      auto ptr = reinterpret_cast<const Identity *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LayerNorm: {
      auto ptr = reinterpret_cast<const LayerNorm *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_While: {
      auto ptr = reinterpret_cast<const While *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_ControlDepend: {
      auto ptr = reinterpret_cast<const ControlDepend *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_UnsortedSegmentSum: {
      auto ptr = reinterpret_cast<const UnsortedSegmentSum *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_AssignAdd: {
      auto ptr = reinterpret_cast<const AssignAdd *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_OnesLike: {
      auto ptr = reinterpret_cast<const OnesLike *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropyGrad: {
      auto ptr = reinterpret_cast<const BinaryCrossEntropyGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_BinaryCrossEntropy: {
      auto ptr = reinterpret_cast<const BinaryCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_LpNormalization: {
      auto ptr = reinterpret_cast<const LpNormalization *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_DropoutGrad: {
      auto ptr = reinterpret_cast<const DropoutGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MaximumGrad: {
      auto ptr = reinterpret_cast<const MaximumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_MinimumGrad: {
      auto ptr = reinterpret_cast<const MinimumGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Switch: {
      auto ptr = reinterpret_cast<const Switch *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Partial: {
      auto ptr = reinterpret_cast<const Partial *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListFromTensor: {
      auto ptr = reinterpret_cast<const TensorListFromTensor *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListStack: {
      auto ptr = reinterpret_cast<const TensorListStack *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListGetItem: {
      auto ptr = reinterpret_cast<const TensorListGetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListSetItem: {
      auto ptr = reinterpret_cast<const TensorListSetItem *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_TensorListReserve: {
      auto ptr = reinterpret_cast<const TensorListReserve *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_All: {
      auto ptr = reinterpret_cast<const All *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Assert: {
      auto ptr = reinterpret_cast<const Assert *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Adder: {
      auto ptr = reinterpret_cast<const Adder *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SparseSoftmaxCrossEntropy: {
      auto ptr = reinterpret_cast<const SparseSoftmaxCrossEntropy *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1Loss: {
      auto ptr = reinterpret_cast<const SmoothL1Loss *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SmoothL1LossGrad: {
      auto ptr = reinterpret_cast<const SmoothL1LossGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogits: {
      auto ptr = reinterpret_cast<const SigmoidCrossEntropyWithLogits *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_SigmoidCrossEntropyWithLogitsGrad: {
      auto ptr = reinterpret_cast<const SigmoidCrossEntropyWithLogitsGrad *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Reciprocal: {
      auto ptr = reinterpret_cast<const Reciprocal *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Merge: {
      auto ptr = reinterpret_cast<const Merge *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_Mod: {
      auto ptr = reinterpret_cast<const Mod *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case PrimitiveType_GeLU: {
      auto ptr = reinterpret_cast<const GeLU *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return false;
  }
}

inline bool VerifyPrimitiveTypeVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPrimitiveType(
        verifier,  values->Get(i), types->GetEnum<PrimitiveType>(i))) {
      return false;
    }
  }
  return true;
}

inline const mindspore::schema::MetaGraph *GetMetaGraph(const void *buf) {
  return flatbuffers::GetRoot<mindspore::schema::MetaGraph>(buf);
}

inline const mindspore::schema::MetaGraph *GetSizePrefixedMetaGraph(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<mindspore::schema::MetaGraph>(buf);
}

inline const char *MetaGraphIdentifier() {
  return "MSL1";
}

inline bool MetaGraphBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, MetaGraphIdentifier());
}

inline bool VerifyMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<mindspore::schema::MetaGraph>(MetaGraphIdentifier());
}

inline bool VerifySizePrefixedMetaGraphBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<mindspore::schema::MetaGraph>(MetaGraphIdentifier());
}

inline const char *MetaGraphExtension() {
  return "ms";
}

inline void FinishMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
  fbb.Finish(root, MetaGraphIdentifier());
}

inline void FinishSizePrefixedMetaGraphBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<mindspore::schema::MetaGraph> root) {
  fbb.FinishSizePrefixed(root, MetaGraphIdentifier());
}

}  // namespace schema
}  // namespace mindspore

#endif  // FLATBUFFERS_GENERATED_MODEL_MINDSPORE_SCHEMA_H_
